
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activitylog
 * 
 */
export type activitylog = $Result.DefaultSelection<Prisma.$activitylogPayload>
/**
 * Model agreementstatus
 * 
 */
export type agreementstatus = $Result.DefaultSelection<Prisma.$agreementstatusPayload>
/**
 * Model attendancelog
 * 
 */
export type attendancelog = $Result.DefaultSelection<Prisma.$attendancelogPayload>
/**
 * Model attendancesummary
 * 
 */
export type attendancesummary = $Result.DefaultSelection<Prisma.$attendancesummaryPayload>
/**
 * Model complaint
 * 
 */
export type complaint = $Result.DefaultSelection<Prisma.$complaintPayload>
/**
 * Model department
 * 
 */
export type department = $Result.DefaultSelection<Prisma.$departmentPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model employeeshift
 * 
 */
export type employeeshift = $Result.DefaultSelection<Prisma.$employeeshiftPayload>
/**
 * Model employmenttype
 * 
 */
export type employmenttype = $Result.DefaultSelection<Prisma.$employmenttypePayload>
/**
 * Model holiday
 * 
 */
export type holiday = $Result.DefaultSelection<Prisma.$holidayPayload>
/**
 * Model interview
 * 
 */
export type interview = $Result.DefaultSelection<Prisma.$interviewPayload>
/**
 * Model jobstatus
 * 
 */
export type jobstatus = $Result.DefaultSelection<Prisma.$jobstatusPayload>
/**
 * Model leave
 * 
 */
export type leave = $Result.DefaultSelection<Prisma.$leavePayload>
/**
 * Model maritalstatus
 * 
 */
export type maritalstatus = $Result.DefaultSelection<Prisma.$maritalstatusPayload>
/**
 * Model meeting
 * 
 */
export type meeting = $Result.DefaultSelection<Prisma.$meetingPayload>
/**
 * Model overtimelog
 * 
 */
export type overtimelog = $Result.DefaultSelection<Prisma.$overtimelogPayload>
/**
 * Model payrollpolicy
 * 
 */
export type payrollpolicy = $Result.DefaultSelection<Prisma.$payrollpolicyPayload>
/**
 * Model performancereview
 * 
 */
export type performancereview = $Result.DefaultSelection<Prisma.$performancereviewPayload>
/**
 * Model position
 * 
 */
export type position = $Result.DefaultSelection<Prisma.$positionPayload>
/**
 * Model role
 * 
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>
/**
 * Model salary
 * 
 */
export type salary = $Result.DefaultSelection<Prisma.$salaryPayload>
/**
 * Model sessiondefinition
 * 
 */
export type sessiondefinition = $Result.DefaultSelection<Prisma.$sessiondefinitionPayload>
/**
 * Model shift
 * 
 */
export type shift = $Result.DefaultSelection<Prisma.$shiftPayload>
/**
 * Model termination
 * 
 */
export type termination = $Result.DefaultSelection<Prisma.$terminationPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const activitylog_type: {
  ATTENDANCE_MARKED: 'ATTENDANCE_MARKED',
  REVIEW_SUBMITTED: 'REVIEW_SUBMITTED',
  OVERTIME_REQUESTED: 'OVERTIME_REQUESTED',
  LEAVE_REQUESTED: 'LEAVE_REQUESTED',
  COMPLAINT_SUBMITTED: 'COMPLAINT_SUBMITTED',
  LEAVE_ACTIONED: 'LEAVE_ACTIONED',
  OVERTIME_ACTIONED: 'OVERTIME_ACTIONED'
};

export type activitylog_type = (typeof activitylog_type)[keyof typeof activitylog_type]


export const leave_leaveType: {
  annual: 'annual',
  sick: 'sick',
  unpaid: 'unpaid',
  maternity: 'maternity',
  other: 'other'
};

export type leave_leaveType = (typeof leave_leaveType)[keyof typeof leave_leaveType]


export const attendancesummary_status: {
  present: 'present',
  absent: 'absent',
  half_day: 'half_day',
  on_leave: 'on_leave',
  permission: 'permission',
  holiday: 'holiday',
  weekend: 'weekend'
};

export type attendancesummary_status = (typeof attendancesummary_status)[keyof typeof attendancesummary_status]


export const complaint_status: {
  open: 'open',
  in_review: 'in_review',
  resolved: 'resolved',
  rejected: 'rejected'
};

export type complaint_status = (typeof complaint_status)[keyof typeof complaint_status]


export const interview_result: {
  pending: 'pending',
  selected: 'selected',
  rejected: 'rejected'
};

export type interview_result = (typeof interview_result)[keyof typeof interview_result]


export const salary_status: {
  paid: 'paid',
  unpaid: 'unpaid',
  pending: 'pending'
};

export type salary_status = (typeof salary_status)[keyof typeof salary_status]


export const termination_status: {
  voluntary: 'voluntary',
  involuntary: 'involuntary',
  retired: 'retired'
};

export type termination_status = (typeof termination_status)[keyof typeof termination_status]


export const leave_status: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type leave_status = (typeof leave_status)[keyof typeof leave_status]


export const attendancelog_status: {
  present: 'present',
  late: 'late',
  absent: 'absent',
  permission: 'permission'
};

export type attendancelog_status = (typeof attendancelog_status)[keyof typeof attendancelog_status]


export const employee_sex: {
  male: 'male',
  female: 'female'
};

export type employee_sex = (typeof employee_sex)[keyof typeof employee_sex]


export const overtimelog_approvalStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type overtimelog_approvalStatus = (typeof overtimelog_approvalStatus)[keyof typeof overtimelog_approvalStatus]


export const overtimelog_compensationMethod: {
  cash: 'cash',
  time_off: 'time_off'
};

export type overtimelog_compensationMethod = (typeof overtimelog_compensationMethod)[keyof typeof overtimelog_compensationMethod]


export const termination_workflowStatus: {
  pending_approval: 'pending_approval',
  processing: 'processing',
  finalized: 'finalized'
};

export type termination_workflowStatus = (typeof termination_workflowStatus)[keyof typeof termination_workflowStatus]


export const overtimelog_overtimeType: {
  WEEKDAY: 'WEEKDAY',
  SUNDAY: 'SUNDAY',
  HOLIDAY: 'HOLIDAY'
};

export type overtimelog_overtimeType = (typeof overtimelog_overtimeType)[keyof typeof overtimelog_overtimeType]

}

export type activitylog_type = $Enums.activitylog_type

export const activitylog_type: typeof $Enums.activitylog_type

export type leave_leaveType = $Enums.leave_leaveType

export const leave_leaveType: typeof $Enums.leave_leaveType

export type attendancesummary_status = $Enums.attendancesummary_status

export const attendancesummary_status: typeof $Enums.attendancesummary_status

export type complaint_status = $Enums.complaint_status

export const complaint_status: typeof $Enums.complaint_status

export type interview_result = $Enums.interview_result

export const interview_result: typeof $Enums.interview_result

export type salary_status = $Enums.salary_status

export const salary_status: typeof $Enums.salary_status

export type termination_status = $Enums.termination_status

export const termination_status: typeof $Enums.termination_status

export type leave_status = $Enums.leave_status

export const leave_status: typeof $Enums.leave_status

export type attendancelog_status = $Enums.attendancelog_status

export const attendancelog_status: typeof $Enums.attendancelog_status

export type employee_sex = $Enums.employee_sex

export const employee_sex: typeof $Enums.employee_sex

export type overtimelog_approvalStatus = $Enums.overtimelog_approvalStatus

export const overtimelog_approvalStatus: typeof $Enums.overtimelog_approvalStatus

export type overtimelog_compensationMethod = $Enums.overtimelog_compensationMethod

export const overtimelog_compensationMethod: typeof $Enums.overtimelog_compensationMethod

export type termination_workflowStatus = $Enums.termination_workflowStatus

export const termination_workflowStatus: typeof $Enums.termination_workflowStatus

export type overtimelog_overtimeType = $Enums.overtimelog_overtimeType

export const overtimelog_overtimeType: typeof $Enums.overtimelog_overtimeType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activitylogs
 * const activitylogs = await prisma.activitylog.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activitylogs
   * const activitylogs = await prisma.activitylog.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activitylog`: Exposes CRUD operations for the **activitylog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activitylogs
    * const activitylogs = await prisma.activitylog.findMany()
    * ```
    */
  get activitylog(): Prisma.activitylogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agreementstatus`: Exposes CRUD operations for the **agreementstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agreementstatuses
    * const agreementstatuses = await prisma.agreementstatus.findMany()
    * ```
    */
  get agreementstatus(): Prisma.agreementstatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendancelog`: Exposes CRUD operations for the **attendancelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendancelogs
    * const attendancelogs = await prisma.attendancelog.findMany()
    * ```
    */
  get attendancelog(): Prisma.attendancelogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendancesummary`: Exposes CRUD operations for the **attendancesummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendancesummaries
    * const attendancesummaries = await prisma.attendancesummary.findMany()
    * ```
    */
  get attendancesummary(): Prisma.attendancesummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.complaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.departmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeshift`: Exposes CRUD operations for the **employeeshift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employeeshifts
    * const employeeshifts = await prisma.employeeshift.findMany()
    * ```
    */
  get employeeshift(): Prisma.employeeshiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmenttype`: Exposes CRUD operations for the **employmenttype** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employmenttypes
    * const employmenttypes = await prisma.employmenttype.findMany()
    * ```
    */
  get employmenttype(): Prisma.employmenttypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.holidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.interviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobstatus`: Exposes CRUD operations for the **jobstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobstatuses
    * const jobstatuses = await prisma.jobstatus.findMany()
    * ```
    */
  get jobstatus(): Prisma.jobstatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.leaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maritalstatus`: Exposes CRUD operations for the **maritalstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maritalstatuses
    * const maritalstatuses = await prisma.maritalstatus.findMany()
    * ```
    */
  get maritalstatus(): Prisma.maritalstatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.meetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtimelog`: Exposes CRUD operations for the **overtimelog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overtimelogs
    * const overtimelogs = await prisma.overtimelog.findMany()
    * ```
    */
  get overtimelog(): Prisma.overtimelogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollpolicy`: Exposes CRUD operations for the **payrollpolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrollpolicies
    * const payrollpolicies = await prisma.payrollpolicy.findMany()
    * ```
    */
  get payrollpolicy(): Prisma.payrollpolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performancereview`: Exposes CRUD operations for the **performancereview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Performancereviews
    * const performancereviews = await prisma.performancereview.findMany()
    * ```
    */
  get performancereview(): Prisma.performancereviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.positionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.salaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessiondefinition`: Exposes CRUD operations for the **sessiondefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessiondefinitions
    * const sessiondefinitions = await prisma.sessiondefinition.findMany()
    * ```
    */
  get sessiondefinition(): Prisma.sessiondefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.shiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termination`: Exposes CRUD operations for the **termination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terminations
    * const terminations = await prisma.termination.findMany()
    * ```
    */
  get termination(): Prisma.terminationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activitylog: 'activitylog',
    agreementstatus: 'agreementstatus',
    attendancelog: 'attendancelog',
    attendancesummary: 'attendancesummary',
    complaint: 'complaint',
    department: 'department',
    employee: 'employee',
    employeeshift: 'employeeshift',
    employmenttype: 'employmenttype',
    holiday: 'holiday',
    interview: 'interview',
    jobstatus: 'jobstatus',
    leave: 'leave',
    maritalstatus: 'maritalstatus',
    meeting: 'meeting',
    overtimelog: 'overtimelog',
    payrollpolicy: 'payrollpolicy',
    performancereview: 'performancereview',
    position: 'position',
    role: 'role',
    salary: 'salary',
    sessiondefinition: 'sessiondefinition',
    shift: 'shift',
    termination: 'termination',
    user: 'user',
    userrole: 'userrole'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activitylog" | "agreementstatus" | "attendancelog" | "attendancesummary" | "complaint" | "department" | "employee" | "employeeshift" | "employmenttype" | "holiday" | "interview" | "jobstatus" | "leave" | "maritalstatus" | "meeting" | "overtimelog" | "payrollpolicy" | "performancereview" | "position" | "role" | "salary" | "sessiondefinition" | "shift" | "termination" | "user" | "userrole"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activitylog: {
        payload: Prisma.$activitylogPayload<ExtArgs>
        fields: Prisma.activitylogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activitylogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activitylogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          findFirst: {
            args: Prisma.activitylogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activitylogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          findMany: {
            args: Prisma.activitylogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>[]
          }
          create: {
            args: Prisma.activitylogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          createMany: {
            args: Prisma.activitylogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.activitylogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          update: {
            args: Prisma.activitylogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          deleteMany: {
            args: Prisma.activitylogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activitylogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.activitylogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activitylogPayload>
          }
          aggregate: {
            args: Prisma.ActivitylogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivitylog>
          }
          groupBy: {
            args: Prisma.activitylogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivitylogGroupByOutputType>[]
          }
          count: {
            args: Prisma.activitylogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivitylogCountAggregateOutputType> | number
          }
        }
      }
      agreementstatus: {
        payload: Prisma.$agreementstatusPayload<ExtArgs>
        fields: Prisma.agreementstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agreementstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agreementstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          findFirst: {
            args: Prisma.agreementstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agreementstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          findMany: {
            args: Prisma.agreementstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>[]
          }
          create: {
            args: Prisma.agreementstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          createMany: {
            args: Prisma.agreementstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agreementstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          update: {
            args: Prisma.agreementstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          deleteMany: {
            args: Prisma.agreementstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agreementstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agreementstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agreementstatusPayload>
          }
          aggregate: {
            args: Prisma.AgreementstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreementstatus>
          }
          groupBy: {
            args: Prisma.agreementstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.agreementstatusCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementstatusCountAggregateOutputType> | number
          }
        }
      }
      attendancelog: {
        payload: Prisma.$attendancelogPayload<ExtArgs>
        fields: Prisma.attendancelogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendancelogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendancelogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          findFirst: {
            args: Prisma.attendancelogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendancelogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          findMany: {
            args: Prisma.attendancelogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>[]
          }
          create: {
            args: Prisma.attendancelogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          createMany: {
            args: Prisma.attendancelogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendancelogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          update: {
            args: Prisma.attendancelogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          deleteMany: {
            args: Prisma.attendancelogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendancelogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendancelogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancelogPayload>
          }
          aggregate: {
            args: Prisma.AttendancelogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendancelog>
          }
          groupBy: {
            args: Prisma.attendancelogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancelogGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendancelogCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancelogCountAggregateOutputType> | number
          }
        }
      }
      attendancesummary: {
        payload: Prisma.$attendancesummaryPayload<ExtArgs>
        fields: Prisma.attendancesummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendancesummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendancesummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          findFirst: {
            args: Prisma.attendancesummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendancesummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          findMany: {
            args: Prisma.attendancesummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>[]
          }
          create: {
            args: Prisma.attendancesummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          createMany: {
            args: Prisma.attendancesummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.attendancesummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          update: {
            args: Prisma.attendancesummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          deleteMany: {
            args: Prisma.attendancesummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendancesummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.attendancesummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancesummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendancesummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendancesummary>
          }
          groupBy: {
            args: Prisma.attendancesummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendancesummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendancesummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendancesummaryCountAggregateOutputType> | number
          }
        }
      }
      complaint: {
        payload: Prisma.$complaintPayload<ExtArgs>
        fields: Prisma.complaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.complaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.complaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          findFirst: {
            args: Prisma.complaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.complaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          findMany: {
            args: Prisma.complaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>[]
          }
          create: {
            args: Prisma.complaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          createMany: {
            args: Prisma.complaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.complaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          update: {
            args: Prisma.complaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          deleteMany: {
            args: Prisma.complaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.complaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.complaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$complaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.complaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.complaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      department: {
        payload: Prisma.$departmentPayload<ExtArgs>
        fields: Prisma.departmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findFirst: {
            args: Prisma.departmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          findMany: {
            args: Prisma.departmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>[]
          }
          create: {
            args: Prisma.departmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          createMany: {
            args: Prisma.departmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.departmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          update: {
            args: Prisma.departmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          deleteMany: {
            args: Prisma.departmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.departmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.departmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$departmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.departmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      employeeshift: {
        payload: Prisma.$employeeshiftPayload<ExtArgs>
        fields: Prisma.employeeshiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeshiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeshiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          findFirst: {
            args: Prisma.employeeshiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeshiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          findMany: {
            args: Prisma.employeeshiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>[]
          }
          create: {
            args: Prisma.employeeshiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          createMany: {
            args: Prisma.employeeshiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employeeshiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          update: {
            args: Prisma.employeeshiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          deleteMany: {
            args: Prisma.employeeshiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeshiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employeeshiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeshiftPayload>
          }
          aggregate: {
            args: Prisma.EmployeeshiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeshift>
          }
          groupBy: {
            args: Prisma.employeeshiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeshiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeshiftCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeshiftCountAggregateOutputType> | number
          }
        }
      }
      employmenttype: {
        payload: Prisma.$employmenttypePayload<ExtArgs>
        fields: Prisma.employmenttypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employmenttypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employmenttypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          findFirst: {
            args: Prisma.employmenttypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employmenttypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          findMany: {
            args: Prisma.employmenttypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>[]
          }
          create: {
            args: Prisma.employmenttypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          createMany: {
            args: Prisma.employmenttypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.employmenttypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          update: {
            args: Prisma.employmenttypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          deleteMany: {
            args: Prisma.employmenttypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employmenttypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.employmenttypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employmenttypePayload>
          }
          aggregate: {
            args: Prisma.EmploymenttypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymenttype>
          }
          groupBy: {
            args: Prisma.employmenttypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymenttypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employmenttypeCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymenttypeCountAggregateOutputType> | number
          }
        }
      }
      holiday: {
        payload: Prisma.$holidayPayload<ExtArgs>
        fields: Prisma.holidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.holidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.holidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          findFirst: {
            args: Prisma.holidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.holidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          findMany: {
            args: Prisma.holidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>[]
          }
          create: {
            args: Prisma.holidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          createMany: {
            args: Prisma.holidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.holidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          update: {
            args: Prisma.holidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          deleteMany: {
            args: Prisma.holidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.holidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.holidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$holidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.holidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.holidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      interview: {
        payload: Prisma.$interviewPayload<ExtArgs>
        fields: Prisma.interviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.interviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.interviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          findFirst: {
            args: Prisma.interviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.interviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          findMany: {
            args: Prisma.interviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>[]
          }
          create: {
            args: Prisma.interviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          createMany: {
            args: Prisma.interviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.interviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          update: {
            args: Prisma.interviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          deleteMany: {
            args: Prisma.interviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.interviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.interviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$interviewPayload>
          }
          aggregate: {
            args: Prisma.InterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterview>
          }
          groupBy: {
            args: Prisma.interviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.interviewCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewCountAggregateOutputType> | number
          }
        }
      }
      jobstatus: {
        payload: Prisma.$jobstatusPayload<ExtArgs>
        fields: Prisma.jobstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          findFirst: {
            args: Prisma.jobstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          findMany: {
            args: Prisma.jobstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>[]
          }
          create: {
            args: Prisma.jobstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          createMany: {
            args: Prisma.jobstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          update: {
            args: Prisma.jobstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          deleteMany: {
            args: Prisma.jobstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobstatusPayload>
          }
          aggregate: {
            args: Prisma.JobstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobstatus>
          }
          groupBy: {
            args: Prisma.jobstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobstatusCountArgs<ExtArgs>
            result: $Utils.Optional<JobstatusCountAggregateOutputType> | number
          }
        }
      }
      leave: {
        payload: Prisma.$leavePayload<ExtArgs>
        fields: Prisma.leaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.leaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.leaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          findFirst: {
            args: Prisma.leaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.leaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          findMany: {
            args: Prisma.leaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>[]
          }
          create: {
            args: Prisma.leaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          createMany: {
            args: Prisma.leaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.leaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          update: {
            args: Prisma.leaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          deleteMany: {
            args: Prisma.leaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.leaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.leaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$leavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.leaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.leaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      maritalstatus: {
        payload: Prisma.$maritalstatusPayload<ExtArgs>
        fields: Prisma.maritalstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.maritalstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.maritalstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          findFirst: {
            args: Prisma.maritalstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.maritalstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          findMany: {
            args: Prisma.maritalstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>[]
          }
          create: {
            args: Prisma.maritalstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          createMany: {
            args: Prisma.maritalstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.maritalstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          update: {
            args: Prisma.maritalstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          deleteMany: {
            args: Prisma.maritalstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.maritalstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.maritalstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$maritalstatusPayload>
          }
          aggregate: {
            args: Prisma.MaritalstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaritalstatus>
          }
          groupBy: {
            args: Prisma.maritalstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaritalstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.maritalstatusCountArgs<ExtArgs>
            result: $Utils.Optional<MaritalstatusCountAggregateOutputType> | number
          }
        }
      }
      meeting: {
        payload: Prisma.$meetingPayload<ExtArgs>
        fields: Prisma.meetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.meetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.meetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          findFirst: {
            args: Prisma.meetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.meetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          findMany: {
            args: Prisma.meetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>[]
          }
          create: {
            args: Prisma.meetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          createMany: {
            args: Prisma.meetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.meetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          update: {
            args: Prisma.meetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          deleteMany: {
            args: Prisma.meetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.meetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.meetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$meetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.meetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.meetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      overtimelog: {
        payload: Prisma.$overtimelogPayload<ExtArgs>
        fields: Prisma.overtimelogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.overtimelogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.overtimelogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          findFirst: {
            args: Prisma.overtimelogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.overtimelogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          findMany: {
            args: Prisma.overtimelogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>[]
          }
          create: {
            args: Prisma.overtimelogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          createMany: {
            args: Prisma.overtimelogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.overtimelogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          update: {
            args: Prisma.overtimelogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          deleteMany: {
            args: Prisma.overtimelogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.overtimelogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.overtimelogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$overtimelogPayload>
          }
          aggregate: {
            args: Prisma.OvertimelogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertimelog>
          }
          groupBy: {
            args: Prisma.overtimelogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimelogGroupByOutputType>[]
          }
          count: {
            args: Prisma.overtimelogCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimelogCountAggregateOutputType> | number
          }
        }
      }
      payrollpolicy: {
        payload: Prisma.$payrollpolicyPayload<ExtArgs>
        fields: Prisma.payrollpolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payrollpolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payrollpolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          findFirst: {
            args: Prisma.payrollpolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payrollpolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          findMany: {
            args: Prisma.payrollpolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>[]
          }
          create: {
            args: Prisma.payrollpolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          createMany: {
            args: Prisma.payrollpolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.payrollpolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          update: {
            args: Prisma.payrollpolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          deleteMany: {
            args: Prisma.payrollpolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payrollpolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.payrollpolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payrollpolicyPayload>
          }
          aggregate: {
            args: Prisma.PayrollpolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollpolicy>
          }
          groupBy: {
            args: Prisma.payrollpolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollpolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.payrollpolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollpolicyCountAggregateOutputType> | number
          }
        }
      }
      performancereview: {
        payload: Prisma.$performancereviewPayload<ExtArgs>
        fields: Prisma.performancereviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.performancereviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.performancereviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          findFirst: {
            args: Prisma.performancereviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.performancereviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          findMany: {
            args: Prisma.performancereviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>[]
          }
          create: {
            args: Prisma.performancereviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          createMany: {
            args: Prisma.performancereviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.performancereviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          update: {
            args: Prisma.performancereviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          deleteMany: {
            args: Prisma.performancereviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.performancereviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.performancereviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancereviewPayload>
          }
          aggregate: {
            args: Prisma.PerformancereviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformancereview>
          }
          groupBy: {
            args: Prisma.performancereviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformancereviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.performancereviewCountArgs<ExtArgs>
            result: $Utils.Optional<PerformancereviewCountAggregateOutputType> | number
          }
        }
      }
      position: {
        payload: Prisma.$positionPayload<ExtArgs>
        fields: Prisma.positionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.positionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.positionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          findFirst: {
            args: Prisma.positionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.positionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          findMany: {
            args: Prisma.positionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>[]
          }
          create: {
            args: Prisma.positionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          createMany: {
            args: Prisma.positionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.positionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          update: {
            args: Prisma.positionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          deleteMany: {
            args: Prisma.positionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.positionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.positionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$positionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.positionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.positionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      role: {
        payload: Prisma.$rolePayload<ExtArgs>
        fields: Prisma.roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[]
          }
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.roleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      salary: {
        payload: Prisma.$salaryPayload<ExtArgs>
        fields: Prisma.salaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.salaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.salaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          findFirst: {
            args: Prisma.salaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.salaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          findMany: {
            args: Prisma.salaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>[]
          }
          create: {
            args: Prisma.salaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          createMany: {
            args: Prisma.salaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.salaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          update: {
            args: Prisma.salaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          deleteMany: {
            args: Prisma.salaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.salaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.salaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$salaryPayload>
          }
          aggregate: {
            args: Prisma.SalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalary>
          }
          groupBy: {
            args: Prisma.salaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.salaryCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryCountAggregateOutputType> | number
          }
        }
      }
      sessiondefinition: {
        payload: Prisma.$sessiondefinitionPayload<ExtArgs>
        fields: Prisma.sessiondefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessiondefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessiondefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          findFirst: {
            args: Prisma.sessiondefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessiondefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          findMany: {
            args: Prisma.sessiondefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>[]
          }
          create: {
            args: Prisma.sessiondefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          createMany: {
            args: Prisma.sessiondefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessiondefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          update: {
            args: Prisma.sessiondefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          deleteMany: {
            args: Prisma.sessiondefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessiondefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessiondefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessiondefinitionPayload>
          }
          aggregate: {
            args: Prisma.SessiondefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessiondefinition>
          }
          groupBy: {
            args: Prisma.sessiondefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessiondefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessiondefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<SessiondefinitionCountAggregateOutputType> | number
          }
        }
      }
      shift: {
        payload: Prisma.$shiftPayload<ExtArgs>
        fields: Prisma.shiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.shiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.shiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          findFirst: {
            args: Prisma.shiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.shiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          findMany: {
            args: Prisma.shiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>[]
          }
          create: {
            args: Prisma.shiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          createMany: {
            args: Prisma.shiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.shiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          update: {
            args: Prisma.shiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          deleteMany: {
            args: Prisma.shiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.shiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.shiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$shiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.shiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.shiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      termination: {
        payload: Prisma.$terminationPayload<ExtArgs>
        fields: Prisma.terminationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.terminationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.terminationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          findFirst: {
            args: Prisma.terminationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.terminationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          findMany: {
            args: Prisma.terminationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>[]
          }
          create: {
            args: Prisma.terminationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          createMany: {
            args: Prisma.terminationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.terminationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          update: {
            args: Prisma.terminationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          deleteMany: {
            args: Prisma.terminationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.terminationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.terminationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$terminationPayload>
          }
          aggregate: {
            args: Prisma.TerminationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermination>
          }
          groupBy: {
            args: Prisma.terminationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminationGroupByOutputType>[]
          }
          count: {
            args: Prisma.terminationCountArgs<ExtArgs>
            result: $Utils.Optional<TerminationCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activitylog?: activitylogOmit
    agreementstatus?: agreementstatusOmit
    attendancelog?: attendancelogOmit
    attendancesummary?: attendancesummaryOmit
    complaint?: complaintOmit
    department?: departmentOmit
    employee?: employeeOmit
    employeeshift?: employeeshiftOmit
    employmenttype?: employmenttypeOmit
    holiday?: holidayOmit
    interview?: interviewOmit
    jobstatus?: jobstatusOmit
    leave?: leaveOmit
    maritalstatus?: maritalstatusOmit
    meeting?: meetingOmit
    overtimelog?: overtimelogOmit
    payrollpolicy?: payrollpolicyOmit
    performancereview?: performancereviewOmit
    position?: positionOmit
    role?: roleOmit
    salary?: salaryOmit
    sessiondefinition?: sessiondefinitionOmit
    shift?: shiftOmit
    termination?: terminationOmit
    user?: userOmit
    userrole?: userroleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgreementstatusCountOutputType
   */

  export type AgreementstatusCountOutputType = {
    employee: number
  }

  export type AgreementstatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | AgreementstatusCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * AgreementstatusCountOutputType without action
   */
  export type AgreementstatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementstatusCountOutputType
     */
    select?: AgreementstatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementstatusCountOutputType without action
   */
  export type AgreementstatusCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    attendancesummary: number
    other_department: number
    employee_employee_departmentIdTodepartment: number
    employee_employee_subDepartmentIdTodepartment: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendancesummary?: boolean | DepartmentCountOutputTypeCountAttendancesummaryArgs
    other_department?: boolean | DepartmentCountOutputTypeCountOther_departmentArgs
    employee_employee_departmentIdTodepartment?: boolean | DepartmentCountOutputTypeCountEmployee_employee_departmentIdTodepartmentArgs
    employee_employee_subDepartmentIdTodepartment?: boolean | DepartmentCountOutputTypeCountEmployee_employee_subDepartmentIdTodepartmentArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAttendancesummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesummaryWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountOther_departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployee_employee_departmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployee_employee_subDepartmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    activitylog_activitylog_actorIdToemployee: number
    activitylog_activitylog_targetIdToemployee: number
    attendancelog: number
    attendancesummary: number
    complaint: number
    employeeshift: number
    leave: number
    meeting: number
    overtimelog: number
    performancereview: number
    salaryRecords: number
    termination: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitylog_activitylog_actorIdToemployee?: boolean | EmployeeCountOutputTypeCountActivitylog_activitylog_actorIdToemployeeArgs
    activitylog_activitylog_targetIdToemployee?: boolean | EmployeeCountOutputTypeCountActivitylog_activitylog_targetIdToemployeeArgs
    attendancelog?: boolean | EmployeeCountOutputTypeCountAttendancelogArgs
    attendancesummary?: boolean | EmployeeCountOutputTypeCountAttendancesummaryArgs
    complaint?: boolean | EmployeeCountOutputTypeCountComplaintArgs
    employeeshift?: boolean | EmployeeCountOutputTypeCountEmployeeshiftArgs
    leave?: boolean | EmployeeCountOutputTypeCountLeaveArgs
    meeting?: boolean | EmployeeCountOutputTypeCountMeetingArgs
    overtimelog?: boolean | EmployeeCountOutputTypeCountOvertimelogArgs
    performancereview?: boolean | EmployeeCountOutputTypeCountPerformancereviewArgs
    salaryRecords?: boolean | EmployeeCountOutputTypeCountSalaryRecordsArgs
    termination?: boolean | EmployeeCountOutputTypeCountTerminationArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountActivitylog_activitylog_actorIdToemployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitylogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountActivitylog_activitylog_targetIdToemployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitylogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancelogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendancesummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesummaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountComplaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeshiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeshiftWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountMeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meetingWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOvertimelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: overtimelogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPerformancereviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performancereviewWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTerminationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terminationWhereInput
  }


  /**
   * Count Type EmploymenttypeCountOutputType
   */

  export type EmploymenttypeCountOutputType = {
    employee: number
  }

  export type EmploymenttypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmploymenttypeCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * EmploymenttypeCountOutputType without action
   */
  export type EmploymenttypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymenttypeCountOutputType
     */
    select?: EmploymenttypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmploymenttypeCountOutputType without action
   */
  export type EmploymenttypeCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type JobstatusCountOutputType
   */

  export type JobstatusCountOutputType = {
    employee: number
  }

  export type JobstatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | JobstatusCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * JobstatusCountOutputType without action
   */
  export type JobstatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobstatusCountOutputType
     */
    select?: JobstatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobstatusCountOutputType without action
   */
  export type JobstatusCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type MaritalstatusCountOutputType
   */

  export type MaritalstatusCountOutputType = {
    employee: number
  }

  export type MaritalstatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | MaritalstatusCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * MaritalstatusCountOutputType without action
   */
  export type MaritalstatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalstatusCountOutputType
     */
    select?: MaritalstatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaritalstatusCountOutputType without action
   */
  export type MaritalstatusCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type PayrollpolicyCountOutputType
   */

  export type PayrollpolicyCountOutputType = {
    department: number
  }

  export type PayrollpolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | PayrollpolicyCountOutputTypeCountDepartmentArgs
  }

  // Custom InputTypes
  /**
   * PayrollpolicyCountOutputType without action
   */
  export type PayrollpolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollpolicyCountOutputType
     */
    select?: PayrollpolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollpolicyCountOutputType without action
   */
  export type PayrollpolicyCountOutputTypeCountDepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    employee: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | PositionCountOutputTypeCountEmployeeArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userrole: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userrole?: boolean | RoleCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Count Type SessiondefinitionCountOutputType
   */

  export type SessiondefinitionCountOutputType = {
    attendancelog: number
  }

  export type SessiondefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendancelog?: boolean | SessiondefinitionCountOutputTypeCountAttendancelogArgs
  }

  // Custom InputTypes
  /**
   * SessiondefinitionCountOutputType without action
   */
  export type SessiondefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessiondefinitionCountOutputType
     */
    select?: SessiondefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessiondefinitionCountOutputType without action
   */
  export type SessiondefinitionCountOutputTypeCountAttendancelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancelogWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    employeeshift: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeshift?: boolean | ShiftCountOutputTypeCountEmployeeshiftArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeeshiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeshiftWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    leave: number
    overtimelog: number
    userrole: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leave?: boolean | UserCountOutputTypeCountLeaveArgs
    overtimelog?: boolean | UserCountOutputTypeCountOvertimelogArgs
    userrole?: boolean | UserCountOutputTypeCountUserroleArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOvertimelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: overtimelogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activitylog
   */

  export type AggregateActivitylog = {
    _count: ActivitylogCountAggregateOutputType | null
    _avg: ActivitylogAvgAggregateOutputType | null
    _sum: ActivitylogSumAggregateOutputType | null
    _min: ActivitylogMinAggregateOutputType | null
    _max: ActivitylogMaxAggregateOutputType | null
  }

  export type ActivitylogAvgAggregateOutputType = {
    id: number | null
    actorId: number | null
    targetId: number | null
    departmentId: number | null
  }

  export type ActivitylogSumAggregateOutputType = {
    id: number | null
    actorId: number | null
    targetId: number | null
    departmentId: number | null
  }

  export type ActivitylogMinAggregateOutputType = {
    id: number | null
    type: $Enums.activitylog_type | null
    message: string | null
    actorId: number | null
    targetId: number | null
    departmentId: number | null
    createdAt: Date | null
  }

  export type ActivitylogMaxAggregateOutputType = {
    id: number | null
    type: $Enums.activitylog_type | null
    message: string | null
    actorId: number | null
    targetId: number | null
    departmentId: number | null
    createdAt: Date | null
  }

  export type ActivitylogCountAggregateOutputType = {
    id: number
    type: number
    message: number
    actorId: number
    targetId: number
    departmentId: number
    createdAt: number
    _all: number
  }


  export type ActivitylogAvgAggregateInputType = {
    id?: true
    actorId?: true
    targetId?: true
    departmentId?: true
  }

  export type ActivitylogSumAggregateInputType = {
    id?: true
    actorId?: true
    targetId?: true
    departmentId?: true
  }

  export type ActivitylogMinAggregateInputType = {
    id?: true
    type?: true
    message?: true
    actorId?: true
    targetId?: true
    departmentId?: true
    createdAt?: true
  }

  export type ActivitylogMaxAggregateInputType = {
    id?: true
    type?: true
    message?: true
    actorId?: true
    targetId?: true
    departmentId?: true
    createdAt?: true
  }

  export type ActivitylogCountAggregateInputType = {
    id?: true
    type?: true
    message?: true
    actorId?: true
    targetId?: true
    departmentId?: true
    createdAt?: true
    _all?: true
  }

  export type ActivitylogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitylog to aggregate.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activitylogs
    **/
    _count?: true | ActivitylogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivitylogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivitylogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivitylogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivitylogMaxAggregateInputType
  }

  export type GetActivitylogAggregateType<T extends ActivitylogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivitylog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivitylog[P]>
      : GetScalarType<T[P], AggregateActivitylog[P]>
  }




  export type activitylogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activitylogWhereInput
    orderBy?: activitylogOrderByWithAggregationInput | activitylogOrderByWithAggregationInput[]
    by: ActivitylogScalarFieldEnum[] | ActivitylogScalarFieldEnum
    having?: activitylogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivitylogCountAggregateInputType | true
    _avg?: ActivitylogAvgAggregateInputType
    _sum?: ActivitylogSumAggregateInputType
    _min?: ActivitylogMinAggregateInputType
    _max?: ActivitylogMaxAggregateInputType
  }

  export type ActivitylogGroupByOutputType = {
    id: number
    type: $Enums.activitylog_type
    message: string
    actorId: number
    targetId: number | null
    departmentId: number
    createdAt: Date
    _count: ActivitylogCountAggregateOutputType | null
    _avg: ActivitylogAvgAggregateOutputType | null
    _sum: ActivitylogSumAggregateOutputType | null
    _min: ActivitylogMinAggregateOutputType | null
    _max: ActivitylogMaxAggregateOutputType | null
  }

  type GetActivitylogGroupByPayload<T extends activitylogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivitylogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivitylogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivitylogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivitylogGroupByOutputType[P]>
        }
      >
    >


  export type activitylogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    message?: boolean
    actorId?: boolean
    targetId?: boolean
    departmentId?: boolean
    createdAt?: boolean
    employee_activitylog_actorIdToemployee?: boolean | employeeDefaultArgs<ExtArgs>
    employee_activitylog_targetIdToemployee?: boolean | activitylog$employee_activitylog_targetIdToemployeeArgs<ExtArgs>
  }, ExtArgs["result"]["activitylog"]>



  export type activitylogSelectScalar = {
    id?: boolean
    type?: boolean
    message?: boolean
    actorId?: boolean
    targetId?: boolean
    departmentId?: boolean
    createdAt?: boolean
  }

  export type activitylogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "message" | "actorId" | "targetId" | "departmentId" | "createdAt", ExtArgs["result"]["activitylog"]>
  export type activitylogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee_activitylog_actorIdToemployee?: boolean | employeeDefaultArgs<ExtArgs>
    employee_activitylog_targetIdToemployee?: boolean | activitylog$employee_activitylog_targetIdToemployeeArgs<ExtArgs>
  }

  export type $activitylogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activitylog"
    objects: {
      employee_activitylog_actorIdToemployee: Prisma.$employeePayload<ExtArgs>
      employee_activitylog_targetIdToemployee: Prisma.$employeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.activitylog_type
      message: string
      actorId: number
      targetId: number | null
      departmentId: number
      createdAt: Date
    }, ExtArgs["result"]["activitylog"]>
    composites: {}
  }

  type activitylogGetPayload<S extends boolean | null | undefined | activitylogDefaultArgs> = $Result.GetResult<Prisma.$activitylogPayload, S>

  type activitylogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activitylogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivitylogCountAggregateInputType | true
    }

  export interface activitylogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activitylog'], meta: { name: 'activitylog' } }
    /**
     * Find zero or one Activitylog that matches the filter.
     * @param {activitylogFindUniqueArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activitylogFindUniqueArgs>(args: SelectSubset<T, activitylogFindUniqueArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activitylog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activitylogFindUniqueOrThrowArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activitylogFindUniqueOrThrowArgs>(args: SelectSubset<T, activitylogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activitylog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindFirstArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activitylogFindFirstArgs>(args?: SelectSubset<T, activitylogFindFirstArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activitylog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindFirstOrThrowArgs} args - Arguments to find a Activitylog
     * @example
     * // Get one Activitylog
     * const activitylog = await prisma.activitylog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activitylogFindFirstOrThrowArgs>(args?: SelectSubset<T, activitylogFindFirstOrThrowArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activitylogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activitylogs
     * const activitylogs = await prisma.activitylog.findMany()
     * 
     * // Get first 10 Activitylogs
     * const activitylogs = await prisma.activitylog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activitylogWithIdOnly = await prisma.activitylog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activitylogFindManyArgs>(args?: SelectSubset<T, activitylogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activitylog.
     * @param {activitylogCreateArgs} args - Arguments to create a Activitylog.
     * @example
     * // Create one Activitylog
     * const Activitylog = await prisma.activitylog.create({
     *   data: {
     *     // ... data to create a Activitylog
     *   }
     * })
     * 
     */
    create<T extends activitylogCreateArgs>(args: SelectSubset<T, activitylogCreateArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activitylogs.
     * @param {activitylogCreateManyArgs} args - Arguments to create many Activitylogs.
     * @example
     * // Create many Activitylogs
     * const activitylog = await prisma.activitylog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activitylogCreateManyArgs>(args?: SelectSubset<T, activitylogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Activitylog.
     * @param {activitylogDeleteArgs} args - Arguments to delete one Activitylog.
     * @example
     * // Delete one Activitylog
     * const Activitylog = await prisma.activitylog.delete({
     *   where: {
     *     // ... filter to delete one Activitylog
     *   }
     * })
     * 
     */
    delete<T extends activitylogDeleteArgs>(args: SelectSubset<T, activitylogDeleteArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activitylog.
     * @param {activitylogUpdateArgs} args - Arguments to update one Activitylog.
     * @example
     * // Update one Activitylog
     * const activitylog = await prisma.activitylog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activitylogUpdateArgs>(args: SelectSubset<T, activitylogUpdateArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activitylogs.
     * @param {activitylogDeleteManyArgs} args - Arguments to filter Activitylogs to delete.
     * @example
     * // Delete a few Activitylogs
     * const { count } = await prisma.activitylog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activitylogDeleteManyArgs>(args?: SelectSubset<T, activitylogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activitylogs
     * const activitylog = await prisma.activitylog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activitylogUpdateManyArgs>(args: SelectSubset<T, activitylogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activitylog.
     * @param {activitylogUpsertArgs} args - Arguments to update or create a Activitylog.
     * @example
     * // Update or create a Activitylog
     * const activitylog = await prisma.activitylog.upsert({
     *   create: {
     *     // ... data to create a Activitylog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activitylog we want to update
     *   }
     * })
     */
    upsert<T extends activitylogUpsertArgs>(args: SelectSubset<T, activitylogUpsertArgs<ExtArgs>>): Prisma__activitylogClient<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activitylogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogCountArgs} args - Arguments to filter Activitylogs to count.
     * @example
     * // Count the number of Activitylogs
     * const count = await prisma.activitylog.count({
     *   where: {
     *     // ... the filter for the Activitylogs we want to count
     *   }
     * })
    **/
    count<T extends activitylogCountArgs>(
      args?: Subset<T, activitylogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivitylogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivitylogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivitylogAggregateArgs>(args: Subset<T, ActivitylogAggregateArgs>): Prisma.PrismaPromise<GetActivitylogAggregateType<T>>

    /**
     * Group by Activitylog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activitylogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activitylogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activitylogGroupByArgs['orderBy'] }
        : { orderBy?: activitylogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activitylogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivitylogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activitylog model
   */
  readonly fields: activitylogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activitylog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activitylogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee_activitylog_actorIdToemployee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee_activitylog_targetIdToemployee<T extends activitylog$employee_activitylog_targetIdToemployeeArgs<ExtArgs> = {}>(args?: Subset<T, activitylog$employee_activitylog_targetIdToemployeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activitylog model
   */
  interface activitylogFieldRefs {
    readonly id: FieldRef<"activitylog", 'Int'>
    readonly type: FieldRef<"activitylog", 'activitylog_type'>
    readonly message: FieldRef<"activitylog", 'String'>
    readonly actorId: FieldRef<"activitylog", 'Int'>
    readonly targetId: FieldRef<"activitylog", 'Int'>
    readonly departmentId: FieldRef<"activitylog", 'Int'>
    readonly createdAt: FieldRef<"activitylog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * activitylog findUnique
   */
  export type activitylogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog findUniqueOrThrow
   */
  export type activitylogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog findFirst
   */
  export type activitylogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitylogs.
     */
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog findFirstOrThrow
   */
  export type activitylogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylog to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activitylogs.
     */
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog findMany
   */
  export type activitylogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter, which activitylogs to fetch.
     */
    where?: activitylogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activitylogs to fetch.
     */
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activitylogs.
     */
    cursor?: activitylogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activitylogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activitylogs.
     */
    skip?: number
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * activitylog create
   */
  export type activitylogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The data needed to create a activitylog.
     */
    data: XOR<activitylogCreateInput, activitylogUncheckedCreateInput>
  }

  /**
   * activitylog createMany
   */
  export type activitylogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activitylogs.
     */
    data: activitylogCreateManyInput | activitylogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activitylog update
   */
  export type activitylogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The data needed to update a activitylog.
     */
    data: XOR<activitylogUpdateInput, activitylogUncheckedUpdateInput>
    /**
     * Choose, which activitylog to update.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog updateMany
   */
  export type activitylogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activitylogs.
     */
    data: XOR<activitylogUpdateManyMutationInput, activitylogUncheckedUpdateManyInput>
    /**
     * Filter which activitylogs to update
     */
    where?: activitylogWhereInput
    /**
     * Limit how many activitylogs to update.
     */
    limit?: number
  }

  /**
   * activitylog upsert
   */
  export type activitylogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * The filter to search for the activitylog to update in case it exists.
     */
    where: activitylogWhereUniqueInput
    /**
     * In case the activitylog found by the `where` argument doesn't exist, create a new activitylog with this data.
     */
    create: XOR<activitylogCreateInput, activitylogUncheckedCreateInput>
    /**
     * In case the activitylog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activitylogUpdateInput, activitylogUncheckedUpdateInput>
  }

  /**
   * activitylog delete
   */
  export type activitylogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    /**
     * Filter which activitylog to delete.
     */
    where: activitylogWhereUniqueInput
  }

  /**
   * activitylog deleteMany
   */
  export type activitylogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activitylogs to delete
     */
    where?: activitylogWhereInput
    /**
     * Limit how many activitylogs to delete.
     */
    limit?: number
  }

  /**
   * activitylog.employee_activitylog_targetIdToemployee
   */
  export type activitylog$employee_activitylog_targetIdToemployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * activitylog without action
   */
  export type activitylogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
  }


  /**
   * Model agreementstatus
   */

  export type AggregateAgreementstatus = {
    _count: AgreementstatusCountAggregateOutputType | null
    _avg: AgreementstatusAvgAggregateOutputType | null
    _sum: AgreementstatusSumAggregateOutputType | null
    _min: AgreementstatusMinAggregateOutputType | null
    _max: AgreementstatusMaxAggregateOutputType | null
  }

  export type AgreementstatusAvgAggregateOutputType = {
    id: number | null
  }

  export type AgreementstatusSumAggregateOutputType = {
    id: number | null
  }

  export type AgreementstatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type AgreementstatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type AgreementstatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type AgreementstatusAvgAggregateInputType = {
    id?: true
  }

  export type AgreementstatusSumAggregateInputType = {
    id?: true
  }

  export type AgreementstatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type AgreementstatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type AgreementstatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type AgreementstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agreementstatus to aggregate.
     */
    where?: agreementstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agreementstatuses to fetch.
     */
    orderBy?: agreementstatusOrderByWithRelationInput | agreementstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agreementstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agreementstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agreementstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agreementstatuses
    **/
    _count?: true | AgreementstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgreementstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgreementstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementstatusMaxAggregateInputType
  }

  export type GetAgreementstatusAggregateType<T extends AgreementstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementstatus[P]>
      : GetScalarType<T[P], AggregateAgreementstatus[P]>
  }




  export type agreementstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agreementstatusWhereInput
    orderBy?: agreementstatusOrderByWithAggregationInput | agreementstatusOrderByWithAggregationInput[]
    by: AgreementstatusScalarFieldEnum[] | AgreementstatusScalarFieldEnum
    having?: agreementstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementstatusCountAggregateInputType | true
    _avg?: AgreementstatusAvgAggregateInputType
    _sum?: AgreementstatusSumAggregateInputType
    _min?: AgreementstatusMinAggregateInputType
    _max?: AgreementstatusMaxAggregateInputType
  }

  export type AgreementstatusGroupByOutputType = {
    id: number
    status: string
    _count: AgreementstatusCountAggregateOutputType | null
    _avg: AgreementstatusAvgAggregateOutputType | null
    _sum: AgreementstatusSumAggregateOutputType | null
    _min: AgreementstatusMinAggregateOutputType | null
    _max: AgreementstatusMaxAggregateOutputType | null
  }

  type GetAgreementstatusGroupByPayload<T extends agreementstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementstatusGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementstatusGroupByOutputType[P]>
        }
      >
    >


  export type agreementstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employee?: boolean | agreementstatus$employeeArgs<ExtArgs>
    _count?: boolean | AgreementstatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementstatus"]>



  export type agreementstatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type agreementstatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["agreementstatus"]>
  export type agreementstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | agreementstatus$employeeArgs<ExtArgs>
    _count?: boolean | AgreementstatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $agreementstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agreementstatus"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["agreementstatus"]>
    composites: {}
  }

  type agreementstatusGetPayload<S extends boolean | null | undefined | agreementstatusDefaultArgs> = $Result.GetResult<Prisma.$agreementstatusPayload, S>

  type agreementstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agreementstatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgreementstatusCountAggregateInputType | true
    }

  export interface agreementstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agreementstatus'], meta: { name: 'agreementstatus' } }
    /**
     * Find zero or one Agreementstatus that matches the filter.
     * @param {agreementstatusFindUniqueArgs} args - Arguments to find a Agreementstatus
     * @example
     * // Get one Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agreementstatusFindUniqueArgs>(args: SelectSubset<T, agreementstatusFindUniqueArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agreementstatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agreementstatusFindUniqueOrThrowArgs} args - Arguments to find a Agreementstatus
     * @example
     * // Get one Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agreementstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, agreementstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agreementstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusFindFirstArgs} args - Arguments to find a Agreementstatus
     * @example
     * // Get one Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agreementstatusFindFirstArgs>(args?: SelectSubset<T, agreementstatusFindFirstArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agreementstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusFindFirstOrThrowArgs} args - Arguments to find a Agreementstatus
     * @example
     * // Get one Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agreementstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, agreementstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agreementstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agreementstatuses
     * const agreementstatuses = await prisma.agreementstatus.findMany()
     * 
     * // Get first 10 Agreementstatuses
     * const agreementstatuses = await prisma.agreementstatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementstatusWithIdOnly = await prisma.agreementstatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends agreementstatusFindManyArgs>(args?: SelectSubset<T, agreementstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agreementstatus.
     * @param {agreementstatusCreateArgs} args - Arguments to create a Agreementstatus.
     * @example
     * // Create one Agreementstatus
     * const Agreementstatus = await prisma.agreementstatus.create({
     *   data: {
     *     // ... data to create a Agreementstatus
     *   }
     * })
     * 
     */
    create<T extends agreementstatusCreateArgs>(args: SelectSubset<T, agreementstatusCreateArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agreementstatuses.
     * @param {agreementstatusCreateManyArgs} args - Arguments to create many Agreementstatuses.
     * @example
     * // Create many Agreementstatuses
     * const agreementstatus = await prisma.agreementstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agreementstatusCreateManyArgs>(args?: SelectSubset<T, agreementstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agreementstatus.
     * @param {agreementstatusDeleteArgs} args - Arguments to delete one Agreementstatus.
     * @example
     * // Delete one Agreementstatus
     * const Agreementstatus = await prisma.agreementstatus.delete({
     *   where: {
     *     // ... filter to delete one Agreementstatus
     *   }
     * })
     * 
     */
    delete<T extends agreementstatusDeleteArgs>(args: SelectSubset<T, agreementstatusDeleteArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agreementstatus.
     * @param {agreementstatusUpdateArgs} args - Arguments to update one Agreementstatus.
     * @example
     * // Update one Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agreementstatusUpdateArgs>(args: SelectSubset<T, agreementstatusUpdateArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agreementstatuses.
     * @param {agreementstatusDeleteManyArgs} args - Arguments to filter Agreementstatuses to delete.
     * @example
     * // Delete a few Agreementstatuses
     * const { count } = await prisma.agreementstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agreementstatusDeleteManyArgs>(args?: SelectSubset<T, agreementstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreementstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agreementstatuses
     * const agreementstatus = await prisma.agreementstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agreementstatusUpdateManyArgs>(args: SelectSubset<T, agreementstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agreementstatus.
     * @param {agreementstatusUpsertArgs} args - Arguments to update or create a Agreementstatus.
     * @example
     * // Update or create a Agreementstatus
     * const agreementstatus = await prisma.agreementstatus.upsert({
     *   create: {
     *     // ... data to create a Agreementstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agreementstatus we want to update
     *   }
     * })
     */
    upsert<T extends agreementstatusUpsertArgs>(args: SelectSubset<T, agreementstatusUpsertArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agreementstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusCountArgs} args - Arguments to filter Agreementstatuses to count.
     * @example
     * // Count the number of Agreementstatuses
     * const count = await prisma.agreementstatus.count({
     *   where: {
     *     // ... the filter for the Agreementstatuses we want to count
     *   }
     * })
    **/
    count<T extends agreementstatusCountArgs>(
      args?: Subset<T, agreementstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agreementstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementstatusAggregateArgs>(args: Subset<T, AgreementstatusAggregateArgs>): Prisma.PrismaPromise<GetAgreementstatusAggregateType<T>>

    /**
     * Group by Agreementstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agreementstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agreementstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agreementstatusGroupByArgs['orderBy'] }
        : { orderBy?: agreementstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agreementstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agreementstatus model
   */
  readonly fields: agreementstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agreementstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agreementstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends agreementstatus$employeeArgs<ExtArgs> = {}>(args?: Subset<T, agreementstatus$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agreementstatus model
   */
  interface agreementstatusFieldRefs {
    readonly id: FieldRef<"agreementstatus", 'Int'>
    readonly status: FieldRef<"agreementstatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agreementstatus findUnique
   */
  export type agreementstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter, which agreementstatus to fetch.
     */
    where: agreementstatusWhereUniqueInput
  }

  /**
   * agreementstatus findUniqueOrThrow
   */
  export type agreementstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter, which agreementstatus to fetch.
     */
    where: agreementstatusWhereUniqueInput
  }

  /**
   * agreementstatus findFirst
   */
  export type agreementstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter, which agreementstatus to fetch.
     */
    where?: agreementstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agreementstatuses to fetch.
     */
    orderBy?: agreementstatusOrderByWithRelationInput | agreementstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agreementstatuses.
     */
    cursor?: agreementstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agreementstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agreementstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agreementstatuses.
     */
    distinct?: AgreementstatusScalarFieldEnum | AgreementstatusScalarFieldEnum[]
  }

  /**
   * agreementstatus findFirstOrThrow
   */
  export type agreementstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter, which agreementstatus to fetch.
     */
    where?: agreementstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agreementstatuses to fetch.
     */
    orderBy?: agreementstatusOrderByWithRelationInput | agreementstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agreementstatuses.
     */
    cursor?: agreementstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agreementstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agreementstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agreementstatuses.
     */
    distinct?: AgreementstatusScalarFieldEnum | AgreementstatusScalarFieldEnum[]
  }

  /**
   * agreementstatus findMany
   */
  export type agreementstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter, which agreementstatuses to fetch.
     */
    where?: agreementstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agreementstatuses to fetch.
     */
    orderBy?: agreementstatusOrderByWithRelationInput | agreementstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agreementstatuses.
     */
    cursor?: agreementstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agreementstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agreementstatuses.
     */
    skip?: number
    distinct?: AgreementstatusScalarFieldEnum | AgreementstatusScalarFieldEnum[]
  }

  /**
   * agreementstatus create
   */
  export type agreementstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a agreementstatus.
     */
    data: XOR<agreementstatusCreateInput, agreementstatusUncheckedCreateInput>
  }

  /**
   * agreementstatus createMany
   */
  export type agreementstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agreementstatuses.
     */
    data: agreementstatusCreateManyInput | agreementstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agreementstatus update
   */
  export type agreementstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a agreementstatus.
     */
    data: XOR<agreementstatusUpdateInput, agreementstatusUncheckedUpdateInput>
    /**
     * Choose, which agreementstatus to update.
     */
    where: agreementstatusWhereUniqueInput
  }

  /**
   * agreementstatus updateMany
   */
  export type agreementstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agreementstatuses.
     */
    data: XOR<agreementstatusUpdateManyMutationInput, agreementstatusUncheckedUpdateManyInput>
    /**
     * Filter which agreementstatuses to update
     */
    where?: agreementstatusWhereInput
    /**
     * Limit how many agreementstatuses to update.
     */
    limit?: number
  }

  /**
   * agreementstatus upsert
   */
  export type agreementstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the agreementstatus to update in case it exists.
     */
    where: agreementstatusWhereUniqueInput
    /**
     * In case the agreementstatus found by the `where` argument doesn't exist, create a new agreementstatus with this data.
     */
    create: XOR<agreementstatusCreateInput, agreementstatusUncheckedCreateInput>
    /**
     * In case the agreementstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agreementstatusUpdateInput, agreementstatusUncheckedUpdateInput>
  }

  /**
   * agreementstatus delete
   */
  export type agreementstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    /**
     * Filter which agreementstatus to delete.
     */
    where: agreementstatusWhereUniqueInput
  }

  /**
   * agreementstatus deleteMany
   */
  export type agreementstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agreementstatuses to delete
     */
    where?: agreementstatusWhereInput
    /**
     * Limit how many agreementstatuses to delete.
     */
    limit?: number
  }

  /**
   * agreementstatus.employee
   */
  export type agreementstatus$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * agreementstatus without action
   */
  export type agreementstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
  }


  /**
   * Model attendancelog
   */

  export type AggregateAttendancelog = {
    _count: AttendancelogCountAggregateOutputType | null
    _avg: AttendancelogAvgAggregateOutputType | null
    _sum: AttendancelogSumAggregateOutputType | null
    _min: AttendancelogMinAggregateOutputType | null
    _max: AttendancelogMaxAggregateOutputType | null
  }

  export type AttendancelogAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    sessionId: number | null
  }

  export type AttendancelogSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    sessionId: number | null
  }

  export type AttendancelogMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    sessionId: number | null
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.attendancelog_status | null
    createdAt: Date | null
  }

  export type AttendancelogMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    sessionId: number | null
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.attendancelog_status | null
    createdAt: Date | null
  }

  export type AttendancelogCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    sessionId: number
    actualClockIn: number
    actualClockOut: number
    status: number
    createdAt: number
    _all: number
  }


  export type AttendancelogAvgAggregateInputType = {
    id?: true
    employeeId?: true
    sessionId?: true
  }

  export type AttendancelogSumAggregateInputType = {
    id?: true
    employeeId?: true
    sessionId?: true
  }

  export type AttendancelogMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
  }

  export type AttendancelogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
  }

  export type AttendancelogCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AttendancelogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendancelog to aggregate.
     */
    where?: attendancelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancelogs to fetch.
     */
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendancelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendancelogs
    **/
    _count?: true | AttendancelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancelogMaxAggregateInputType
  }

  export type GetAttendancelogAggregateType<T extends AttendancelogAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendancelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendancelog[P]>
      : GetScalarType<T[P], AggregateAttendancelog[P]>
  }




  export type attendancelogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancelogWhereInput
    orderBy?: attendancelogOrderByWithAggregationInput | attendancelogOrderByWithAggregationInput[]
    by: AttendancelogScalarFieldEnum[] | AttendancelogScalarFieldEnum
    having?: attendancelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancelogCountAggregateInputType | true
    _avg?: AttendancelogAvgAggregateInputType
    _sum?: AttendancelogSumAggregateInputType
    _min?: AttendancelogMinAggregateInputType
    _max?: AttendancelogMaxAggregateInputType
  }

  export type AttendancelogGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    sessionId: number
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.attendancelog_status
    createdAt: Date
    _count: AttendancelogCountAggregateOutputType | null
    _avg: AttendancelogAvgAggregateOutputType | null
    _sum: AttendancelogSumAggregateOutputType | null
    _min: AttendancelogMinAggregateOutputType | null
    _max: AttendancelogMaxAggregateOutputType | null
  }

  type GetAttendancelogGroupByPayload<T extends attendancelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancelogGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancelogGroupByOutputType[P]>
        }
      >
    >


  export type attendancelogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    sessionId?: boolean
    actualClockIn?: boolean
    actualClockOut?: boolean
    status?: boolean
    createdAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    sessiondefinition?: boolean | sessiondefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendancelog"]>



  export type attendancelogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    sessionId?: boolean
    actualClockIn?: boolean
    actualClockOut?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type attendancelogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "sessionId" | "actualClockIn" | "actualClockOut" | "status" | "createdAt", ExtArgs["result"]["attendancelog"]>
  export type attendancelogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    sessiondefinition?: boolean | sessiondefinitionDefaultArgs<ExtArgs>
  }

  export type $attendancelogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendancelog"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      sessiondefinition: Prisma.$sessiondefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      sessionId: number
      actualClockIn: Date | null
      actualClockOut: Date | null
      status: $Enums.attendancelog_status
      createdAt: Date
    }, ExtArgs["result"]["attendancelog"]>
    composites: {}
  }

  type attendancelogGetPayload<S extends boolean | null | undefined | attendancelogDefaultArgs> = $Result.GetResult<Prisma.$attendancelogPayload, S>

  type attendancelogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendancelogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendancelogCountAggregateInputType | true
    }

  export interface attendancelogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendancelog'], meta: { name: 'attendancelog' } }
    /**
     * Find zero or one Attendancelog that matches the filter.
     * @param {attendancelogFindUniqueArgs} args - Arguments to find a Attendancelog
     * @example
     * // Get one Attendancelog
     * const attendancelog = await prisma.attendancelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendancelogFindUniqueArgs>(args: SelectSubset<T, attendancelogFindUniqueArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendancelog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendancelogFindUniqueOrThrowArgs} args - Arguments to find a Attendancelog
     * @example
     * // Get one Attendancelog
     * const attendancelog = await prisma.attendancelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendancelogFindUniqueOrThrowArgs>(args: SelectSubset<T, attendancelogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendancelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogFindFirstArgs} args - Arguments to find a Attendancelog
     * @example
     * // Get one Attendancelog
     * const attendancelog = await prisma.attendancelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendancelogFindFirstArgs>(args?: SelectSubset<T, attendancelogFindFirstArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendancelog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogFindFirstOrThrowArgs} args - Arguments to find a Attendancelog
     * @example
     * // Get one Attendancelog
     * const attendancelog = await prisma.attendancelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendancelogFindFirstOrThrowArgs>(args?: SelectSubset<T, attendancelogFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendancelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendancelogs
     * const attendancelogs = await prisma.attendancelog.findMany()
     * 
     * // Get first 10 Attendancelogs
     * const attendancelogs = await prisma.attendancelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancelogWithIdOnly = await prisma.attendancelog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendancelogFindManyArgs>(args?: SelectSubset<T, attendancelogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendancelog.
     * @param {attendancelogCreateArgs} args - Arguments to create a Attendancelog.
     * @example
     * // Create one Attendancelog
     * const Attendancelog = await prisma.attendancelog.create({
     *   data: {
     *     // ... data to create a Attendancelog
     *   }
     * })
     * 
     */
    create<T extends attendancelogCreateArgs>(args: SelectSubset<T, attendancelogCreateArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendancelogs.
     * @param {attendancelogCreateManyArgs} args - Arguments to create many Attendancelogs.
     * @example
     * // Create many Attendancelogs
     * const attendancelog = await prisma.attendancelog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendancelogCreateManyArgs>(args?: SelectSubset<T, attendancelogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendancelog.
     * @param {attendancelogDeleteArgs} args - Arguments to delete one Attendancelog.
     * @example
     * // Delete one Attendancelog
     * const Attendancelog = await prisma.attendancelog.delete({
     *   where: {
     *     // ... filter to delete one Attendancelog
     *   }
     * })
     * 
     */
    delete<T extends attendancelogDeleteArgs>(args: SelectSubset<T, attendancelogDeleteArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendancelog.
     * @param {attendancelogUpdateArgs} args - Arguments to update one Attendancelog.
     * @example
     * // Update one Attendancelog
     * const attendancelog = await prisma.attendancelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendancelogUpdateArgs>(args: SelectSubset<T, attendancelogUpdateArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendancelogs.
     * @param {attendancelogDeleteManyArgs} args - Arguments to filter Attendancelogs to delete.
     * @example
     * // Delete a few Attendancelogs
     * const { count } = await prisma.attendancelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendancelogDeleteManyArgs>(args?: SelectSubset<T, attendancelogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendancelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendancelogs
     * const attendancelog = await prisma.attendancelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendancelogUpdateManyArgs>(args: SelectSubset<T, attendancelogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendancelog.
     * @param {attendancelogUpsertArgs} args - Arguments to update or create a Attendancelog.
     * @example
     * // Update or create a Attendancelog
     * const attendancelog = await prisma.attendancelog.upsert({
     *   create: {
     *     // ... data to create a Attendancelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendancelog we want to update
     *   }
     * })
     */
    upsert<T extends attendancelogUpsertArgs>(args: SelectSubset<T, attendancelogUpsertArgs<ExtArgs>>): Prisma__attendancelogClient<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendancelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogCountArgs} args - Arguments to filter Attendancelogs to count.
     * @example
     * // Count the number of Attendancelogs
     * const count = await prisma.attendancelog.count({
     *   where: {
     *     // ... the filter for the Attendancelogs we want to count
     *   }
     * })
    **/
    count<T extends attendancelogCountArgs>(
      args?: Subset<T, attendancelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendancelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancelogAggregateArgs>(args: Subset<T, AttendancelogAggregateArgs>): Prisma.PrismaPromise<GetAttendancelogAggregateType<T>>

    /**
     * Group by Attendancelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendancelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendancelogGroupByArgs['orderBy'] }
        : { orderBy?: attendancelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendancelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendancelog model
   */
  readonly fields: attendancelogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendancelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendancelogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessiondefinition<T extends sessiondefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, sessiondefinitionDefaultArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendancelog model
   */
  interface attendancelogFieldRefs {
    readonly id: FieldRef<"attendancelog", 'Int'>
    readonly employeeId: FieldRef<"attendancelog", 'Int'>
    readonly date: FieldRef<"attendancelog", 'DateTime'>
    readonly sessionId: FieldRef<"attendancelog", 'Int'>
    readonly actualClockIn: FieldRef<"attendancelog", 'DateTime'>
    readonly actualClockOut: FieldRef<"attendancelog", 'DateTime'>
    readonly status: FieldRef<"attendancelog", 'attendancelog_status'>
    readonly createdAt: FieldRef<"attendancelog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendancelog findUnique
   */
  export type attendancelogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter, which attendancelog to fetch.
     */
    where: attendancelogWhereUniqueInput
  }

  /**
   * attendancelog findUniqueOrThrow
   */
  export type attendancelogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter, which attendancelog to fetch.
     */
    where: attendancelogWhereUniqueInput
  }

  /**
   * attendancelog findFirst
   */
  export type attendancelogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter, which attendancelog to fetch.
     */
    where?: attendancelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancelogs to fetch.
     */
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendancelogs.
     */
    cursor?: attendancelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendancelogs.
     */
    distinct?: AttendancelogScalarFieldEnum | AttendancelogScalarFieldEnum[]
  }

  /**
   * attendancelog findFirstOrThrow
   */
  export type attendancelogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter, which attendancelog to fetch.
     */
    where?: attendancelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancelogs to fetch.
     */
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendancelogs.
     */
    cursor?: attendancelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendancelogs.
     */
    distinct?: AttendancelogScalarFieldEnum | AttendancelogScalarFieldEnum[]
  }

  /**
   * attendancelog findMany
   */
  export type attendancelogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter, which attendancelogs to fetch.
     */
    where?: attendancelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancelogs to fetch.
     */
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendancelogs.
     */
    cursor?: attendancelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancelogs.
     */
    skip?: number
    distinct?: AttendancelogScalarFieldEnum | AttendancelogScalarFieldEnum[]
  }

  /**
   * attendancelog create
   */
  export type attendancelogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * The data needed to create a attendancelog.
     */
    data: XOR<attendancelogCreateInput, attendancelogUncheckedCreateInput>
  }

  /**
   * attendancelog createMany
   */
  export type attendancelogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendancelogs.
     */
    data: attendancelogCreateManyInput | attendancelogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendancelog update
   */
  export type attendancelogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * The data needed to update a attendancelog.
     */
    data: XOR<attendancelogUpdateInput, attendancelogUncheckedUpdateInput>
    /**
     * Choose, which attendancelog to update.
     */
    where: attendancelogWhereUniqueInput
  }

  /**
   * attendancelog updateMany
   */
  export type attendancelogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendancelogs.
     */
    data: XOR<attendancelogUpdateManyMutationInput, attendancelogUncheckedUpdateManyInput>
    /**
     * Filter which attendancelogs to update
     */
    where?: attendancelogWhereInput
    /**
     * Limit how many attendancelogs to update.
     */
    limit?: number
  }

  /**
   * attendancelog upsert
   */
  export type attendancelogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * The filter to search for the attendancelog to update in case it exists.
     */
    where: attendancelogWhereUniqueInput
    /**
     * In case the attendancelog found by the `where` argument doesn't exist, create a new attendancelog with this data.
     */
    create: XOR<attendancelogCreateInput, attendancelogUncheckedCreateInput>
    /**
     * In case the attendancelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendancelogUpdateInput, attendancelogUncheckedUpdateInput>
  }

  /**
   * attendancelog delete
   */
  export type attendancelogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    /**
     * Filter which attendancelog to delete.
     */
    where: attendancelogWhereUniqueInput
  }

  /**
   * attendancelog deleteMany
   */
  export type attendancelogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendancelogs to delete
     */
    where?: attendancelogWhereInput
    /**
     * Limit how many attendancelogs to delete.
     */
    limit?: number
  }

  /**
   * attendancelog without action
   */
  export type attendancelogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
  }


  /**
   * Model attendancesummary
   */

  export type AggregateAttendancesummary = {
    _count: AttendancesummaryCountAggregateOutputType | null
    _avg: AttendancesummaryAvgAggregateOutputType | null
    _sum: AttendancesummarySumAggregateOutputType | null
    _min: AttendancesummaryMinAggregateOutputType | null
    _max: AttendancesummaryMaxAggregateOutputType | null
  }

  export type AttendancesummaryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalWorkHours: Decimal | null
    departmentId: number | null
  }

  export type AttendancesummarySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalWorkHours: Decimal | null
    departmentId: number | null
  }

  export type AttendancesummaryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.attendancesummary_status | null
    lateArrival: boolean | null
    earlyDeparture: boolean | null
    unplannedAbsence: boolean | null
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
  }

  export type AttendancesummaryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.attendancesummary_status | null
    lateArrival: boolean | null
    earlyDeparture: boolean | null
    unplannedAbsence: boolean | null
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
  }

  export type AttendancesummaryCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    status: number
    lateArrival: number
    earlyDeparture: number
    unplannedAbsence: number
    totalWorkHours: number
    remarks: number
    departmentId: number
    _all: number
  }


  export type AttendancesummaryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    totalWorkHours?: true
    departmentId?: true
  }

  export type AttendancesummarySumAggregateInputType = {
    id?: true
    employeeId?: true
    totalWorkHours?: true
    departmentId?: true
  }

  export type AttendancesummaryMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
  }

  export type AttendancesummaryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
  }

  export type AttendancesummaryCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
    _all?: true
  }

  export type AttendancesummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendancesummary to aggregate.
     */
    where?: attendancesummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancesummaries to fetch.
     */
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendancesummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancesummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancesummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendancesummaries
    **/
    _count?: true | AttendancesummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendancesummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendancesummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendancesummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendancesummaryMaxAggregateInputType
  }

  export type GetAttendancesummaryAggregateType<T extends AttendancesummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendancesummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendancesummary[P]>
      : GetScalarType<T[P], AggregateAttendancesummary[P]>
  }




  export type attendancesummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendancesummaryWhereInput
    orderBy?: attendancesummaryOrderByWithAggregationInput | attendancesummaryOrderByWithAggregationInput[]
    by: AttendancesummaryScalarFieldEnum[] | AttendancesummaryScalarFieldEnum
    having?: attendancesummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendancesummaryCountAggregateInputType | true
    _avg?: AttendancesummaryAvgAggregateInputType
    _sum?: AttendancesummarySumAggregateInputType
    _min?: AttendancesummaryMinAggregateInputType
    _max?: AttendancesummaryMaxAggregateInputType
  }

  export type AttendancesummaryGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    status: $Enums.attendancesummary_status
    lateArrival: boolean
    earlyDeparture: boolean
    unplannedAbsence: boolean
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
    _count: AttendancesummaryCountAggregateOutputType | null
    _avg: AttendancesummaryAvgAggregateOutputType | null
    _sum: AttendancesummarySumAggregateOutputType | null
    _min: AttendancesummaryMinAggregateOutputType | null
    _max: AttendancesummaryMaxAggregateOutputType | null
  }

  type GetAttendancesummaryGroupByPayload<T extends attendancesummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendancesummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendancesummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendancesummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendancesummaryGroupByOutputType[P]>
        }
      >
    >


  export type attendancesummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: boolean
    remarks?: boolean
    departmentId?: boolean
    department?: boolean | attendancesummary$departmentArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendancesummary"]>



  export type attendancesummarySelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: boolean
    remarks?: boolean
    departmentId?: boolean
  }

  export type attendancesummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "status" | "lateArrival" | "earlyDeparture" | "unplannedAbsence" | "totalWorkHours" | "remarks" | "departmentId", ExtArgs["result"]["attendancesummary"]>
  export type attendancesummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | attendancesummary$departmentArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $attendancesummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendancesummary"
    objects: {
      department: Prisma.$departmentPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      status: $Enums.attendancesummary_status
      lateArrival: boolean
      earlyDeparture: boolean
      unplannedAbsence: boolean
      totalWorkHours: Prisma.Decimal | null
      remarks: string | null
      departmentId: number | null
    }, ExtArgs["result"]["attendancesummary"]>
    composites: {}
  }

  type attendancesummaryGetPayload<S extends boolean | null | undefined | attendancesummaryDefaultArgs> = $Result.GetResult<Prisma.$attendancesummaryPayload, S>

  type attendancesummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendancesummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendancesummaryCountAggregateInputType | true
    }

  export interface attendancesummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendancesummary'], meta: { name: 'attendancesummary' } }
    /**
     * Find zero or one Attendancesummary that matches the filter.
     * @param {attendancesummaryFindUniqueArgs} args - Arguments to find a Attendancesummary
     * @example
     * // Get one Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendancesummaryFindUniqueArgs>(args: SelectSubset<T, attendancesummaryFindUniqueArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendancesummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendancesummaryFindUniqueOrThrowArgs} args - Arguments to find a Attendancesummary
     * @example
     * // Get one Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendancesummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, attendancesummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendancesummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryFindFirstArgs} args - Arguments to find a Attendancesummary
     * @example
     * // Get one Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendancesummaryFindFirstArgs>(args?: SelectSubset<T, attendancesummaryFindFirstArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendancesummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryFindFirstOrThrowArgs} args - Arguments to find a Attendancesummary
     * @example
     * // Get one Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendancesummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, attendancesummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendancesummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendancesummaries
     * const attendancesummaries = await prisma.attendancesummary.findMany()
     * 
     * // Get first 10 Attendancesummaries
     * const attendancesummaries = await prisma.attendancesummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendancesummaryWithIdOnly = await prisma.attendancesummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendancesummaryFindManyArgs>(args?: SelectSubset<T, attendancesummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendancesummary.
     * @param {attendancesummaryCreateArgs} args - Arguments to create a Attendancesummary.
     * @example
     * // Create one Attendancesummary
     * const Attendancesummary = await prisma.attendancesummary.create({
     *   data: {
     *     // ... data to create a Attendancesummary
     *   }
     * })
     * 
     */
    create<T extends attendancesummaryCreateArgs>(args: SelectSubset<T, attendancesummaryCreateArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendancesummaries.
     * @param {attendancesummaryCreateManyArgs} args - Arguments to create many Attendancesummaries.
     * @example
     * // Create many Attendancesummaries
     * const attendancesummary = await prisma.attendancesummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendancesummaryCreateManyArgs>(args?: SelectSubset<T, attendancesummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attendancesummary.
     * @param {attendancesummaryDeleteArgs} args - Arguments to delete one Attendancesummary.
     * @example
     * // Delete one Attendancesummary
     * const Attendancesummary = await prisma.attendancesummary.delete({
     *   where: {
     *     // ... filter to delete one Attendancesummary
     *   }
     * })
     * 
     */
    delete<T extends attendancesummaryDeleteArgs>(args: SelectSubset<T, attendancesummaryDeleteArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendancesummary.
     * @param {attendancesummaryUpdateArgs} args - Arguments to update one Attendancesummary.
     * @example
     * // Update one Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendancesummaryUpdateArgs>(args: SelectSubset<T, attendancesummaryUpdateArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendancesummaries.
     * @param {attendancesummaryDeleteManyArgs} args - Arguments to filter Attendancesummaries to delete.
     * @example
     * // Delete a few Attendancesummaries
     * const { count } = await prisma.attendancesummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendancesummaryDeleteManyArgs>(args?: SelectSubset<T, attendancesummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendancesummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendancesummaries
     * const attendancesummary = await prisma.attendancesummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendancesummaryUpdateManyArgs>(args: SelectSubset<T, attendancesummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendancesummary.
     * @param {attendancesummaryUpsertArgs} args - Arguments to update or create a Attendancesummary.
     * @example
     * // Update or create a Attendancesummary
     * const attendancesummary = await prisma.attendancesummary.upsert({
     *   create: {
     *     // ... data to create a Attendancesummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendancesummary we want to update
     *   }
     * })
     */
    upsert<T extends attendancesummaryUpsertArgs>(args: SelectSubset<T, attendancesummaryUpsertArgs<ExtArgs>>): Prisma__attendancesummaryClient<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendancesummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryCountArgs} args - Arguments to filter Attendancesummaries to count.
     * @example
     * // Count the number of Attendancesummaries
     * const count = await prisma.attendancesummary.count({
     *   where: {
     *     // ... the filter for the Attendancesummaries we want to count
     *   }
     * })
    **/
    count<T extends attendancesummaryCountArgs>(
      args?: Subset<T, attendancesummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendancesummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendancesummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendancesummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendancesummaryAggregateArgs>(args: Subset<T, AttendancesummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendancesummaryAggregateType<T>>

    /**
     * Group by Attendancesummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendancesummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendancesummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendancesummaryGroupByArgs['orderBy'] }
        : { orderBy?: attendancesummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendancesummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendancesummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendancesummary model
   */
  readonly fields: attendancesummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendancesummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendancesummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends attendancesummary$departmentArgs<ExtArgs> = {}>(args?: Subset<T, attendancesummary$departmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendancesummary model
   */
  interface attendancesummaryFieldRefs {
    readonly id: FieldRef<"attendancesummary", 'Int'>
    readonly employeeId: FieldRef<"attendancesummary", 'Int'>
    readonly date: FieldRef<"attendancesummary", 'DateTime'>
    readonly status: FieldRef<"attendancesummary", 'attendancesummary_status'>
    readonly lateArrival: FieldRef<"attendancesummary", 'Boolean'>
    readonly earlyDeparture: FieldRef<"attendancesummary", 'Boolean'>
    readonly unplannedAbsence: FieldRef<"attendancesummary", 'Boolean'>
    readonly totalWorkHours: FieldRef<"attendancesummary", 'Decimal'>
    readonly remarks: FieldRef<"attendancesummary", 'String'>
    readonly departmentId: FieldRef<"attendancesummary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * attendancesummary findUnique
   */
  export type attendancesummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter, which attendancesummary to fetch.
     */
    where: attendancesummaryWhereUniqueInput
  }

  /**
   * attendancesummary findUniqueOrThrow
   */
  export type attendancesummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter, which attendancesummary to fetch.
     */
    where: attendancesummaryWhereUniqueInput
  }

  /**
   * attendancesummary findFirst
   */
  export type attendancesummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter, which attendancesummary to fetch.
     */
    where?: attendancesummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancesummaries to fetch.
     */
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendancesummaries.
     */
    cursor?: attendancesummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancesummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancesummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendancesummaries.
     */
    distinct?: AttendancesummaryScalarFieldEnum | AttendancesummaryScalarFieldEnum[]
  }

  /**
   * attendancesummary findFirstOrThrow
   */
  export type attendancesummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter, which attendancesummary to fetch.
     */
    where?: attendancesummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancesummaries to fetch.
     */
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendancesummaries.
     */
    cursor?: attendancesummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancesummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancesummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendancesummaries.
     */
    distinct?: AttendancesummaryScalarFieldEnum | AttendancesummaryScalarFieldEnum[]
  }

  /**
   * attendancesummary findMany
   */
  export type attendancesummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter, which attendancesummaries to fetch.
     */
    where?: attendancesummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendancesummaries to fetch.
     */
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendancesummaries.
     */
    cursor?: attendancesummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendancesummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendancesummaries.
     */
    skip?: number
    distinct?: AttendancesummaryScalarFieldEnum | AttendancesummaryScalarFieldEnum[]
  }

  /**
   * attendancesummary create
   */
  export type attendancesummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a attendancesummary.
     */
    data: XOR<attendancesummaryCreateInput, attendancesummaryUncheckedCreateInput>
  }

  /**
   * attendancesummary createMany
   */
  export type attendancesummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendancesummaries.
     */
    data: attendancesummaryCreateManyInput | attendancesummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendancesummary update
   */
  export type attendancesummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a attendancesummary.
     */
    data: XOR<attendancesummaryUpdateInput, attendancesummaryUncheckedUpdateInput>
    /**
     * Choose, which attendancesummary to update.
     */
    where: attendancesummaryWhereUniqueInput
  }

  /**
   * attendancesummary updateMany
   */
  export type attendancesummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendancesummaries.
     */
    data: XOR<attendancesummaryUpdateManyMutationInput, attendancesummaryUncheckedUpdateManyInput>
    /**
     * Filter which attendancesummaries to update
     */
    where?: attendancesummaryWhereInput
    /**
     * Limit how many attendancesummaries to update.
     */
    limit?: number
  }

  /**
   * attendancesummary upsert
   */
  export type attendancesummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the attendancesummary to update in case it exists.
     */
    where: attendancesummaryWhereUniqueInput
    /**
     * In case the attendancesummary found by the `where` argument doesn't exist, create a new attendancesummary with this data.
     */
    create: XOR<attendancesummaryCreateInput, attendancesummaryUncheckedCreateInput>
    /**
     * In case the attendancesummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendancesummaryUpdateInput, attendancesummaryUncheckedUpdateInput>
  }

  /**
   * attendancesummary delete
   */
  export type attendancesummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    /**
     * Filter which attendancesummary to delete.
     */
    where: attendancesummaryWhereUniqueInput
  }

  /**
   * attendancesummary deleteMany
   */
  export type attendancesummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendancesummaries to delete
     */
    where?: attendancesummaryWhereInput
    /**
     * Limit how many attendancesummaries to delete.
     */
    limit?: number
  }

  /**
   * attendancesummary.department
   */
  export type attendancesummary$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * attendancesummary without action
   */
  export type attendancesummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
  }


  /**
   * Model complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    subject: string | null
    description: string | null
    status: $Enums.complaint_status | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    subject: string | null
    description: string | null
    status: $Enums.complaint_status | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    employeeId: number
    subject: number
    description: number
    status: number
    response: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaint to aggregate.
     */
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintOrderByWithRelationInput | complaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type complaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: complaintWhereInput
    orderBy?: complaintOrderByWithAggregationInput | complaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: complaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    employeeId: number
    subject: string
    description: string
    status: $Enums.complaint_status
    response: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends complaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type complaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type complaintSelectScalar = {
    id?: boolean
    employeeId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type complaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "subject" | "description" | "status" | "response" | "createdAt" | "updatedAt", ExtArgs["result"]["complaint"]>
  export type complaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $complaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "complaint"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      subject: string
      description: string
      status: $Enums.complaint_status
      response: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type complaintGetPayload<S extends boolean | null | undefined | complaintDefaultArgs> = $Result.GetResult<Prisma.$complaintPayload, S>

  type complaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<complaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface complaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['complaint'], meta: { name: 'complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {complaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends complaintFindUniqueArgs>(args: SelectSubset<T, complaintFindUniqueArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {complaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends complaintFindUniqueOrThrowArgs>(args: SelectSubset<T, complaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends complaintFindFirstArgs>(args?: SelectSubset<T, complaintFindFirstArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends complaintFindFirstOrThrowArgs>(args?: SelectSubset<T, complaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends complaintFindManyArgs>(args?: SelectSubset<T, complaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {complaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends complaintCreateArgs>(args: SelectSubset<T, complaintCreateArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {complaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends complaintCreateManyArgs>(args?: SelectSubset<T, complaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {complaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends complaintDeleteArgs>(args: SelectSubset<T, complaintDeleteArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {complaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends complaintUpdateArgs>(args: SelectSubset<T, complaintUpdateArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {complaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends complaintDeleteManyArgs>(args?: SelectSubset<T, complaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends complaintUpdateManyArgs>(args: SelectSubset<T, complaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {complaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends complaintUpsertArgs>(args: SelectSubset<T, complaintUpsertArgs<ExtArgs>>): Prisma__complaintClient<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends complaintCountArgs>(
      args?: Subset<T, complaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {complaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends complaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: complaintGroupByArgs['orderBy'] }
        : { orderBy?: complaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, complaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the complaint model
   */
  readonly fields: complaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__complaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the complaint model
   */
  interface complaintFieldRefs {
    readonly id: FieldRef<"complaint", 'Int'>
    readonly employeeId: FieldRef<"complaint", 'Int'>
    readonly subject: FieldRef<"complaint", 'String'>
    readonly description: FieldRef<"complaint", 'String'>
    readonly status: FieldRef<"complaint", 'complaint_status'>
    readonly response: FieldRef<"complaint", 'String'>
    readonly createdAt: FieldRef<"complaint", 'DateTime'>
    readonly updatedAt: FieldRef<"complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * complaint findUnique
   */
  export type complaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter, which complaint to fetch.
     */
    where: complaintWhereUniqueInput
  }

  /**
   * complaint findUniqueOrThrow
   */
  export type complaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter, which complaint to fetch.
     */
    where: complaintWhereUniqueInput
  }

  /**
   * complaint findFirst
   */
  export type complaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter, which complaint to fetch.
     */
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintOrderByWithRelationInput | complaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * complaint findFirstOrThrow
   */
  export type complaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter, which complaint to fetch.
     */
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintOrderByWithRelationInput | complaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for complaints.
     */
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * complaint findMany
   */
  export type complaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter, which complaints to fetch.
     */
    where?: complaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of complaints to fetch.
     */
    orderBy?: complaintOrderByWithRelationInput | complaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing complaints.
     */
    cursor?: complaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * complaint create
   */
  export type complaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * The data needed to create a complaint.
     */
    data: XOR<complaintCreateInput, complaintUncheckedCreateInput>
  }

  /**
   * complaint createMany
   */
  export type complaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many complaints.
     */
    data: complaintCreateManyInput | complaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * complaint update
   */
  export type complaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * The data needed to update a complaint.
     */
    data: XOR<complaintUpdateInput, complaintUncheckedUpdateInput>
    /**
     * Choose, which complaint to update.
     */
    where: complaintWhereUniqueInput
  }

  /**
   * complaint updateMany
   */
  export type complaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update complaints.
     */
    data: XOR<complaintUpdateManyMutationInput, complaintUncheckedUpdateManyInput>
    /**
     * Filter which complaints to update
     */
    where?: complaintWhereInput
    /**
     * Limit how many complaints to update.
     */
    limit?: number
  }

  /**
   * complaint upsert
   */
  export type complaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * The filter to search for the complaint to update in case it exists.
     */
    where: complaintWhereUniqueInput
    /**
     * In case the complaint found by the `where` argument doesn't exist, create a new complaint with this data.
     */
    create: XOR<complaintCreateInput, complaintUncheckedCreateInput>
    /**
     * In case the complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<complaintUpdateInput, complaintUncheckedUpdateInput>
  }

  /**
   * complaint delete
   */
  export type complaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    /**
     * Filter which complaint to delete.
     */
    where: complaintWhereUniqueInput
  }

  /**
   * complaint deleteMany
   */
  export type complaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which complaints to delete
     */
    where?: complaintWhereInput
    /**
     * Limit how many complaints to delete.
     */
    limit?: number
  }

  /**
   * complaint without action
   */
  export type complaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
  }


  /**
   * Model department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
    payrollPolicyId: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    parentId: number | null
    payrollPolicyId: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: number | null
    payrollPolicyId: number | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: number | null
    payrollPolicyId: number | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    parentId: number
    payrollPolicyId: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    parentId?: true
    payrollPolicyId?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    parentId?: true
    payrollPolicyId?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    payrollPolicyId?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    payrollPolicyId?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    payrollPolicyId?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which department to aggregate.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type departmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithAggregationInput | departmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: departmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    parentId: number | null
    payrollPolicyId: number | null
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends departmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type departmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    payrollPolicyId?: boolean
    attendancesummary?: boolean | department$attendancesummaryArgs<ExtArgs>
    department?: boolean | department$departmentArgs<ExtArgs>
    other_department?: boolean | department$other_departmentArgs<ExtArgs>
    payrollpolicy?: boolean | department$payrollpolicyArgs<ExtArgs>
    employee_employee_departmentIdTodepartment?: boolean | department$employee_employee_departmentIdTodepartmentArgs<ExtArgs>
    employee_employee_subDepartmentIdTodepartment?: boolean | department$employee_employee_subDepartmentIdTodepartmentArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>



  export type departmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    payrollPolicyId?: boolean
  }

  export type departmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "parentId" | "payrollPolicyId", ExtArgs["result"]["department"]>
  export type departmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendancesummary?: boolean | department$attendancesummaryArgs<ExtArgs>
    department?: boolean | department$departmentArgs<ExtArgs>
    other_department?: boolean | department$other_departmentArgs<ExtArgs>
    payrollpolicy?: boolean | department$payrollpolicyArgs<ExtArgs>
    employee_employee_departmentIdTodepartment?: boolean | department$employee_employee_departmentIdTodepartmentArgs<ExtArgs>
    employee_employee_subDepartmentIdTodepartment?: boolean | department$employee_employee_subDepartmentIdTodepartmentArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $departmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "department"
    objects: {
      attendancesummary: Prisma.$attendancesummaryPayload<ExtArgs>[]
      department: Prisma.$departmentPayload<ExtArgs> | null
      other_department: Prisma.$departmentPayload<ExtArgs>[]
      payrollpolicy: Prisma.$payrollpolicyPayload<ExtArgs> | null
      employee_employee_departmentIdTodepartment: Prisma.$employeePayload<ExtArgs>[]
      employee_employee_subDepartmentIdTodepartment: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      parentId: number | null
      payrollPolicyId: number | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type departmentGetPayload<S extends boolean | null | undefined | departmentDefaultArgs> = $Result.GetResult<Prisma.$departmentPayload, S>

  type departmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<departmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface departmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['department'], meta: { name: 'department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {departmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends departmentFindUniqueArgs>(args: SelectSubset<T, departmentFindUniqueArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {departmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends departmentFindUniqueOrThrowArgs>(args: SelectSubset<T, departmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends departmentFindFirstArgs>(args?: SelectSubset<T, departmentFindFirstArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends departmentFindFirstOrThrowArgs>(args?: SelectSubset<T, departmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends departmentFindManyArgs>(args?: SelectSubset<T, departmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {departmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends departmentCreateArgs>(args: SelectSubset<T, departmentCreateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {departmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends departmentCreateManyArgs>(args?: SelectSubset<T, departmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {departmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends departmentDeleteArgs>(args: SelectSubset<T, departmentDeleteArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {departmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends departmentUpdateArgs>(args: SelectSubset<T, departmentUpdateArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {departmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends departmentDeleteManyArgs>(args?: SelectSubset<T, departmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends departmentUpdateManyArgs>(args: SelectSubset<T, departmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {departmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends departmentUpsertArgs>(args: SelectSubset<T, departmentUpsertArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentCountArgs>(
      args?: Subset<T, departmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentGroupByArgs['orderBy'] }
        : { orderBy?: departmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the department model
   */
  readonly fields: departmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__departmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendancesummary<T extends department$attendancesummaryArgs<ExtArgs> = {}>(args?: Subset<T, department$attendancesummaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends department$departmentArgs<ExtArgs> = {}>(args?: Subset<T, department$departmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_department<T extends department$other_departmentArgs<ExtArgs> = {}>(args?: Subset<T, department$other_departmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollpolicy<T extends department$payrollpolicyArgs<ExtArgs> = {}>(args?: Subset<T, department$payrollpolicyArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee_employee_departmentIdTodepartment<T extends department$employee_employee_departmentIdTodepartmentArgs<ExtArgs> = {}>(args?: Subset<T, department$employee_employee_departmentIdTodepartmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee_employee_subDepartmentIdTodepartment<T extends department$employee_employee_subDepartmentIdTodepartmentArgs<ExtArgs> = {}>(args?: Subset<T, department$employee_employee_subDepartmentIdTodepartmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the department model
   */
  interface departmentFieldRefs {
    readonly id: FieldRef<"department", 'Int'>
    readonly name: FieldRef<"department", 'String'>
    readonly description: FieldRef<"department", 'String'>
    readonly createdAt: FieldRef<"department", 'DateTime'>
    readonly updatedAt: FieldRef<"department", 'DateTime'>
    readonly parentId: FieldRef<"department", 'Int'>
    readonly payrollPolicyId: FieldRef<"department", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * department findUnique
   */
  export type departmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findUniqueOrThrow
   */
  export type departmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department findFirst
   */
  export type departmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findFirstOrThrow
   */
  export type departmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department findMany
   */
  export type departmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department create
   */
  export type departmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to create a department.
     */
    data: XOR<departmentCreateInput, departmentUncheckedCreateInput>
  }

  /**
   * department createMany
   */
  export type departmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentCreateManyInput | departmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * department update
   */
  export type departmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to update a department.
     */
    data: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
    /**
     * Choose, which department to update.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department updateMany
   */
  export type departmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentWhereInput
    /**
     * Limit how many departments to update.
     */
    limit?: number
  }

  /**
   * department upsert
   */
  export type departmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The filter to search for the department to update in case it exists.
     */
    where: departmentWhereUniqueInput
    /**
     * In case the department found by the `where` argument doesn't exist, create a new department with this data.
     */
    create: XOR<departmentCreateInput, departmentUncheckedCreateInput>
    /**
     * In case the department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
  }

  /**
   * department delete
   */
  export type departmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter which department to delete.
     */
    where: departmentWhereUniqueInput
  }

  /**
   * department deleteMany
   */
  export type departmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentWhereInput
    /**
     * Limit how many departments to delete.
     */
    limit?: number
  }

  /**
   * department.attendancesummary
   */
  export type department$attendancesummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    where?: attendancesummaryWhereInput
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    cursor?: attendancesummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesummaryScalarFieldEnum | AttendancesummaryScalarFieldEnum[]
  }

  /**
   * department.department
   */
  export type department$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * department.other_department
   */
  export type department$other_departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    cursor?: departmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * department.payrollpolicy
   */
  export type department$payrollpolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    where?: payrollpolicyWhereInput
  }

  /**
   * department.employee_employee_departmentIdTodepartment
   */
  export type department$employee_employee_departmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * department.employee_employee_subDepartmentIdTodepartment
   */
  export type department$employee_employee_subDepartmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * department without action
   */
  export type departmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    maritalStatusId: number | null
    departmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    jobStatusId: number | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    agreementStatusId: number | null
    subDepartmentId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    maritalStatusId: number | null
    departmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    jobStatusId: number | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    agreementStatusId: number | null
    subDepartmentId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.employee_sex | null
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    subDepartmentId: number | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.employee_sex | null
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    subDepartmentId: number | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    baptismalName: number
    dateOfBirth: number
    sex: number
    nationality: number
    maritalStatusId: number
    departmentId: number
    positionId: number
    employmentTypeId: number
    employmentDate: number
    jobStatusId: number
    phone: number
    address: number
    subCity: number
    emergencyContactName: number
    emergencyContactPhone: number
    repentanceFatherName: number
    repentanceFatherChurch: number
    repentanceFatherPhone: number
    academicQualification: number
    educationalInstitution: number
    salary: number
    bonusSalary: number
    accountNumber: number
    agreementStatusId: number
    photo: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    subDepartmentId: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    userId?: true
    maritalStatusId?: true
    departmentId?: true
    positionId?: true
    employmentTypeId?: true
    jobStatusId?: true
    salary?: true
    bonusSalary?: true
    agreementStatusId?: true
    subDepartmentId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    userId?: true
    maritalStatusId?: true
    departmentId?: true
    positionId?: true
    employmentTypeId?: true
    jobStatusId?: true
    salary?: true
    bonusSalary?: true
    agreementStatusId?: true
    subDepartmentId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    subDepartmentId?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    subDepartmentId?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    subDepartmentId?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    userId: number | null
    firstName: string
    lastName: string
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.employee_sex
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal
    bonusSalary: Decimal
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    subDepartmentId: number | null
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    baptismalName?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    maritalStatusId?: boolean
    departmentId?: boolean
    positionId?: boolean
    employmentTypeId?: boolean
    employmentDate?: boolean
    jobStatusId?: boolean
    phone?: boolean
    address?: boolean
    subCity?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    repentanceFatherName?: boolean
    repentanceFatherChurch?: boolean
    repentanceFatherPhone?: boolean
    academicQualification?: boolean
    educationalInstitution?: boolean
    salary?: boolean
    bonusSalary?: boolean
    accountNumber?: boolean
    agreementStatusId?: boolean
    photo?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subDepartmentId?: boolean
    activitylog_activitylog_actorIdToemployee?: boolean | employee$activitylog_activitylog_actorIdToemployeeArgs<ExtArgs>
    activitylog_activitylog_targetIdToemployee?: boolean | employee$activitylog_activitylog_targetIdToemployeeArgs<ExtArgs>
    attendancelog?: boolean | employee$attendancelogArgs<ExtArgs>
    attendancesummary?: boolean | employee$attendancesummaryArgs<ExtArgs>
    complaint?: boolean | employee$complaintArgs<ExtArgs>
    agreementstatus?: boolean | employee$agreementstatusArgs<ExtArgs>
    department_employee_departmentIdTodepartment?: boolean | employee$department_employee_departmentIdTodepartmentArgs<ExtArgs>
    employmenttype?: boolean | employee$employmenttypeArgs<ExtArgs>
    jobstatus?: boolean | employee$jobstatusArgs<ExtArgs>
    maritalstatus?: boolean | employee$maritalstatusArgs<ExtArgs>
    position?: boolean | employee$positionArgs<ExtArgs>
    department_employee_subDepartmentIdTodepartment?: boolean | employee$department_employee_subDepartmentIdTodepartmentArgs<ExtArgs>
    user?: boolean | employee$userArgs<ExtArgs>
    employeeshift?: boolean | employee$employeeshiftArgs<ExtArgs>
    leave?: boolean | employee$leaveArgs<ExtArgs>
    meeting?: boolean | employee$meetingArgs<ExtArgs>
    overtimelog?: boolean | employee$overtimelogArgs<ExtArgs>
    performancereview?: boolean | employee$performancereviewArgs<ExtArgs>
    salaryRecords?: boolean | employee$salaryRecordsArgs<ExtArgs>
    termination?: boolean | employee$terminationArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type employeeSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    baptismalName?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    maritalStatusId?: boolean
    departmentId?: boolean
    positionId?: boolean
    employmentTypeId?: boolean
    employmentDate?: boolean
    jobStatusId?: boolean
    phone?: boolean
    address?: boolean
    subCity?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    repentanceFatherName?: boolean
    repentanceFatherChurch?: boolean
    repentanceFatherPhone?: boolean
    academicQualification?: boolean
    educationalInstitution?: boolean
    salary?: boolean
    bonusSalary?: boolean
    accountNumber?: boolean
    agreementStatusId?: boolean
    photo?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subDepartmentId?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "baptismalName" | "dateOfBirth" | "sex" | "nationality" | "maritalStatusId" | "departmentId" | "positionId" | "employmentTypeId" | "employmentDate" | "jobStatusId" | "phone" | "address" | "subCity" | "emergencyContactName" | "emergencyContactPhone" | "repentanceFatherName" | "repentanceFatherChurch" | "repentanceFatherPhone" | "academicQualification" | "educationalInstitution" | "salary" | "bonusSalary" | "accountNumber" | "agreementStatusId" | "photo" | "deletedAt" | "createdAt" | "updatedAt" | "subDepartmentId", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitylog_activitylog_actorIdToemployee?: boolean | employee$activitylog_activitylog_actorIdToemployeeArgs<ExtArgs>
    activitylog_activitylog_targetIdToemployee?: boolean | employee$activitylog_activitylog_targetIdToemployeeArgs<ExtArgs>
    attendancelog?: boolean | employee$attendancelogArgs<ExtArgs>
    attendancesummary?: boolean | employee$attendancesummaryArgs<ExtArgs>
    complaint?: boolean | employee$complaintArgs<ExtArgs>
    agreementstatus?: boolean | employee$agreementstatusArgs<ExtArgs>
    department_employee_departmentIdTodepartment?: boolean | employee$department_employee_departmentIdTodepartmentArgs<ExtArgs>
    employmenttype?: boolean | employee$employmenttypeArgs<ExtArgs>
    jobstatus?: boolean | employee$jobstatusArgs<ExtArgs>
    maritalstatus?: boolean | employee$maritalstatusArgs<ExtArgs>
    position?: boolean | employee$positionArgs<ExtArgs>
    department_employee_subDepartmentIdTodepartment?: boolean | employee$department_employee_subDepartmentIdTodepartmentArgs<ExtArgs>
    user?: boolean | employee$userArgs<ExtArgs>
    employeeshift?: boolean | employee$employeeshiftArgs<ExtArgs>
    leave?: boolean | employee$leaveArgs<ExtArgs>
    meeting?: boolean | employee$meetingArgs<ExtArgs>
    overtimelog?: boolean | employee$overtimelogArgs<ExtArgs>
    performancereview?: boolean | employee$performancereviewArgs<ExtArgs>
    salaryRecords?: boolean | employee$salaryRecordsArgs<ExtArgs>
    termination?: boolean | employee$terminationArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      activitylog_activitylog_actorIdToemployee: Prisma.$activitylogPayload<ExtArgs>[]
      activitylog_activitylog_targetIdToemployee: Prisma.$activitylogPayload<ExtArgs>[]
      attendancelog: Prisma.$attendancelogPayload<ExtArgs>[]
      attendancesummary: Prisma.$attendancesummaryPayload<ExtArgs>[]
      complaint: Prisma.$complaintPayload<ExtArgs>[]
      agreementstatus: Prisma.$agreementstatusPayload<ExtArgs> | null
      department_employee_departmentIdTodepartment: Prisma.$departmentPayload<ExtArgs> | null
      employmenttype: Prisma.$employmenttypePayload<ExtArgs> | null
      jobstatus: Prisma.$jobstatusPayload<ExtArgs> | null
      maritalstatus: Prisma.$maritalstatusPayload<ExtArgs> | null
      position: Prisma.$positionPayload<ExtArgs> | null
      department_employee_subDepartmentIdTodepartment: Prisma.$departmentPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
      employeeshift: Prisma.$employeeshiftPayload<ExtArgs>[]
      leave: Prisma.$leavePayload<ExtArgs>[]
      meeting: Prisma.$meetingPayload<ExtArgs>[]
      overtimelog: Prisma.$overtimelogPayload<ExtArgs>[]
      performancereview: Prisma.$performancereviewPayload<ExtArgs>[]
      salaryRecords: Prisma.$salaryPayload<ExtArgs>[]
      termination: Prisma.$terminationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      firstName: string
      lastName: string
      baptismalName: string | null
      dateOfBirth: Date | null
      sex: $Enums.employee_sex
      nationality: string | null
      maritalStatusId: number | null
      departmentId: number | null
      positionId: number | null
      employmentTypeId: number | null
      employmentDate: Date | null
      jobStatusId: number | null
      phone: string | null
      address: string | null
      subCity: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      repentanceFatherName: string | null
      repentanceFatherChurch: string | null
      repentanceFatherPhone: string | null
      academicQualification: string | null
      educationalInstitution: string | null
      salary: Prisma.Decimal
      bonusSalary: Prisma.Decimal
      accountNumber: string | null
      agreementStatusId: number | null
      photo: string | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
      subDepartmentId: number | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitylog_activitylog_actorIdToemployee<T extends employee$activitylog_activitylog_actorIdToemployeeArgs<ExtArgs> = {}>(args?: Subset<T, employee$activitylog_activitylog_actorIdToemployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activitylog_activitylog_targetIdToemployee<T extends employee$activitylog_activitylog_targetIdToemployeeArgs<ExtArgs> = {}>(args?: Subset<T, employee$activitylog_activitylog_targetIdToemployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activitylogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendancelog<T extends employee$attendancelogArgs<ExtArgs> = {}>(args?: Subset<T, employee$attendancelogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendancesummary<T extends employee$attendancesummaryArgs<ExtArgs> = {}>(args?: Subset<T, employee$attendancesummaryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancesummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaint<T extends employee$complaintArgs<ExtArgs> = {}>(args?: Subset<T, employee$complaintArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$complaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agreementstatus<T extends employee$agreementstatusArgs<ExtArgs> = {}>(args?: Subset<T, employee$agreementstatusArgs<ExtArgs>>): Prisma__agreementstatusClient<$Result.GetResult<Prisma.$agreementstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department_employee_departmentIdTodepartment<T extends employee$department_employee_departmentIdTodepartmentArgs<ExtArgs> = {}>(args?: Subset<T, employee$department_employee_departmentIdTodepartmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employmenttype<T extends employee$employmenttypeArgs<ExtArgs> = {}>(args?: Subset<T, employee$employmenttypeArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobstatus<T extends employee$jobstatusArgs<ExtArgs> = {}>(args?: Subset<T, employee$jobstatusArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    maritalstatus<T extends employee$maritalstatusArgs<ExtArgs> = {}>(args?: Subset<T, employee$maritalstatusArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends employee$positionArgs<ExtArgs> = {}>(args?: Subset<T, employee$positionArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department_employee_subDepartmentIdTodepartment<T extends employee$department_employee_subDepartmentIdTodepartmentArgs<ExtArgs> = {}>(args?: Subset<T, employee$department_employee_subDepartmentIdTodepartmentArgs<ExtArgs>>): Prisma__departmentClient<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends employee$userArgs<ExtArgs> = {}>(args?: Subset<T, employee$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employeeshift<T extends employee$employeeshiftArgs<ExtArgs> = {}>(args?: Subset<T, employee$employeeshiftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leave<T extends employee$leaveArgs<ExtArgs> = {}>(args?: Subset<T, employee$leaveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meeting<T extends employee$meetingArgs<ExtArgs> = {}>(args?: Subset<T, employee$meetingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimelog<T extends employee$overtimelogArgs<ExtArgs> = {}>(args?: Subset<T, employee$overtimelogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performancereview<T extends employee$performancereviewArgs<ExtArgs> = {}>(args?: Subset<T, employee$performancereviewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryRecords<T extends employee$salaryRecordsArgs<ExtArgs> = {}>(args?: Subset<T, employee$salaryRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    termination<T extends employee$terminationArgs<ExtArgs> = {}>(args?: Subset<T, employee$terminationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly id: FieldRef<"employee", 'Int'>
    readonly userId: FieldRef<"employee", 'Int'>
    readonly firstName: FieldRef<"employee", 'String'>
    readonly lastName: FieldRef<"employee", 'String'>
    readonly baptismalName: FieldRef<"employee", 'String'>
    readonly dateOfBirth: FieldRef<"employee", 'DateTime'>
    readonly sex: FieldRef<"employee", 'employee_sex'>
    readonly nationality: FieldRef<"employee", 'String'>
    readonly maritalStatusId: FieldRef<"employee", 'Int'>
    readonly departmentId: FieldRef<"employee", 'Int'>
    readonly positionId: FieldRef<"employee", 'Int'>
    readonly employmentTypeId: FieldRef<"employee", 'Int'>
    readonly employmentDate: FieldRef<"employee", 'DateTime'>
    readonly jobStatusId: FieldRef<"employee", 'Int'>
    readonly phone: FieldRef<"employee", 'String'>
    readonly address: FieldRef<"employee", 'String'>
    readonly subCity: FieldRef<"employee", 'String'>
    readonly emergencyContactName: FieldRef<"employee", 'String'>
    readonly emergencyContactPhone: FieldRef<"employee", 'String'>
    readonly repentanceFatherName: FieldRef<"employee", 'String'>
    readonly repentanceFatherChurch: FieldRef<"employee", 'String'>
    readonly repentanceFatherPhone: FieldRef<"employee", 'String'>
    readonly academicQualification: FieldRef<"employee", 'String'>
    readonly educationalInstitution: FieldRef<"employee", 'String'>
    readonly salary: FieldRef<"employee", 'Decimal'>
    readonly bonusSalary: FieldRef<"employee", 'Decimal'>
    readonly accountNumber: FieldRef<"employee", 'String'>
    readonly agreementStatusId: FieldRef<"employee", 'Int'>
    readonly photo: FieldRef<"employee", 'String'>
    readonly deletedAt: FieldRef<"employee", 'DateTime'>
    readonly createdAt: FieldRef<"employee", 'DateTime'>
    readonly updatedAt: FieldRef<"employee", 'DateTime'>
    readonly subDepartmentId: FieldRef<"employee", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.activitylog_activitylog_actorIdToemployee
   */
  export type employee$activitylog_activitylog_actorIdToemployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    where?: activitylogWhereInput
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    cursor?: activitylogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * employee.activitylog_activitylog_targetIdToemployee
   */
  export type employee$activitylog_activitylog_targetIdToemployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activitylog
     */
    select?: activitylogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the activitylog
     */
    omit?: activitylogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activitylogInclude<ExtArgs> | null
    where?: activitylogWhereInput
    orderBy?: activitylogOrderByWithRelationInput | activitylogOrderByWithRelationInput[]
    cursor?: activitylogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivitylogScalarFieldEnum | ActivitylogScalarFieldEnum[]
  }

  /**
   * employee.attendancelog
   */
  export type employee$attendancelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    where?: attendancelogWhereInput
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    cursor?: attendancelogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancelogScalarFieldEnum | AttendancelogScalarFieldEnum[]
  }

  /**
   * employee.attendancesummary
   */
  export type employee$attendancesummaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancesummary
     */
    select?: attendancesummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancesummary
     */
    omit?: attendancesummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancesummaryInclude<ExtArgs> | null
    where?: attendancesummaryWhereInput
    orderBy?: attendancesummaryOrderByWithRelationInput | attendancesummaryOrderByWithRelationInput[]
    cursor?: attendancesummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancesummaryScalarFieldEnum | AttendancesummaryScalarFieldEnum[]
  }

  /**
   * employee.complaint
   */
  export type employee$complaintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the complaint
     */
    select?: complaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the complaint
     */
    omit?: complaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: complaintInclude<ExtArgs> | null
    where?: complaintWhereInput
    orderBy?: complaintOrderByWithRelationInput | complaintOrderByWithRelationInput[]
    cursor?: complaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * employee.agreementstatus
   */
  export type employee$agreementstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agreementstatus
     */
    select?: agreementstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agreementstatus
     */
    omit?: agreementstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agreementstatusInclude<ExtArgs> | null
    where?: agreementstatusWhereInput
  }

  /**
   * employee.department_employee_departmentIdTodepartment
   */
  export type employee$department_employee_departmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * employee.employmenttype
   */
  export type employee$employmenttypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    where?: employmenttypeWhereInput
  }

  /**
   * employee.jobstatus
   */
  export type employee$jobstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    where?: jobstatusWhereInput
  }

  /**
   * employee.maritalstatus
   */
  export type employee$maritalstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    where?: maritalstatusWhereInput
  }

  /**
   * employee.position
   */
  export type employee$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    where?: positionWhereInput
  }

  /**
   * employee.department_employee_subDepartmentIdTodepartment
   */
  export type employee$department_employee_subDepartmentIdTodepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
  }

  /**
   * employee.user
   */
  export type employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * employee.employeeshift
   */
  export type employee$employeeshiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    where?: employeeshiftWhereInput
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    cursor?: employeeshiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeshiftScalarFieldEnum | EmployeeshiftScalarFieldEnum[]
  }

  /**
   * employee.leave
   */
  export type employee$leaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    where?: leaveWhereInput
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    cursor?: leaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * employee.meeting
   */
  export type employee$meetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    where?: meetingWhereInput
    orderBy?: meetingOrderByWithRelationInput | meetingOrderByWithRelationInput[]
    cursor?: meetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * employee.overtimelog
   */
  export type employee$overtimelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    where?: overtimelogWhereInput
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    cursor?: overtimelogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimelogScalarFieldEnum | OvertimelogScalarFieldEnum[]
  }

  /**
   * employee.performancereview
   */
  export type employee$performancereviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    where?: performancereviewWhereInput
    orderBy?: performancereviewOrderByWithRelationInput | performancereviewOrderByWithRelationInput[]
    cursor?: performancereviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformancereviewScalarFieldEnum | PerformancereviewScalarFieldEnum[]
  }

  /**
   * employee.salaryRecords
   */
  export type employee$salaryRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    where?: salaryWhereInput
    orderBy?: salaryOrderByWithRelationInput | salaryOrderByWithRelationInput[]
    cursor?: salaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * employee.termination
   */
  export type employee$terminationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    where?: terminationWhereInput
    orderBy?: terminationOrderByWithRelationInput | terminationOrderByWithRelationInput[]
    cursor?: terminationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model employeeshift
   */

  export type AggregateEmployeeshift = {
    _count: EmployeeshiftCountAggregateOutputType | null
    _avg: EmployeeshiftAvgAggregateOutputType | null
    _sum: EmployeeshiftSumAggregateOutputType | null
    _min: EmployeeshiftMinAggregateOutputType | null
    _max: EmployeeshiftMaxAggregateOutputType | null
  }

  export type EmployeeshiftAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
  }

  export type EmployeeshiftSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
  }

  export type EmployeeshiftMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
  }

  export type EmployeeshiftMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
  }

  export type EmployeeshiftCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    effectiveFrom: number
    effectiveTo: number
    _all: number
  }


  export type EmployeeshiftAvgAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
  }

  export type EmployeeshiftSumAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
  }

  export type EmployeeshiftMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
  }

  export type EmployeeshiftMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
  }

  export type EmployeeshiftCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
    _all?: true
  }

  export type EmployeeshiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeeshift to aggregate.
     */
    where?: employeeshiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeshifts to fetch.
     */
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeshiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeshifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeshifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employeeshifts
    **/
    _count?: true | EmployeeshiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeshiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeshiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeshiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeshiftMaxAggregateInputType
  }

  export type GetEmployeeshiftAggregateType<T extends EmployeeshiftAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeshift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeshift[P]>
      : GetScalarType<T[P], AggregateEmployeeshift[P]>
  }




  export type employeeshiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeshiftWhereInput
    orderBy?: employeeshiftOrderByWithAggregationInput | employeeshiftOrderByWithAggregationInput[]
    by: EmployeeshiftScalarFieldEnum[] | EmployeeshiftScalarFieldEnum
    having?: employeeshiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeshiftCountAggregateInputType | true
    _avg?: EmployeeshiftAvgAggregateInputType
    _sum?: EmployeeshiftSumAggregateInputType
    _min?: EmployeeshiftMinAggregateInputType
    _max?: EmployeeshiftMaxAggregateInputType
  }

  export type EmployeeshiftGroupByOutputType = {
    id: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date
    effectiveTo: Date | null
    _count: EmployeeshiftCountAggregateOutputType | null
    _avg: EmployeeshiftAvgAggregateOutputType | null
    _sum: EmployeeshiftSumAggregateOutputType | null
    _min: EmployeeshiftMinAggregateOutputType | null
    _max: EmployeeshiftMaxAggregateOutputType | null
  }

  type GetEmployeeshiftGroupByPayload<T extends employeeshiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeshiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeshiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeshiftGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeshiftGroupByOutputType[P]>
        }
      >
    >


  export type employeeshiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    shift?: boolean | shiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeshift"]>



  export type employeeshiftSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
  }

  export type employeeshiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "shiftId" | "effectiveFrom" | "effectiveTo", ExtArgs["result"]["employeeshift"]>
  export type employeeshiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    shift?: boolean | shiftDefaultArgs<ExtArgs>
  }

  export type $employeeshiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employeeshift"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      shift: Prisma.$shiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      shiftId: number
      effectiveFrom: Date
      effectiveTo: Date | null
    }, ExtArgs["result"]["employeeshift"]>
    composites: {}
  }

  type employeeshiftGetPayload<S extends boolean | null | undefined | employeeshiftDefaultArgs> = $Result.GetResult<Prisma.$employeeshiftPayload, S>

  type employeeshiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeshiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeshiftCountAggregateInputType | true
    }

  export interface employeeshiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employeeshift'], meta: { name: 'employeeshift' } }
    /**
     * Find zero or one Employeeshift that matches the filter.
     * @param {employeeshiftFindUniqueArgs} args - Arguments to find a Employeeshift
     * @example
     * // Get one Employeeshift
     * const employeeshift = await prisma.employeeshift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeshiftFindUniqueArgs>(args: SelectSubset<T, employeeshiftFindUniqueArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employeeshift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeshiftFindUniqueOrThrowArgs} args - Arguments to find a Employeeshift
     * @example
     * // Get one Employeeshift
     * const employeeshift = await prisma.employeeshift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeshiftFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeshiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employeeshift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftFindFirstArgs} args - Arguments to find a Employeeshift
     * @example
     * // Get one Employeeshift
     * const employeeshift = await prisma.employeeshift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeshiftFindFirstArgs>(args?: SelectSubset<T, employeeshiftFindFirstArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employeeshift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftFindFirstOrThrowArgs} args - Arguments to find a Employeeshift
     * @example
     * // Get one Employeeshift
     * const employeeshift = await prisma.employeeshift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeshiftFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeshiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employeeshifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employeeshifts
     * const employeeshifts = await prisma.employeeshift.findMany()
     * 
     * // Get first 10 Employeeshifts
     * const employeeshifts = await prisma.employeeshift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeshiftWithIdOnly = await prisma.employeeshift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeeshiftFindManyArgs>(args?: SelectSubset<T, employeeshiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employeeshift.
     * @param {employeeshiftCreateArgs} args - Arguments to create a Employeeshift.
     * @example
     * // Create one Employeeshift
     * const Employeeshift = await prisma.employeeshift.create({
     *   data: {
     *     // ... data to create a Employeeshift
     *   }
     * })
     * 
     */
    create<T extends employeeshiftCreateArgs>(args: SelectSubset<T, employeeshiftCreateArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employeeshifts.
     * @param {employeeshiftCreateManyArgs} args - Arguments to create many Employeeshifts.
     * @example
     * // Create many Employeeshifts
     * const employeeshift = await prisma.employeeshift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeshiftCreateManyArgs>(args?: SelectSubset<T, employeeshiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employeeshift.
     * @param {employeeshiftDeleteArgs} args - Arguments to delete one Employeeshift.
     * @example
     * // Delete one Employeeshift
     * const Employeeshift = await prisma.employeeshift.delete({
     *   where: {
     *     // ... filter to delete one Employeeshift
     *   }
     * })
     * 
     */
    delete<T extends employeeshiftDeleteArgs>(args: SelectSubset<T, employeeshiftDeleteArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employeeshift.
     * @param {employeeshiftUpdateArgs} args - Arguments to update one Employeeshift.
     * @example
     * // Update one Employeeshift
     * const employeeshift = await prisma.employeeshift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeshiftUpdateArgs>(args: SelectSubset<T, employeeshiftUpdateArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employeeshifts.
     * @param {employeeshiftDeleteManyArgs} args - Arguments to filter Employeeshifts to delete.
     * @example
     * // Delete a few Employeeshifts
     * const { count } = await prisma.employeeshift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeshiftDeleteManyArgs>(args?: SelectSubset<T, employeeshiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employeeshifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employeeshifts
     * const employeeshift = await prisma.employeeshift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeshiftUpdateManyArgs>(args: SelectSubset<T, employeeshiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employeeshift.
     * @param {employeeshiftUpsertArgs} args - Arguments to update or create a Employeeshift.
     * @example
     * // Update or create a Employeeshift
     * const employeeshift = await prisma.employeeshift.upsert({
     *   create: {
     *     // ... data to create a Employeeshift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employeeshift we want to update
     *   }
     * })
     */
    upsert<T extends employeeshiftUpsertArgs>(args: SelectSubset<T, employeeshiftUpsertArgs<ExtArgs>>): Prisma__employeeshiftClient<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employeeshifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftCountArgs} args - Arguments to filter Employeeshifts to count.
     * @example
     * // Count the number of Employeeshifts
     * const count = await prisma.employeeshift.count({
     *   where: {
     *     // ... the filter for the Employeeshifts we want to count
     *   }
     * })
    **/
    count<T extends employeeshiftCountArgs>(
      args?: Subset<T, employeeshiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeshiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employeeshift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeshiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeshiftAggregateArgs>(args: Subset<T, EmployeeshiftAggregateArgs>): Prisma.PrismaPromise<GetEmployeeshiftAggregateType<T>>

    /**
     * Group by Employeeshift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeshiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeshiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeshiftGroupByArgs['orderBy'] }
        : { orderBy?: employeeshiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeshiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeshiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employeeshift model
   */
  readonly fields: employeeshiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employeeshift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeshiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends shiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, shiftDefaultArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employeeshift model
   */
  interface employeeshiftFieldRefs {
    readonly id: FieldRef<"employeeshift", 'Int'>
    readonly employeeId: FieldRef<"employeeshift", 'Int'>
    readonly shiftId: FieldRef<"employeeshift", 'Int'>
    readonly effectiveFrom: FieldRef<"employeeshift", 'DateTime'>
    readonly effectiveTo: FieldRef<"employeeshift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employeeshift findUnique
   */
  export type employeeshiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter, which employeeshift to fetch.
     */
    where: employeeshiftWhereUniqueInput
  }

  /**
   * employeeshift findUniqueOrThrow
   */
  export type employeeshiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter, which employeeshift to fetch.
     */
    where: employeeshiftWhereUniqueInput
  }

  /**
   * employeeshift findFirst
   */
  export type employeeshiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter, which employeeshift to fetch.
     */
    where?: employeeshiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeshifts to fetch.
     */
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeeshifts.
     */
    cursor?: employeeshiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeshifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeshifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeeshifts.
     */
    distinct?: EmployeeshiftScalarFieldEnum | EmployeeshiftScalarFieldEnum[]
  }

  /**
   * employeeshift findFirstOrThrow
   */
  export type employeeshiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter, which employeeshift to fetch.
     */
    where?: employeeshiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeshifts to fetch.
     */
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeeshifts.
     */
    cursor?: employeeshiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeshifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeshifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeeshifts.
     */
    distinct?: EmployeeshiftScalarFieldEnum | EmployeeshiftScalarFieldEnum[]
  }

  /**
   * employeeshift findMany
   */
  export type employeeshiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter, which employeeshifts to fetch.
     */
    where?: employeeshiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeshifts to fetch.
     */
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employeeshifts.
     */
    cursor?: employeeshiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeshifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeshifts.
     */
    skip?: number
    distinct?: EmployeeshiftScalarFieldEnum | EmployeeshiftScalarFieldEnum[]
  }

  /**
   * employeeshift create
   */
  export type employeeshiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * The data needed to create a employeeshift.
     */
    data: XOR<employeeshiftCreateInput, employeeshiftUncheckedCreateInput>
  }

  /**
   * employeeshift createMany
   */
  export type employeeshiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employeeshifts.
     */
    data: employeeshiftCreateManyInput | employeeshiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employeeshift update
   */
  export type employeeshiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * The data needed to update a employeeshift.
     */
    data: XOR<employeeshiftUpdateInput, employeeshiftUncheckedUpdateInput>
    /**
     * Choose, which employeeshift to update.
     */
    where: employeeshiftWhereUniqueInput
  }

  /**
   * employeeshift updateMany
   */
  export type employeeshiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employeeshifts.
     */
    data: XOR<employeeshiftUpdateManyMutationInput, employeeshiftUncheckedUpdateManyInput>
    /**
     * Filter which employeeshifts to update
     */
    where?: employeeshiftWhereInput
    /**
     * Limit how many employeeshifts to update.
     */
    limit?: number
  }

  /**
   * employeeshift upsert
   */
  export type employeeshiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * The filter to search for the employeeshift to update in case it exists.
     */
    where: employeeshiftWhereUniqueInput
    /**
     * In case the employeeshift found by the `where` argument doesn't exist, create a new employeeshift with this data.
     */
    create: XOR<employeeshiftCreateInput, employeeshiftUncheckedCreateInput>
    /**
     * In case the employeeshift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeshiftUpdateInput, employeeshiftUncheckedUpdateInput>
  }

  /**
   * employeeshift delete
   */
  export type employeeshiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    /**
     * Filter which employeeshift to delete.
     */
    where: employeeshiftWhereUniqueInput
  }

  /**
   * employeeshift deleteMany
   */
  export type employeeshiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeeshifts to delete
     */
    where?: employeeshiftWhereInput
    /**
     * Limit how many employeeshifts to delete.
     */
    limit?: number
  }

  /**
   * employeeshift without action
   */
  export type employeeshiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
  }


  /**
   * Model employmenttype
   */

  export type AggregateEmploymenttype = {
    _count: EmploymenttypeCountAggregateOutputType | null
    _avg: EmploymenttypeAvgAggregateOutputType | null
    _sum: EmploymenttypeSumAggregateOutputType | null
    _min: EmploymenttypeMinAggregateOutputType | null
    _max: EmploymenttypeMaxAggregateOutputType | null
  }

  export type EmploymenttypeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmploymenttypeSumAggregateOutputType = {
    id: number | null
  }

  export type EmploymenttypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type EmploymenttypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type EmploymenttypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type EmploymenttypeAvgAggregateInputType = {
    id?: true
  }

  export type EmploymenttypeSumAggregateInputType = {
    id?: true
  }

  export type EmploymenttypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type EmploymenttypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type EmploymenttypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type EmploymenttypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employmenttype to aggregate.
     */
    where?: employmenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenttypes to fetch.
     */
    orderBy?: employmenttypeOrderByWithRelationInput | employmenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employmenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employmenttypes
    **/
    _count?: true | EmploymenttypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymenttypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymenttypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymenttypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymenttypeMaxAggregateInputType
  }

  export type GetEmploymenttypeAggregateType<T extends EmploymenttypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymenttype]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymenttype[P]>
      : GetScalarType<T[P], AggregateEmploymenttype[P]>
  }




  export type employmenttypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employmenttypeWhereInput
    orderBy?: employmenttypeOrderByWithAggregationInput | employmenttypeOrderByWithAggregationInput[]
    by: EmploymenttypeScalarFieldEnum[] | EmploymenttypeScalarFieldEnum
    having?: employmenttypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymenttypeCountAggregateInputType | true
    _avg?: EmploymenttypeAvgAggregateInputType
    _sum?: EmploymenttypeSumAggregateInputType
    _min?: EmploymenttypeMinAggregateInputType
    _max?: EmploymenttypeMaxAggregateInputType
  }

  export type EmploymenttypeGroupByOutputType = {
    id: number
    type: string
    _count: EmploymenttypeCountAggregateOutputType | null
    _avg: EmploymenttypeAvgAggregateOutputType | null
    _sum: EmploymenttypeSumAggregateOutputType | null
    _min: EmploymenttypeMinAggregateOutputType | null
    _max: EmploymenttypeMaxAggregateOutputType | null
  }

  type GetEmploymenttypeGroupByPayload<T extends employmenttypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymenttypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymenttypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymenttypeGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymenttypeGroupByOutputType[P]>
        }
      >
    >


  export type employmenttypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    employee?: boolean | employmenttype$employeeArgs<ExtArgs>
    _count?: boolean | EmploymenttypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmenttype"]>



  export type employmenttypeSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type employmenttypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["employmenttype"]>
  export type employmenttypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employmenttype$employeeArgs<ExtArgs>
    _count?: boolean | EmploymenttypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $employmenttypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employmenttype"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
    }, ExtArgs["result"]["employmenttype"]>
    composites: {}
  }

  type employmenttypeGetPayload<S extends boolean | null | undefined | employmenttypeDefaultArgs> = $Result.GetResult<Prisma.$employmenttypePayload, S>

  type employmenttypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employmenttypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymenttypeCountAggregateInputType | true
    }

  export interface employmenttypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employmenttype'], meta: { name: 'employmenttype' } }
    /**
     * Find zero or one Employmenttype that matches the filter.
     * @param {employmenttypeFindUniqueArgs} args - Arguments to find a Employmenttype
     * @example
     * // Get one Employmenttype
     * const employmenttype = await prisma.employmenttype.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employmenttypeFindUniqueArgs>(args: SelectSubset<T, employmenttypeFindUniqueArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employmenttype that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employmenttypeFindUniqueOrThrowArgs} args - Arguments to find a Employmenttype
     * @example
     * // Get one Employmenttype
     * const employmenttype = await prisma.employmenttype.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employmenttypeFindUniqueOrThrowArgs>(args: SelectSubset<T, employmenttypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employmenttype that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeFindFirstArgs} args - Arguments to find a Employmenttype
     * @example
     * // Get one Employmenttype
     * const employmenttype = await prisma.employmenttype.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employmenttypeFindFirstArgs>(args?: SelectSubset<T, employmenttypeFindFirstArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employmenttype that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeFindFirstOrThrowArgs} args - Arguments to find a Employmenttype
     * @example
     * // Get one Employmenttype
     * const employmenttype = await prisma.employmenttype.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employmenttypeFindFirstOrThrowArgs>(args?: SelectSubset<T, employmenttypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employmenttypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employmenttypes
     * const employmenttypes = await prisma.employmenttype.findMany()
     * 
     * // Get first 10 Employmenttypes
     * const employmenttypes = await prisma.employmenttype.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmenttypeWithIdOnly = await prisma.employmenttype.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employmenttypeFindManyArgs>(args?: SelectSubset<T, employmenttypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employmenttype.
     * @param {employmenttypeCreateArgs} args - Arguments to create a Employmenttype.
     * @example
     * // Create one Employmenttype
     * const Employmenttype = await prisma.employmenttype.create({
     *   data: {
     *     // ... data to create a Employmenttype
     *   }
     * })
     * 
     */
    create<T extends employmenttypeCreateArgs>(args: SelectSubset<T, employmenttypeCreateArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employmenttypes.
     * @param {employmenttypeCreateManyArgs} args - Arguments to create many Employmenttypes.
     * @example
     * // Create many Employmenttypes
     * const employmenttype = await prisma.employmenttype.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employmenttypeCreateManyArgs>(args?: SelectSubset<T, employmenttypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employmenttype.
     * @param {employmenttypeDeleteArgs} args - Arguments to delete one Employmenttype.
     * @example
     * // Delete one Employmenttype
     * const Employmenttype = await prisma.employmenttype.delete({
     *   where: {
     *     // ... filter to delete one Employmenttype
     *   }
     * })
     * 
     */
    delete<T extends employmenttypeDeleteArgs>(args: SelectSubset<T, employmenttypeDeleteArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employmenttype.
     * @param {employmenttypeUpdateArgs} args - Arguments to update one Employmenttype.
     * @example
     * // Update one Employmenttype
     * const employmenttype = await prisma.employmenttype.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employmenttypeUpdateArgs>(args: SelectSubset<T, employmenttypeUpdateArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employmenttypes.
     * @param {employmenttypeDeleteManyArgs} args - Arguments to filter Employmenttypes to delete.
     * @example
     * // Delete a few Employmenttypes
     * const { count } = await prisma.employmenttype.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employmenttypeDeleteManyArgs>(args?: SelectSubset<T, employmenttypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employmenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employmenttypes
     * const employmenttype = await prisma.employmenttype.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employmenttypeUpdateManyArgs>(args: SelectSubset<T, employmenttypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employmenttype.
     * @param {employmenttypeUpsertArgs} args - Arguments to update or create a Employmenttype.
     * @example
     * // Update or create a Employmenttype
     * const employmenttype = await prisma.employmenttype.upsert({
     *   create: {
     *     // ... data to create a Employmenttype
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employmenttype we want to update
     *   }
     * })
     */
    upsert<T extends employmenttypeUpsertArgs>(args: SelectSubset<T, employmenttypeUpsertArgs<ExtArgs>>): Prisma__employmenttypeClient<$Result.GetResult<Prisma.$employmenttypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employmenttypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeCountArgs} args - Arguments to filter Employmenttypes to count.
     * @example
     * // Count the number of Employmenttypes
     * const count = await prisma.employmenttype.count({
     *   where: {
     *     // ... the filter for the Employmenttypes we want to count
     *   }
     * })
    **/
    count<T extends employmenttypeCountArgs>(
      args?: Subset<T, employmenttypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymenttypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employmenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymenttypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymenttypeAggregateArgs>(args: Subset<T, EmploymenttypeAggregateArgs>): Prisma.PrismaPromise<GetEmploymenttypeAggregateType<T>>

    /**
     * Group by Employmenttype.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employmenttypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employmenttypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employmenttypeGroupByArgs['orderBy'] }
        : { orderBy?: employmenttypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employmenttypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymenttypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employmenttype model
   */
  readonly fields: employmenttypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employmenttype.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employmenttypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employmenttype$employeeArgs<ExtArgs> = {}>(args?: Subset<T, employmenttype$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employmenttype model
   */
  interface employmenttypeFieldRefs {
    readonly id: FieldRef<"employmenttype", 'Int'>
    readonly type: FieldRef<"employmenttype", 'String'>
  }
    

  // Custom InputTypes
  /**
   * employmenttype findUnique
   */
  export type employmenttypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter, which employmenttype to fetch.
     */
    where: employmenttypeWhereUniqueInput
  }

  /**
   * employmenttype findUniqueOrThrow
   */
  export type employmenttypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter, which employmenttype to fetch.
     */
    where: employmenttypeWhereUniqueInput
  }

  /**
   * employmenttype findFirst
   */
  export type employmenttypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter, which employmenttype to fetch.
     */
    where?: employmenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenttypes to fetch.
     */
    orderBy?: employmenttypeOrderByWithRelationInput | employmenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employmenttypes.
     */
    cursor?: employmenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employmenttypes.
     */
    distinct?: EmploymenttypeScalarFieldEnum | EmploymenttypeScalarFieldEnum[]
  }

  /**
   * employmenttype findFirstOrThrow
   */
  export type employmenttypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter, which employmenttype to fetch.
     */
    where?: employmenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenttypes to fetch.
     */
    orderBy?: employmenttypeOrderByWithRelationInput | employmenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employmenttypes.
     */
    cursor?: employmenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenttypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employmenttypes.
     */
    distinct?: EmploymenttypeScalarFieldEnum | EmploymenttypeScalarFieldEnum[]
  }

  /**
   * employmenttype findMany
   */
  export type employmenttypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter, which employmenttypes to fetch.
     */
    where?: employmenttypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employmenttypes to fetch.
     */
    orderBy?: employmenttypeOrderByWithRelationInput | employmenttypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employmenttypes.
     */
    cursor?: employmenttypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employmenttypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employmenttypes.
     */
    skip?: number
    distinct?: EmploymenttypeScalarFieldEnum | EmploymenttypeScalarFieldEnum[]
  }

  /**
   * employmenttype create
   */
  export type employmenttypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * The data needed to create a employmenttype.
     */
    data: XOR<employmenttypeCreateInput, employmenttypeUncheckedCreateInput>
  }

  /**
   * employmenttype createMany
   */
  export type employmenttypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employmenttypes.
     */
    data: employmenttypeCreateManyInput | employmenttypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employmenttype update
   */
  export type employmenttypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * The data needed to update a employmenttype.
     */
    data: XOR<employmenttypeUpdateInput, employmenttypeUncheckedUpdateInput>
    /**
     * Choose, which employmenttype to update.
     */
    where: employmenttypeWhereUniqueInput
  }

  /**
   * employmenttype updateMany
   */
  export type employmenttypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employmenttypes.
     */
    data: XOR<employmenttypeUpdateManyMutationInput, employmenttypeUncheckedUpdateManyInput>
    /**
     * Filter which employmenttypes to update
     */
    where?: employmenttypeWhereInput
    /**
     * Limit how many employmenttypes to update.
     */
    limit?: number
  }

  /**
   * employmenttype upsert
   */
  export type employmenttypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * The filter to search for the employmenttype to update in case it exists.
     */
    where: employmenttypeWhereUniqueInput
    /**
     * In case the employmenttype found by the `where` argument doesn't exist, create a new employmenttype with this data.
     */
    create: XOR<employmenttypeCreateInput, employmenttypeUncheckedCreateInput>
    /**
     * In case the employmenttype was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employmenttypeUpdateInput, employmenttypeUncheckedUpdateInput>
  }

  /**
   * employmenttype delete
   */
  export type employmenttypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
    /**
     * Filter which employmenttype to delete.
     */
    where: employmenttypeWhereUniqueInput
  }

  /**
   * employmenttype deleteMany
   */
  export type employmenttypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employmenttypes to delete
     */
    where?: employmenttypeWhereInput
    /**
     * Limit how many employmenttypes to delete.
     */
    limit?: number
  }

  /**
   * employmenttype.employee
   */
  export type employmenttype$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employmenttype without action
   */
  export type employmenttypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employmenttype
     */
    select?: employmenttypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employmenttype
     */
    omit?: employmenttypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employmenttypeInclude<ExtArgs> | null
  }


  /**
   * Model holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayAvgAggregateOutputType = {
    id: number | null
  }

  export type HolidaySumAggregateOutputType = {
    id: number | null
  }

  export type HolidayMinAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    isPublic: boolean | null
    description: string | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    isPublic: boolean | null
    description: string | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    date: number
    isPublic: number
    description: number
    _all: number
  }


  export type HolidayAvgAggregateInputType = {
    id?: true
  }

  export type HolidaySumAggregateInputType = {
    id?: true
  }

  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holiday to aggregate.
     */
    where?: holidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidayOrderByWithRelationInput | holidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: holidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolidayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolidaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type holidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: holidayWhereInput
    orderBy?: holidayOrderByWithAggregationInput | holidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: holidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _avg?: HolidayAvgAggregateInputType
    _sum?: HolidaySumAggregateInputType
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: number
    name: string
    date: Date
    isPublic: boolean
    description: string | null
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends holidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type holidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    isPublic?: boolean
    description?: boolean
  }, ExtArgs["result"]["holiday"]>



  export type holidaySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    isPublic?: boolean
    description?: boolean
  }

  export type holidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "isPublic" | "description", ExtArgs["result"]["holiday"]>

  export type $holidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "holiday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      date: Date
      isPublic: boolean
      description: string | null
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type holidayGetPayload<S extends boolean | null | undefined | holidayDefaultArgs> = $Result.GetResult<Prisma.$holidayPayload, S>

  type holidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<holidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface holidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['holiday'], meta: { name: 'holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {holidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends holidayFindUniqueArgs>(args: SelectSubset<T, holidayFindUniqueArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {holidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends holidayFindUniqueOrThrowArgs>(args: SelectSubset<T, holidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends holidayFindFirstArgs>(args?: SelectSubset<T, holidayFindFirstArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends holidayFindFirstOrThrowArgs>(args?: SelectSubset<T, holidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends holidayFindManyArgs>(args?: SelectSubset<T, holidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Holiday.
     * @param {holidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends holidayCreateArgs>(args: SelectSubset<T, holidayCreateArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holidays.
     * @param {holidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends holidayCreateManyArgs>(args?: SelectSubset<T, holidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Holiday.
     * @param {holidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends holidayDeleteArgs>(args: SelectSubset<T, holidayDeleteArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Holiday.
     * @param {holidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends holidayUpdateArgs>(args: SelectSubset<T, holidayUpdateArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holidays.
     * @param {holidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends holidayDeleteManyArgs>(args?: SelectSubset<T, holidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends holidayUpdateManyArgs>(args: SelectSubset<T, holidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {holidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends holidayUpsertArgs>(args: SelectSubset<T, holidayUpsertArgs<ExtArgs>>): Prisma__holidayClient<$Result.GetResult<Prisma.$holidayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends holidayCountArgs>(
      args?: Subset<T, holidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {holidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends holidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: holidayGroupByArgs['orderBy'] }
        : { orderBy?: holidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, holidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the holiday model
   */
  readonly fields: holidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__holidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the holiday model
   */
  interface holidayFieldRefs {
    readonly id: FieldRef<"holiday", 'Int'>
    readonly name: FieldRef<"holiday", 'String'>
    readonly date: FieldRef<"holiday", 'DateTime'>
    readonly isPublic: FieldRef<"holiday", 'Boolean'>
    readonly description: FieldRef<"holiday", 'String'>
  }
    

  // Custom InputTypes
  /**
   * holiday findUnique
   */
  export type holidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter, which holiday to fetch.
     */
    where: holidayWhereUniqueInput
  }

  /**
   * holiday findUniqueOrThrow
   */
  export type holidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter, which holiday to fetch.
     */
    where: holidayWhereUniqueInput
  }

  /**
   * holiday findFirst
   */
  export type holidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter, which holiday to fetch.
     */
    where?: holidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidayOrderByWithRelationInput | holidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holidays.
     */
    cursor?: holidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * holiday findFirstOrThrow
   */
  export type holidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter, which holiday to fetch.
     */
    where?: holidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidayOrderByWithRelationInput | holidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for holidays.
     */
    cursor?: holidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * holiday findMany
   */
  export type holidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter, which holidays to fetch.
     */
    where?: holidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of holidays to fetch.
     */
    orderBy?: holidayOrderByWithRelationInput | holidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing holidays.
     */
    cursor?: holidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * holiday create
   */
  export type holidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * The data needed to create a holiday.
     */
    data: XOR<holidayCreateInput, holidayUncheckedCreateInput>
  }

  /**
   * holiday createMany
   */
  export type holidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many holidays.
     */
    data: holidayCreateManyInput | holidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * holiday update
   */
  export type holidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * The data needed to update a holiday.
     */
    data: XOR<holidayUpdateInput, holidayUncheckedUpdateInput>
    /**
     * Choose, which holiday to update.
     */
    where: holidayWhereUniqueInput
  }

  /**
   * holiday updateMany
   */
  export type holidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update holidays.
     */
    data: XOR<holidayUpdateManyMutationInput, holidayUncheckedUpdateManyInput>
    /**
     * Filter which holidays to update
     */
    where?: holidayWhereInput
    /**
     * Limit how many holidays to update.
     */
    limit?: number
  }

  /**
   * holiday upsert
   */
  export type holidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * The filter to search for the holiday to update in case it exists.
     */
    where: holidayWhereUniqueInput
    /**
     * In case the holiday found by the `where` argument doesn't exist, create a new holiday with this data.
     */
    create: XOR<holidayCreateInput, holidayUncheckedCreateInput>
    /**
     * In case the holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<holidayUpdateInput, holidayUncheckedUpdateInput>
  }

  /**
   * holiday delete
   */
  export type holidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
    /**
     * Filter which holiday to delete.
     */
    where: holidayWhereUniqueInput
  }

  /**
   * holiday deleteMany
   */
  export type holidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which holidays to delete
     */
    where?: holidayWhereInput
    /**
     * Limit how many holidays to delete.
     */
    limit?: number
  }

  /**
   * holiday without action
   */
  export type holidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the holiday
     */
    select?: holidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the holiday
     */
    omit?: holidayOmit<ExtArgs> | null
  }


  /**
   * Model interview
   */

  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewAvgAggregateOutputType = {
    id: number | null
  }

  export type InterviewSumAggregateOutputType = {
    id: number | null
  }

  export type InterviewMinAggregateOutputType = {
    id: number | null
    candidateName: string | null
    position: string | null
    interviewDate: Date | null
    result: $Enums.interview_result | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewMaxAggregateOutputType = {
    id: number | null
    candidateName: string | null
    position: string | null
    interviewDate: Date | null
    result: $Enums.interview_result | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewCountAggregateOutputType = {
    id: number
    candidateName: number
    position: number
    interviewDate: number
    result: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewAvgAggregateInputType = {
    id?: true
  }

  export type InterviewSumAggregateInputType = {
    id?: true
  }

  export type InterviewMinAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewMaxAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewCountAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which interview to aggregate.
     */
    where?: interviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewOrderByWithRelationInput | interviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: interviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type interviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: interviewWhereInput
    orderBy?: interviewOrderByWithAggregationInput | interviewOrderByWithAggregationInput[]
    by: InterviewScalarFieldEnum[] | InterviewScalarFieldEnum
    having?: interviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _avg?: InterviewAvgAggregateInputType
    _sum?: InterviewSumAggregateInputType
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }

  export type InterviewGroupByOutputType = {
    id: number
    candidateName: string
    position: string | null
    interviewDate: Date | null
    result: $Enums.interview_result
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends interviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type interviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateName?: boolean
    position?: boolean
    interviewDate?: boolean
    result?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["interview"]>



  export type interviewSelectScalar = {
    id?: boolean
    candidateName?: boolean
    position?: boolean
    interviewDate?: boolean
    result?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type interviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "candidateName" | "position" | "interviewDate" | "result" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["interview"]>

  export type $interviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "interview"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      candidateName: string
      position: string | null
      interviewDate: Date | null
      result: $Enums.interview_result
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interview"]>
    composites: {}
  }

  type interviewGetPayload<S extends boolean | null | undefined | interviewDefaultArgs> = $Result.GetResult<Prisma.$interviewPayload, S>

  type interviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<interviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface interviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['interview'], meta: { name: 'interview' } }
    /**
     * Find zero or one Interview that matches the filter.
     * @param {interviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends interviewFindUniqueArgs>(args: SelectSubset<T, interviewFindUniqueArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {interviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends interviewFindUniqueOrThrowArgs>(args: SelectSubset<T, interviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends interviewFindFirstArgs>(args?: SelectSubset<T, interviewFindFirstArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends interviewFindFirstOrThrowArgs>(args?: SelectSubset<T, interviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewWithIdOnly = await prisma.interview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends interviewFindManyArgs>(args?: SelectSubset<T, interviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interview.
     * @param {interviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
     */
    create<T extends interviewCreateArgs>(args: SelectSubset<T, interviewCreateArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interviews.
     * @param {interviewCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends interviewCreateManyArgs>(args?: SelectSubset<T, interviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Interview.
     * @param {interviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
     */
    delete<T extends interviewDeleteArgs>(args: SelectSubset<T, interviewDeleteArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interview.
     * @param {interviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends interviewUpdateArgs>(args: SelectSubset<T, interviewUpdateArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interviews.
     * @param {interviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends interviewDeleteManyArgs>(args?: SelectSubset<T, interviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends interviewUpdateManyArgs>(args: SelectSubset<T, interviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interview.
     * @param {interviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
     */
    upsert<T extends interviewUpsertArgs>(args: SelectSubset<T, interviewUpsertArgs<ExtArgs>>): Prisma__interviewClient<$Result.GetResult<Prisma.$interviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends interviewCountArgs>(
      args?: Subset<T, interviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): Prisma.PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends interviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: interviewGroupByArgs['orderBy'] }
        : { orderBy?: interviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, interviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the interview model
   */
  readonly fields: interviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__interviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the interview model
   */
  interface interviewFieldRefs {
    readonly id: FieldRef<"interview", 'Int'>
    readonly candidateName: FieldRef<"interview", 'String'>
    readonly position: FieldRef<"interview", 'String'>
    readonly interviewDate: FieldRef<"interview", 'DateTime'>
    readonly result: FieldRef<"interview", 'interview_result'>
    readonly comments: FieldRef<"interview", 'String'>
    readonly createdAt: FieldRef<"interview", 'DateTime'>
    readonly updatedAt: FieldRef<"interview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * interview findUnique
   */
  export type interviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter, which interview to fetch.
     */
    where: interviewWhereUniqueInput
  }

  /**
   * interview findUniqueOrThrow
   */
  export type interviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter, which interview to fetch.
     */
    where: interviewWhereUniqueInput
  }

  /**
   * interview findFirst
   */
  export type interviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter, which interview to fetch.
     */
    where?: interviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewOrderByWithRelationInput | interviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for interviews.
     */
    cursor?: interviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * interview findFirstOrThrow
   */
  export type interviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter, which interview to fetch.
     */
    where?: interviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewOrderByWithRelationInput | interviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for interviews.
     */
    cursor?: interviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * interview findMany
   */
  export type interviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter, which interviews to fetch.
     */
    where?: interviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interviews to fetch.
     */
    orderBy?: interviewOrderByWithRelationInput | interviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing interviews.
     */
    cursor?: interviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interviews.
     */
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * interview create
   */
  export type interviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * The data needed to create a interview.
     */
    data: XOR<interviewCreateInput, interviewUncheckedCreateInput>
  }

  /**
   * interview createMany
   */
  export type interviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many interviews.
     */
    data: interviewCreateManyInput | interviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * interview update
   */
  export type interviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * The data needed to update a interview.
     */
    data: XOR<interviewUpdateInput, interviewUncheckedUpdateInput>
    /**
     * Choose, which interview to update.
     */
    where: interviewWhereUniqueInput
  }

  /**
   * interview updateMany
   */
  export type interviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update interviews.
     */
    data: XOR<interviewUpdateManyMutationInput, interviewUncheckedUpdateManyInput>
    /**
     * Filter which interviews to update
     */
    where?: interviewWhereInput
    /**
     * Limit how many interviews to update.
     */
    limit?: number
  }

  /**
   * interview upsert
   */
  export type interviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * The filter to search for the interview to update in case it exists.
     */
    where: interviewWhereUniqueInput
    /**
     * In case the interview found by the `where` argument doesn't exist, create a new interview with this data.
     */
    create: XOR<interviewCreateInput, interviewUncheckedCreateInput>
    /**
     * In case the interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<interviewUpdateInput, interviewUncheckedUpdateInput>
  }

  /**
   * interview delete
   */
  export type interviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
    /**
     * Filter which interview to delete.
     */
    where: interviewWhereUniqueInput
  }

  /**
   * interview deleteMany
   */
  export type interviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which interviews to delete
     */
    where?: interviewWhereInput
    /**
     * Limit how many interviews to delete.
     */
    limit?: number
  }

  /**
   * interview without action
   */
  export type interviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the interview
     */
    select?: interviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the interview
     */
    omit?: interviewOmit<ExtArgs> | null
  }


  /**
   * Model jobstatus
   */

  export type AggregateJobstatus = {
    _count: JobstatusCountAggregateOutputType | null
    _avg: JobstatusAvgAggregateOutputType | null
    _sum: JobstatusSumAggregateOutputType | null
    _min: JobstatusMinAggregateOutputType | null
    _max: JobstatusMaxAggregateOutputType | null
  }

  export type JobstatusAvgAggregateOutputType = {
    id: number | null
  }

  export type JobstatusSumAggregateOutputType = {
    id: number | null
  }

  export type JobstatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type JobstatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type JobstatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type JobstatusAvgAggregateInputType = {
    id?: true
  }

  export type JobstatusSumAggregateInputType = {
    id?: true
  }

  export type JobstatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type JobstatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type JobstatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type JobstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobstatus to aggregate.
     */
    where?: jobstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobstatuses to fetch.
     */
    orderBy?: jobstatusOrderByWithRelationInput | jobstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobstatuses
    **/
    _count?: true | JobstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobstatusMaxAggregateInputType
  }

  export type GetJobstatusAggregateType<T extends JobstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateJobstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobstatus[P]>
      : GetScalarType<T[P], AggregateJobstatus[P]>
  }




  export type jobstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobstatusWhereInput
    orderBy?: jobstatusOrderByWithAggregationInput | jobstatusOrderByWithAggregationInput[]
    by: JobstatusScalarFieldEnum[] | JobstatusScalarFieldEnum
    having?: jobstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobstatusCountAggregateInputType | true
    _avg?: JobstatusAvgAggregateInputType
    _sum?: JobstatusSumAggregateInputType
    _min?: JobstatusMinAggregateInputType
    _max?: JobstatusMaxAggregateInputType
  }

  export type JobstatusGroupByOutputType = {
    id: number
    status: string
    _count: JobstatusCountAggregateOutputType | null
    _avg: JobstatusAvgAggregateOutputType | null
    _sum: JobstatusSumAggregateOutputType | null
    _min: JobstatusMinAggregateOutputType | null
    _max: JobstatusMaxAggregateOutputType | null
  }

  type GetJobstatusGroupByPayload<T extends jobstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobstatusGroupByOutputType[P]>
            : GetScalarType<T[P], JobstatusGroupByOutputType[P]>
        }
      >
    >


  export type jobstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employee?: boolean | jobstatus$employeeArgs<ExtArgs>
    _count?: boolean | JobstatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobstatus"]>



  export type jobstatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type jobstatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["jobstatus"]>
  export type jobstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | jobstatus$employeeArgs<ExtArgs>
    _count?: boolean | JobstatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $jobstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobstatus"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["jobstatus"]>
    composites: {}
  }

  type jobstatusGetPayload<S extends boolean | null | undefined | jobstatusDefaultArgs> = $Result.GetResult<Prisma.$jobstatusPayload, S>

  type jobstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobstatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobstatusCountAggregateInputType | true
    }

  export interface jobstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobstatus'], meta: { name: 'jobstatus' } }
    /**
     * Find zero or one Jobstatus that matches the filter.
     * @param {jobstatusFindUniqueArgs} args - Arguments to find a Jobstatus
     * @example
     * // Get one Jobstatus
     * const jobstatus = await prisma.jobstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobstatusFindUniqueArgs>(args: SelectSubset<T, jobstatusFindUniqueArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobstatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobstatusFindUniqueOrThrowArgs} args - Arguments to find a Jobstatus
     * @example
     * // Get one Jobstatus
     * const jobstatus = await prisma.jobstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, jobstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusFindFirstArgs} args - Arguments to find a Jobstatus
     * @example
     * // Get one Jobstatus
     * const jobstatus = await prisma.jobstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobstatusFindFirstArgs>(args?: SelectSubset<T, jobstatusFindFirstArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusFindFirstOrThrowArgs} args - Arguments to find a Jobstatus
     * @example
     * // Get one Jobstatus
     * const jobstatus = await prisma.jobstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, jobstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobstatuses
     * const jobstatuses = await prisma.jobstatus.findMany()
     * 
     * // Get first 10 Jobstatuses
     * const jobstatuses = await prisma.jobstatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobstatusWithIdOnly = await prisma.jobstatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobstatusFindManyArgs>(args?: SelectSubset<T, jobstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobstatus.
     * @param {jobstatusCreateArgs} args - Arguments to create a Jobstatus.
     * @example
     * // Create one Jobstatus
     * const Jobstatus = await prisma.jobstatus.create({
     *   data: {
     *     // ... data to create a Jobstatus
     *   }
     * })
     * 
     */
    create<T extends jobstatusCreateArgs>(args: SelectSubset<T, jobstatusCreateArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobstatuses.
     * @param {jobstatusCreateManyArgs} args - Arguments to create many Jobstatuses.
     * @example
     * // Create many Jobstatuses
     * const jobstatus = await prisma.jobstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobstatusCreateManyArgs>(args?: SelectSubset<T, jobstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobstatus.
     * @param {jobstatusDeleteArgs} args - Arguments to delete one Jobstatus.
     * @example
     * // Delete one Jobstatus
     * const Jobstatus = await prisma.jobstatus.delete({
     *   where: {
     *     // ... filter to delete one Jobstatus
     *   }
     * })
     * 
     */
    delete<T extends jobstatusDeleteArgs>(args: SelectSubset<T, jobstatusDeleteArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobstatus.
     * @param {jobstatusUpdateArgs} args - Arguments to update one Jobstatus.
     * @example
     * // Update one Jobstatus
     * const jobstatus = await prisma.jobstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobstatusUpdateArgs>(args: SelectSubset<T, jobstatusUpdateArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobstatuses.
     * @param {jobstatusDeleteManyArgs} args - Arguments to filter Jobstatuses to delete.
     * @example
     * // Delete a few Jobstatuses
     * const { count } = await prisma.jobstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobstatusDeleteManyArgs>(args?: SelectSubset<T, jobstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobstatuses
     * const jobstatus = await prisma.jobstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobstatusUpdateManyArgs>(args: SelectSubset<T, jobstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobstatus.
     * @param {jobstatusUpsertArgs} args - Arguments to update or create a Jobstatus.
     * @example
     * // Update or create a Jobstatus
     * const jobstatus = await prisma.jobstatus.upsert({
     *   create: {
     *     // ... data to create a Jobstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobstatus we want to update
     *   }
     * })
     */
    upsert<T extends jobstatusUpsertArgs>(args: SelectSubset<T, jobstatusUpsertArgs<ExtArgs>>): Prisma__jobstatusClient<$Result.GetResult<Prisma.$jobstatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusCountArgs} args - Arguments to filter Jobstatuses to count.
     * @example
     * // Count the number of Jobstatuses
     * const count = await prisma.jobstatus.count({
     *   where: {
     *     // ... the filter for the Jobstatuses we want to count
     *   }
     * })
    **/
    count<T extends jobstatusCountArgs>(
      args?: Subset<T, jobstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobstatusAggregateArgs>(args: Subset<T, JobstatusAggregateArgs>): Prisma.PrismaPromise<GetJobstatusAggregateType<T>>

    /**
     * Group by Jobstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobstatusGroupByArgs['orderBy'] }
        : { orderBy?: jobstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobstatus model
   */
  readonly fields: jobstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends jobstatus$employeeArgs<ExtArgs> = {}>(args?: Subset<T, jobstatus$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobstatus model
   */
  interface jobstatusFieldRefs {
    readonly id: FieldRef<"jobstatus", 'Int'>
    readonly status: FieldRef<"jobstatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * jobstatus findUnique
   */
  export type jobstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter, which jobstatus to fetch.
     */
    where: jobstatusWhereUniqueInput
  }

  /**
   * jobstatus findUniqueOrThrow
   */
  export type jobstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter, which jobstatus to fetch.
     */
    where: jobstatusWhereUniqueInput
  }

  /**
   * jobstatus findFirst
   */
  export type jobstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter, which jobstatus to fetch.
     */
    where?: jobstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobstatuses to fetch.
     */
    orderBy?: jobstatusOrderByWithRelationInput | jobstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobstatuses.
     */
    cursor?: jobstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobstatuses.
     */
    distinct?: JobstatusScalarFieldEnum | JobstatusScalarFieldEnum[]
  }

  /**
   * jobstatus findFirstOrThrow
   */
  export type jobstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter, which jobstatus to fetch.
     */
    where?: jobstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobstatuses to fetch.
     */
    orderBy?: jobstatusOrderByWithRelationInput | jobstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobstatuses.
     */
    cursor?: jobstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobstatuses.
     */
    distinct?: JobstatusScalarFieldEnum | JobstatusScalarFieldEnum[]
  }

  /**
   * jobstatus findMany
   */
  export type jobstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter, which jobstatuses to fetch.
     */
    where?: jobstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobstatuses to fetch.
     */
    orderBy?: jobstatusOrderByWithRelationInput | jobstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobstatuses.
     */
    cursor?: jobstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobstatuses.
     */
    skip?: number
    distinct?: JobstatusScalarFieldEnum | JobstatusScalarFieldEnum[]
  }

  /**
   * jobstatus create
   */
  export type jobstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a jobstatus.
     */
    data: XOR<jobstatusCreateInput, jobstatusUncheckedCreateInput>
  }

  /**
   * jobstatus createMany
   */
  export type jobstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobstatuses.
     */
    data: jobstatusCreateManyInput | jobstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobstatus update
   */
  export type jobstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a jobstatus.
     */
    data: XOR<jobstatusUpdateInput, jobstatusUncheckedUpdateInput>
    /**
     * Choose, which jobstatus to update.
     */
    where: jobstatusWhereUniqueInput
  }

  /**
   * jobstatus updateMany
   */
  export type jobstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobstatuses.
     */
    data: XOR<jobstatusUpdateManyMutationInput, jobstatusUncheckedUpdateManyInput>
    /**
     * Filter which jobstatuses to update
     */
    where?: jobstatusWhereInput
    /**
     * Limit how many jobstatuses to update.
     */
    limit?: number
  }

  /**
   * jobstatus upsert
   */
  export type jobstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the jobstatus to update in case it exists.
     */
    where: jobstatusWhereUniqueInput
    /**
     * In case the jobstatus found by the `where` argument doesn't exist, create a new jobstatus with this data.
     */
    create: XOR<jobstatusCreateInput, jobstatusUncheckedCreateInput>
    /**
     * In case the jobstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobstatusUpdateInput, jobstatusUncheckedUpdateInput>
  }

  /**
   * jobstatus delete
   */
  export type jobstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
    /**
     * Filter which jobstatus to delete.
     */
    where: jobstatusWhereUniqueInput
  }

  /**
   * jobstatus deleteMany
   */
  export type jobstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobstatuses to delete
     */
    where?: jobstatusWhereInput
    /**
     * Limit how many jobstatuses to delete.
     */
    limit?: number
  }

  /**
   * jobstatus.employee
   */
  export type jobstatus$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * jobstatus without action
   */
  export type jobstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobstatus
     */
    select?: jobstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobstatus
     */
    omit?: jobstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobstatusInclude<ExtArgs> | null
  }


  /**
   * Model leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    approvedBy: number | null
  }

  export type LeaveSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    approvedBy: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.leave_leaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.leave_status | null
    reason: string | null
    approvedBy: number | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.leave_leaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.leave_status | null
    reason: string | null
    approvedBy: number | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    status: number
    reason: number
    approvedBy: number
    requestedAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    id?: true
    employeeId?: true
    approvedBy?: true
  }

  export type LeaveSumAggregateInputType = {
    id?: true
    employeeId?: true
    approvedBy?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leave to aggregate.
     */
    where?: leaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaves to fetch.
     */
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: leaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type leaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: leaveWhereInput
    orderBy?: leaveOrderByWithAggregationInput | leaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: leaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: number
    employeeId: number
    leaveType: $Enums.leave_leaveType
    startDate: Date
    endDate: Date
    status: $Enums.leave_status
    reason: string | null
    approvedBy: number | null
    requestedAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends leaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type leaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reason?: boolean
    approvedBy?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
    user?: boolean | leave$userArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>



  export type leaveSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reason?: boolean
    approvedBy?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
  }

  export type leaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "leaveType" | "startDate" | "endDate" | "status" | "reason" | "approvedBy" | "requestedAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type leaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | leave$userArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $leavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "leave"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      leaveType: $Enums.leave_leaveType
      startDate: Date
      endDate: Date
      status: $Enums.leave_status
      reason: string | null
      approvedBy: number | null
      requestedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type leaveGetPayload<S extends boolean | null | undefined | leaveDefaultArgs> = $Result.GetResult<Prisma.$leavePayload, S>

  type leaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<leaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface leaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['leave'], meta: { name: 'leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {leaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends leaveFindUniqueArgs>(args: SelectSubset<T, leaveFindUniqueArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {leaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends leaveFindUniqueOrThrowArgs>(args: SelectSubset<T, leaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends leaveFindFirstArgs>(args?: SelectSubset<T, leaveFindFirstArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends leaveFindFirstOrThrowArgs>(args?: SelectSubset<T, leaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends leaveFindManyArgs>(args?: SelectSubset<T, leaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {leaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends leaveCreateArgs>(args: SelectSubset<T, leaveCreateArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {leaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends leaveCreateManyArgs>(args?: SelectSubset<T, leaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave.
     * @param {leaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends leaveDeleteArgs>(args: SelectSubset<T, leaveDeleteArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {leaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends leaveUpdateArgs>(args: SelectSubset<T, leaveUpdateArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {leaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends leaveDeleteManyArgs>(args?: SelectSubset<T, leaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends leaveUpdateManyArgs>(args: SelectSubset<T, leaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {leaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends leaveUpsertArgs>(args: SelectSubset<T, leaveUpsertArgs<ExtArgs>>): Prisma__leaveClient<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends leaveCountArgs>(
      args?: Subset<T, leaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {leaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends leaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: leaveGroupByArgs['orderBy'] }
        : { orderBy?: leaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, leaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the leave model
   */
  readonly fields: leaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__leaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends leave$userArgs<ExtArgs> = {}>(args?: Subset<T, leave$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the leave model
   */
  interface leaveFieldRefs {
    readonly id: FieldRef<"leave", 'Int'>
    readonly employeeId: FieldRef<"leave", 'Int'>
    readonly leaveType: FieldRef<"leave", 'leave_leaveType'>
    readonly startDate: FieldRef<"leave", 'DateTime'>
    readonly endDate: FieldRef<"leave", 'DateTime'>
    readonly status: FieldRef<"leave", 'leave_status'>
    readonly reason: FieldRef<"leave", 'String'>
    readonly approvedBy: FieldRef<"leave", 'Int'>
    readonly requestedAt: FieldRef<"leave", 'DateTime'>
    readonly updatedAt: FieldRef<"leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * leave findUnique
   */
  export type leaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter, which leave to fetch.
     */
    where: leaveWhereUniqueInput
  }

  /**
   * leave findUniqueOrThrow
   */
  export type leaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter, which leave to fetch.
     */
    where: leaveWhereUniqueInput
  }

  /**
   * leave findFirst
   */
  export type leaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter, which leave to fetch.
     */
    where?: leaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaves to fetch.
     */
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leaves.
     */
    cursor?: leaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * leave findFirstOrThrow
   */
  export type leaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter, which leave to fetch.
     */
    where?: leaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaves to fetch.
     */
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for leaves.
     */
    cursor?: leaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * leave findMany
   */
  export type leaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter, which leaves to fetch.
     */
    where?: leaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of leaves to fetch.
     */
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing leaves.
     */
    cursor?: leaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * leave create
   */
  export type leaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * The data needed to create a leave.
     */
    data: XOR<leaveCreateInput, leaveUncheckedCreateInput>
  }

  /**
   * leave createMany
   */
  export type leaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many leaves.
     */
    data: leaveCreateManyInput | leaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * leave update
   */
  export type leaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * The data needed to update a leave.
     */
    data: XOR<leaveUpdateInput, leaveUncheckedUpdateInput>
    /**
     * Choose, which leave to update.
     */
    where: leaveWhereUniqueInput
  }

  /**
   * leave updateMany
   */
  export type leaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update leaves.
     */
    data: XOR<leaveUpdateManyMutationInput, leaveUncheckedUpdateManyInput>
    /**
     * Filter which leaves to update
     */
    where?: leaveWhereInput
    /**
     * Limit how many leaves to update.
     */
    limit?: number
  }

  /**
   * leave upsert
   */
  export type leaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * The filter to search for the leave to update in case it exists.
     */
    where: leaveWhereUniqueInput
    /**
     * In case the leave found by the `where` argument doesn't exist, create a new leave with this data.
     */
    create: XOR<leaveCreateInput, leaveUncheckedCreateInput>
    /**
     * In case the leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<leaveUpdateInput, leaveUncheckedUpdateInput>
  }

  /**
   * leave delete
   */
  export type leaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    /**
     * Filter which leave to delete.
     */
    where: leaveWhereUniqueInput
  }

  /**
   * leave deleteMany
   */
  export type leaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which leaves to delete
     */
    where?: leaveWhereInput
    /**
     * Limit how many leaves to delete.
     */
    limit?: number
  }

  /**
   * leave.user
   */
  export type leave$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * leave without action
   */
  export type leaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
  }


  /**
   * Model maritalstatus
   */

  export type AggregateMaritalstatus = {
    _count: MaritalstatusCountAggregateOutputType | null
    _avg: MaritalstatusAvgAggregateOutputType | null
    _sum: MaritalstatusSumAggregateOutputType | null
    _min: MaritalstatusMinAggregateOutputType | null
    _max: MaritalstatusMaxAggregateOutputType | null
  }

  export type MaritalstatusAvgAggregateOutputType = {
    id: number | null
  }

  export type MaritalstatusSumAggregateOutputType = {
    id: number | null
  }

  export type MaritalstatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type MaritalstatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type MaritalstatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type MaritalstatusAvgAggregateInputType = {
    id?: true
  }

  export type MaritalstatusSumAggregateInputType = {
    id?: true
  }

  export type MaritalstatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type MaritalstatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type MaritalstatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type MaritalstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maritalstatus to aggregate.
     */
    where?: maritalstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maritalstatuses to fetch.
     */
    orderBy?: maritalstatusOrderByWithRelationInput | maritalstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: maritalstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maritalstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maritalstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned maritalstatuses
    **/
    _count?: true | MaritalstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaritalstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaritalstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaritalstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaritalstatusMaxAggregateInputType
  }

  export type GetMaritalstatusAggregateType<T extends MaritalstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMaritalstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaritalstatus[P]>
      : GetScalarType<T[P], AggregateMaritalstatus[P]>
  }




  export type maritalstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: maritalstatusWhereInput
    orderBy?: maritalstatusOrderByWithAggregationInput | maritalstatusOrderByWithAggregationInput[]
    by: MaritalstatusScalarFieldEnum[] | MaritalstatusScalarFieldEnum
    having?: maritalstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaritalstatusCountAggregateInputType | true
    _avg?: MaritalstatusAvgAggregateInputType
    _sum?: MaritalstatusSumAggregateInputType
    _min?: MaritalstatusMinAggregateInputType
    _max?: MaritalstatusMaxAggregateInputType
  }

  export type MaritalstatusGroupByOutputType = {
    id: number
    status: string
    _count: MaritalstatusCountAggregateOutputType | null
    _avg: MaritalstatusAvgAggregateOutputType | null
    _sum: MaritalstatusSumAggregateOutputType | null
    _min: MaritalstatusMinAggregateOutputType | null
    _max: MaritalstatusMaxAggregateOutputType | null
  }

  type GetMaritalstatusGroupByPayload<T extends maritalstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaritalstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaritalstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaritalstatusGroupByOutputType[P]>
            : GetScalarType<T[P], MaritalstatusGroupByOutputType[P]>
        }
      >
    >


  export type maritalstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employee?: boolean | maritalstatus$employeeArgs<ExtArgs>
    _count?: boolean | MaritalstatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maritalstatus"]>



  export type maritalstatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type maritalstatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["maritalstatus"]>
  export type maritalstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | maritalstatus$employeeArgs<ExtArgs>
    _count?: boolean | MaritalstatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $maritalstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "maritalstatus"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["maritalstatus"]>
    composites: {}
  }

  type maritalstatusGetPayload<S extends boolean | null | undefined | maritalstatusDefaultArgs> = $Result.GetResult<Prisma.$maritalstatusPayload, S>

  type maritalstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<maritalstatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaritalstatusCountAggregateInputType | true
    }

  export interface maritalstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['maritalstatus'], meta: { name: 'maritalstatus' } }
    /**
     * Find zero or one Maritalstatus that matches the filter.
     * @param {maritalstatusFindUniqueArgs} args - Arguments to find a Maritalstatus
     * @example
     * // Get one Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends maritalstatusFindUniqueArgs>(args: SelectSubset<T, maritalstatusFindUniqueArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maritalstatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {maritalstatusFindUniqueOrThrowArgs} args - Arguments to find a Maritalstatus
     * @example
     * // Get one Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends maritalstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, maritalstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maritalstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusFindFirstArgs} args - Arguments to find a Maritalstatus
     * @example
     * // Get one Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends maritalstatusFindFirstArgs>(args?: SelectSubset<T, maritalstatusFindFirstArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maritalstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusFindFirstOrThrowArgs} args - Arguments to find a Maritalstatus
     * @example
     * // Get one Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends maritalstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, maritalstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maritalstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maritalstatuses
     * const maritalstatuses = await prisma.maritalstatus.findMany()
     * 
     * // Get first 10 Maritalstatuses
     * const maritalstatuses = await prisma.maritalstatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maritalstatusWithIdOnly = await prisma.maritalstatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends maritalstatusFindManyArgs>(args?: SelectSubset<T, maritalstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maritalstatus.
     * @param {maritalstatusCreateArgs} args - Arguments to create a Maritalstatus.
     * @example
     * // Create one Maritalstatus
     * const Maritalstatus = await prisma.maritalstatus.create({
     *   data: {
     *     // ... data to create a Maritalstatus
     *   }
     * })
     * 
     */
    create<T extends maritalstatusCreateArgs>(args: SelectSubset<T, maritalstatusCreateArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maritalstatuses.
     * @param {maritalstatusCreateManyArgs} args - Arguments to create many Maritalstatuses.
     * @example
     * // Create many Maritalstatuses
     * const maritalstatus = await prisma.maritalstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends maritalstatusCreateManyArgs>(args?: SelectSubset<T, maritalstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Maritalstatus.
     * @param {maritalstatusDeleteArgs} args - Arguments to delete one Maritalstatus.
     * @example
     * // Delete one Maritalstatus
     * const Maritalstatus = await prisma.maritalstatus.delete({
     *   where: {
     *     // ... filter to delete one Maritalstatus
     *   }
     * })
     * 
     */
    delete<T extends maritalstatusDeleteArgs>(args: SelectSubset<T, maritalstatusDeleteArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maritalstatus.
     * @param {maritalstatusUpdateArgs} args - Arguments to update one Maritalstatus.
     * @example
     * // Update one Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends maritalstatusUpdateArgs>(args: SelectSubset<T, maritalstatusUpdateArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maritalstatuses.
     * @param {maritalstatusDeleteManyArgs} args - Arguments to filter Maritalstatuses to delete.
     * @example
     * // Delete a few Maritalstatuses
     * const { count } = await prisma.maritalstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends maritalstatusDeleteManyArgs>(args?: SelectSubset<T, maritalstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maritalstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maritalstatuses
     * const maritalstatus = await prisma.maritalstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends maritalstatusUpdateManyArgs>(args: SelectSubset<T, maritalstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maritalstatus.
     * @param {maritalstatusUpsertArgs} args - Arguments to update or create a Maritalstatus.
     * @example
     * // Update or create a Maritalstatus
     * const maritalstatus = await prisma.maritalstatus.upsert({
     *   create: {
     *     // ... data to create a Maritalstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maritalstatus we want to update
     *   }
     * })
     */
    upsert<T extends maritalstatusUpsertArgs>(args: SelectSubset<T, maritalstatusUpsertArgs<ExtArgs>>): Prisma__maritalstatusClient<$Result.GetResult<Prisma.$maritalstatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maritalstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusCountArgs} args - Arguments to filter Maritalstatuses to count.
     * @example
     * // Count the number of Maritalstatuses
     * const count = await prisma.maritalstatus.count({
     *   where: {
     *     // ... the filter for the Maritalstatuses we want to count
     *   }
     * })
    **/
    count<T extends maritalstatusCountArgs>(
      args?: Subset<T, maritalstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaritalstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maritalstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaritalstatusAggregateArgs>(args: Subset<T, MaritalstatusAggregateArgs>): Prisma.PrismaPromise<GetMaritalstatusAggregateType<T>>

    /**
     * Group by Maritalstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {maritalstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends maritalstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: maritalstatusGroupByArgs['orderBy'] }
        : { orderBy?: maritalstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, maritalstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaritalstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the maritalstatus model
   */
  readonly fields: maritalstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for maritalstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__maritalstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends maritalstatus$employeeArgs<ExtArgs> = {}>(args?: Subset<T, maritalstatus$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the maritalstatus model
   */
  interface maritalstatusFieldRefs {
    readonly id: FieldRef<"maritalstatus", 'Int'>
    readonly status: FieldRef<"maritalstatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * maritalstatus findUnique
   */
  export type maritalstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter, which maritalstatus to fetch.
     */
    where: maritalstatusWhereUniqueInput
  }

  /**
   * maritalstatus findUniqueOrThrow
   */
  export type maritalstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter, which maritalstatus to fetch.
     */
    where: maritalstatusWhereUniqueInput
  }

  /**
   * maritalstatus findFirst
   */
  export type maritalstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter, which maritalstatus to fetch.
     */
    where?: maritalstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maritalstatuses to fetch.
     */
    orderBy?: maritalstatusOrderByWithRelationInput | maritalstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maritalstatuses.
     */
    cursor?: maritalstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maritalstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maritalstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maritalstatuses.
     */
    distinct?: MaritalstatusScalarFieldEnum | MaritalstatusScalarFieldEnum[]
  }

  /**
   * maritalstatus findFirstOrThrow
   */
  export type maritalstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter, which maritalstatus to fetch.
     */
    where?: maritalstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maritalstatuses to fetch.
     */
    orderBy?: maritalstatusOrderByWithRelationInput | maritalstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for maritalstatuses.
     */
    cursor?: maritalstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maritalstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maritalstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of maritalstatuses.
     */
    distinct?: MaritalstatusScalarFieldEnum | MaritalstatusScalarFieldEnum[]
  }

  /**
   * maritalstatus findMany
   */
  export type maritalstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter, which maritalstatuses to fetch.
     */
    where?: maritalstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of maritalstatuses to fetch.
     */
    orderBy?: maritalstatusOrderByWithRelationInput | maritalstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing maritalstatuses.
     */
    cursor?: maritalstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` maritalstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` maritalstatuses.
     */
    skip?: number
    distinct?: MaritalstatusScalarFieldEnum | MaritalstatusScalarFieldEnum[]
  }

  /**
   * maritalstatus create
   */
  export type maritalstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a maritalstatus.
     */
    data: XOR<maritalstatusCreateInput, maritalstatusUncheckedCreateInput>
  }

  /**
   * maritalstatus createMany
   */
  export type maritalstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many maritalstatuses.
     */
    data: maritalstatusCreateManyInput | maritalstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * maritalstatus update
   */
  export type maritalstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a maritalstatus.
     */
    data: XOR<maritalstatusUpdateInput, maritalstatusUncheckedUpdateInput>
    /**
     * Choose, which maritalstatus to update.
     */
    where: maritalstatusWhereUniqueInput
  }

  /**
   * maritalstatus updateMany
   */
  export type maritalstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update maritalstatuses.
     */
    data: XOR<maritalstatusUpdateManyMutationInput, maritalstatusUncheckedUpdateManyInput>
    /**
     * Filter which maritalstatuses to update
     */
    where?: maritalstatusWhereInput
    /**
     * Limit how many maritalstatuses to update.
     */
    limit?: number
  }

  /**
   * maritalstatus upsert
   */
  export type maritalstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the maritalstatus to update in case it exists.
     */
    where: maritalstatusWhereUniqueInput
    /**
     * In case the maritalstatus found by the `where` argument doesn't exist, create a new maritalstatus with this data.
     */
    create: XOR<maritalstatusCreateInput, maritalstatusUncheckedCreateInput>
    /**
     * In case the maritalstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<maritalstatusUpdateInput, maritalstatusUncheckedUpdateInput>
  }

  /**
   * maritalstatus delete
   */
  export type maritalstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
    /**
     * Filter which maritalstatus to delete.
     */
    where: maritalstatusWhereUniqueInput
  }

  /**
   * maritalstatus deleteMany
   */
  export type maritalstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which maritalstatuses to delete
     */
    where?: maritalstatusWhereInput
    /**
     * Limit how many maritalstatuses to delete.
     */
    limit?: number
  }

  /**
   * maritalstatus.employee
   */
  export type maritalstatus$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * maritalstatus without action
   */
  export type maritalstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the maritalstatus
     */
    select?: maritalstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the maritalstatus
     */
    omit?: maritalstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: maritalstatusInclude<ExtArgs> | null
  }


  /**
   * Model meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    creatorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    creatorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type MeetingSumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meeting to aggregate.
     */
    where?: meetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetings to fetch.
     */
    orderBy?: meetingOrderByWithRelationInput | meetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: meetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type meetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: meetingWhereInput
    orderBy?: meetingOrderByWithAggregationInput | meetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: meetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: Date
    time: string
    creatorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends meetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type meetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | meeting$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>



  export type meetingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type meetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "time" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["meeting"]>
  export type meetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | meeting$employeeArgs<ExtArgs>
  }

  export type $meetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "meeting"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: Date
      time: string
      creatorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type meetingGetPayload<S extends boolean | null | undefined | meetingDefaultArgs> = $Result.GetResult<Prisma.$meetingPayload, S>

  type meetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<meetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface meetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['meeting'], meta: { name: 'meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {meetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends meetingFindUniqueArgs>(args: SelectSubset<T, meetingFindUniqueArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {meetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends meetingFindUniqueOrThrowArgs>(args: SelectSubset<T, meetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends meetingFindFirstArgs>(args?: SelectSubset<T, meetingFindFirstArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends meetingFindFirstOrThrowArgs>(args?: SelectSubset<T, meetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends meetingFindManyArgs>(args?: SelectSubset<T, meetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {meetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends meetingCreateArgs>(args: SelectSubset<T, meetingCreateArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {meetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends meetingCreateManyArgs>(args?: SelectSubset<T, meetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meeting.
     * @param {meetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends meetingDeleteArgs>(args: SelectSubset<T, meetingDeleteArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {meetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends meetingUpdateArgs>(args: SelectSubset<T, meetingUpdateArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {meetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends meetingDeleteManyArgs>(args?: SelectSubset<T, meetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends meetingUpdateManyArgs>(args: SelectSubset<T, meetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {meetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends meetingUpsertArgs>(args: SelectSubset<T, meetingUpsertArgs<ExtArgs>>): Prisma__meetingClient<$Result.GetResult<Prisma.$meetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends meetingCountArgs>(
      args?: Subset<T, meetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {meetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends meetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: meetingGroupByArgs['orderBy'] }
        : { orderBy?: meetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, meetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the meeting model
   */
  readonly fields: meetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__meetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends meeting$employeeArgs<ExtArgs> = {}>(args?: Subset<T, meeting$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the meeting model
   */
  interface meetingFieldRefs {
    readonly id: FieldRef<"meeting", 'Int'>
    readonly title: FieldRef<"meeting", 'String'>
    readonly description: FieldRef<"meeting", 'String'>
    readonly date: FieldRef<"meeting", 'DateTime'>
    readonly time: FieldRef<"meeting", 'String'>
    readonly creatorId: FieldRef<"meeting", 'Int'>
    readonly createdAt: FieldRef<"meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * meeting findUnique
   */
  export type meetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter, which meeting to fetch.
     */
    where: meetingWhereUniqueInput
  }

  /**
   * meeting findUniqueOrThrow
   */
  export type meetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter, which meeting to fetch.
     */
    where: meetingWhereUniqueInput
  }

  /**
   * meeting findFirst
   */
  export type meetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter, which meeting to fetch.
     */
    where?: meetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetings to fetch.
     */
    orderBy?: meetingOrderByWithRelationInput | meetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetings.
     */
    cursor?: meetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * meeting findFirstOrThrow
   */
  export type meetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter, which meeting to fetch.
     */
    where?: meetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetings to fetch.
     */
    orderBy?: meetingOrderByWithRelationInput | meetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for meetings.
     */
    cursor?: meetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * meeting findMany
   */
  export type meetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter, which meetings to fetch.
     */
    where?: meetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of meetings to fetch.
     */
    orderBy?: meetingOrderByWithRelationInput | meetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing meetings.
     */
    cursor?: meetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * meeting create
   */
  export type meetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * The data needed to create a meeting.
     */
    data: XOR<meetingCreateInput, meetingUncheckedCreateInput>
  }

  /**
   * meeting createMany
   */
  export type meetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many meetings.
     */
    data: meetingCreateManyInput | meetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * meeting update
   */
  export type meetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * The data needed to update a meeting.
     */
    data: XOR<meetingUpdateInput, meetingUncheckedUpdateInput>
    /**
     * Choose, which meeting to update.
     */
    where: meetingWhereUniqueInput
  }

  /**
   * meeting updateMany
   */
  export type meetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update meetings.
     */
    data: XOR<meetingUpdateManyMutationInput, meetingUncheckedUpdateManyInput>
    /**
     * Filter which meetings to update
     */
    where?: meetingWhereInput
    /**
     * Limit how many meetings to update.
     */
    limit?: number
  }

  /**
   * meeting upsert
   */
  export type meetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * The filter to search for the meeting to update in case it exists.
     */
    where: meetingWhereUniqueInput
    /**
     * In case the meeting found by the `where` argument doesn't exist, create a new meeting with this data.
     */
    create: XOR<meetingCreateInput, meetingUncheckedCreateInput>
    /**
     * In case the meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<meetingUpdateInput, meetingUncheckedUpdateInput>
  }

  /**
   * meeting delete
   */
  export type meetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
    /**
     * Filter which meeting to delete.
     */
    where: meetingWhereUniqueInput
  }

  /**
   * meeting deleteMany
   */
  export type meetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which meetings to delete
     */
    where?: meetingWhereInput
    /**
     * Limit how many meetings to delete.
     */
    limit?: number
  }

  /**
   * meeting.employee
   */
  export type meeting$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * meeting without action
   */
  export type meetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the meeting
     */
    select?: meetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the meeting
     */
    omit?: meetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: meetingInclude<ExtArgs> | null
  }


  /**
   * Model overtimelog
   */

  export type AggregateOvertimelog = {
    _count: OvertimelogCountAggregateOutputType | null
    _avg: OvertimelogAvgAggregateOutputType | null
    _sum: OvertimelogSumAggregateOutputType | null
    _min: OvertimelogMinAggregateOutputType | null
    _max: OvertimelogMaxAggregateOutputType | null
  }

  export type OvertimelogAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    hours: Decimal | null
    approvedBy: number | null
  }

  export type OvertimelogSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    hours: Decimal | null
    approvedBy: number | null
  }

  export type OvertimelogMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    hours: Decimal | null
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.overtimelog_approvalStatus | null
    compensationMethod: $Enums.overtimelog_compensationMethod | null
    endTime: Date | null
    startTime: Date | null
    overtimeType: $Enums.overtimelog_overtimeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimelogMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    hours: Decimal | null
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.overtimelog_approvalStatus | null
    compensationMethod: $Enums.overtimelog_compensationMethod | null
    endTime: Date | null
    startTime: Date | null
    overtimeType: $Enums.overtimelog_overtimeType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimelogCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    hours: number
    reason: number
    approvedBy: number
    approvalStatus: number
    compensationMethod: number
    endTime: number
    startTime: number
    overtimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OvertimelogAvgAggregateInputType = {
    id?: true
    employeeId?: true
    hours?: true
    approvedBy?: true
  }

  export type OvertimelogSumAggregateInputType = {
    id?: true
    employeeId?: true
    hours?: true
    approvedBy?: true
  }

  export type OvertimelogMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
    endTime?: true
    startTime?: true
    overtimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimelogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
    endTime?: true
    startTime?: true
    overtimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimelogCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
    endTime?: true
    startTime?: true
    overtimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OvertimelogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which overtimelog to aggregate.
     */
    where?: overtimelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overtimelogs to fetch.
     */
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: overtimelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overtimelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overtimelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned overtimelogs
    **/
    _count?: true | OvertimelogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimelogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimelogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimelogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimelogMaxAggregateInputType
  }

  export type GetOvertimelogAggregateType<T extends OvertimelogAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertimelog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertimelog[P]>
      : GetScalarType<T[P], AggregateOvertimelog[P]>
  }




  export type overtimelogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: overtimelogWhereInput
    orderBy?: overtimelogOrderByWithAggregationInput | overtimelogOrderByWithAggregationInput[]
    by: OvertimelogScalarFieldEnum[] | OvertimelogScalarFieldEnum
    having?: overtimelogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimelogCountAggregateInputType | true
    _avg?: OvertimelogAvgAggregateInputType
    _sum?: OvertimelogSumAggregateInputType
    _min?: OvertimelogMinAggregateInputType
    _max?: OvertimelogMaxAggregateInputType
  }

  export type OvertimelogGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    hours: Decimal | null
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.overtimelog_approvalStatus
    compensationMethod: $Enums.overtimelog_compensationMethod
    endTime: Date | null
    startTime: Date | null
    overtimeType: $Enums.overtimelog_overtimeType
    createdAt: Date
    updatedAt: Date
    _count: OvertimelogCountAggregateOutputType | null
    _avg: OvertimelogAvgAggregateOutputType | null
    _sum: OvertimelogSumAggregateOutputType | null
    _min: OvertimelogMinAggregateOutputType | null
    _max: OvertimelogMaxAggregateOutputType | null
  }

  type GetOvertimelogGroupByPayload<T extends overtimelogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimelogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimelogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimelogGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimelogGroupByOutputType[P]>
        }
      >
    >


  export type overtimelogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    compensationMethod?: boolean
    endTime?: boolean
    startTime?: boolean
    overtimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | overtimelog$userArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtimelog"]>



  export type overtimelogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    hours?: boolean
    reason?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    compensationMethod?: boolean
    endTime?: boolean
    startTime?: boolean
    overtimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type overtimelogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "hours" | "reason" | "approvedBy" | "approvalStatus" | "compensationMethod" | "endTime" | "startTime" | "overtimeType" | "createdAt" | "updatedAt", ExtArgs["result"]["overtimelog"]>
  export type overtimelogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | overtimelog$userArgs<ExtArgs>
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $overtimelogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "overtimelog"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      hours: Prisma.Decimal | null
      reason: string | null
      approvedBy: number | null
      approvalStatus: $Enums.overtimelog_approvalStatus
      compensationMethod: $Enums.overtimelog_compensationMethod
      endTime: Date | null
      startTime: Date | null
      overtimeType: $Enums.overtimelog_overtimeType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["overtimelog"]>
    composites: {}
  }

  type overtimelogGetPayload<S extends boolean | null | undefined | overtimelogDefaultArgs> = $Result.GetResult<Prisma.$overtimelogPayload, S>

  type overtimelogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<overtimelogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimelogCountAggregateInputType | true
    }

  export interface overtimelogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['overtimelog'], meta: { name: 'overtimelog' } }
    /**
     * Find zero or one Overtimelog that matches the filter.
     * @param {overtimelogFindUniqueArgs} args - Arguments to find a Overtimelog
     * @example
     * // Get one Overtimelog
     * const overtimelog = await prisma.overtimelog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends overtimelogFindUniqueArgs>(args: SelectSubset<T, overtimelogFindUniqueArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Overtimelog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {overtimelogFindUniqueOrThrowArgs} args - Arguments to find a Overtimelog
     * @example
     * // Get one Overtimelog
     * const overtimelog = await prisma.overtimelog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends overtimelogFindUniqueOrThrowArgs>(args: SelectSubset<T, overtimelogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtimelog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogFindFirstArgs} args - Arguments to find a Overtimelog
     * @example
     * // Get one Overtimelog
     * const overtimelog = await prisma.overtimelog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends overtimelogFindFirstArgs>(args?: SelectSubset<T, overtimelogFindFirstArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtimelog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogFindFirstOrThrowArgs} args - Arguments to find a Overtimelog
     * @example
     * // Get one Overtimelog
     * const overtimelog = await prisma.overtimelog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends overtimelogFindFirstOrThrowArgs>(args?: SelectSubset<T, overtimelogFindFirstOrThrowArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Overtimelogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overtimelogs
     * const overtimelogs = await prisma.overtimelog.findMany()
     * 
     * // Get first 10 Overtimelogs
     * const overtimelogs = await prisma.overtimelog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimelogWithIdOnly = await prisma.overtimelog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends overtimelogFindManyArgs>(args?: SelectSubset<T, overtimelogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Overtimelog.
     * @param {overtimelogCreateArgs} args - Arguments to create a Overtimelog.
     * @example
     * // Create one Overtimelog
     * const Overtimelog = await prisma.overtimelog.create({
     *   data: {
     *     // ... data to create a Overtimelog
     *   }
     * })
     * 
     */
    create<T extends overtimelogCreateArgs>(args: SelectSubset<T, overtimelogCreateArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Overtimelogs.
     * @param {overtimelogCreateManyArgs} args - Arguments to create many Overtimelogs.
     * @example
     * // Create many Overtimelogs
     * const overtimelog = await prisma.overtimelog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends overtimelogCreateManyArgs>(args?: SelectSubset<T, overtimelogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Overtimelog.
     * @param {overtimelogDeleteArgs} args - Arguments to delete one Overtimelog.
     * @example
     * // Delete one Overtimelog
     * const Overtimelog = await prisma.overtimelog.delete({
     *   where: {
     *     // ... filter to delete one Overtimelog
     *   }
     * })
     * 
     */
    delete<T extends overtimelogDeleteArgs>(args: SelectSubset<T, overtimelogDeleteArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Overtimelog.
     * @param {overtimelogUpdateArgs} args - Arguments to update one Overtimelog.
     * @example
     * // Update one Overtimelog
     * const overtimelog = await prisma.overtimelog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends overtimelogUpdateArgs>(args: SelectSubset<T, overtimelogUpdateArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Overtimelogs.
     * @param {overtimelogDeleteManyArgs} args - Arguments to filter Overtimelogs to delete.
     * @example
     * // Delete a few Overtimelogs
     * const { count } = await prisma.overtimelog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends overtimelogDeleteManyArgs>(args?: SelectSubset<T, overtimelogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overtimelogs
     * const overtimelog = await prisma.overtimelog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends overtimelogUpdateManyArgs>(args: SelectSubset<T, overtimelogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Overtimelog.
     * @param {overtimelogUpsertArgs} args - Arguments to update or create a Overtimelog.
     * @example
     * // Update or create a Overtimelog
     * const overtimelog = await prisma.overtimelog.upsert({
     *   create: {
     *     // ... data to create a Overtimelog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overtimelog we want to update
     *   }
     * })
     */
    upsert<T extends overtimelogUpsertArgs>(args: SelectSubset<T, overtimelogUpsertArgs<ExtArgs>>): Prisma__overtimelogClient<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Overtimelogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogCountArgs} args - Arguments to filter Overtimelogs to count.
     * @example
     * // Count the number of Overtimelogs
     * const count = await prisma.overtimelog.count({
     *   where: {
     *     // ... the filter for the Overtimelogs we want to count
     *   }
     * })
    **/
    count<T extends overtimelogCountArgs>(
      args?: Subset<T, overtimelogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimelogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overtimelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimelogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimelogAggregateArgs>(args: Subset<T, OvertimelogAggregateArgs>): Prisma.PrismaPromise<GetOvertimelogAggregateType<T>>

    /**
     * Group by Overtimelog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {overtimelogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends overtimelogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: overtimelogGroupByArgs['orderBy'] }
        : { orderBy?: overtimelogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, overtimelogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimelogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the overtimelog model
   */
  readonly fields: overtimelogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for overtimelog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__overtimelogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends overtimelog$userArgs<ExtArgs> = {}>(args?: Subset<T, overtimelog$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the overtimelog model
   */
  interface overtimelogFieldRefs {
    readonly id: FieldRef<"overtimelog", 'Int'>
    readonly employeeId: FieldRef<"overtimelog", 'Int'>
    readonly date: FieldRef<"overtimelog", 'DateTime'>
    readonly hours: FieldRef<"overtimelog", 'Decimal'>
    readonly reason: FieldRef<"overtimelog", 'String'>
    readonly approvedBy: FieldRef<"overtimelog", 'Int'>
    readonly approvalStatus: FieldRef<"overtimelog", 'overtimelog_approvalStatus'>
    readonly compensationMethod: FieldRef<"overtimelog", 'overtimelog_compensationMethod'>
    readonly endTime: FieldRef<"overtimelog", 'DateTime'>
    readonly startTime: FieldRef<"overtimelog", 'DateTime'>
    readonly overtimeType: FieldRef<"overtimelog", 'overtimelog_overtimeType'>
    readonly createdAt: FieldRef<"overtimelog", 'DateTime'>
    readonly updatedAt: FieldRef<"overtimelog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * overtimelog findUnique
   */
  export type overtimelogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter, which overtimelog to fetch.
     */
    where: overtimelogWhereUniqueInput
  }

  /**
   * overtimelog findUniqueOrThrow
   */
  export type overtimelogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter, which overtimelog to fetch.
     */
    where: overtimelogWhereUniqueInput
  }

  /**
   * overtimelog findFirst
   */
  export type overtimelogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter, which overtimelog to fetch.
     */
    where?: overtimelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overtimelogs to fetch.
     */
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for overtimelogs.
     */
    cursor?: overtimelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overtimelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overtimelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of overtimelogs.
     */
    distinct?: OvertimelogScalarFieldEnum | OvertimelogScalarFieldEnum[]
  }

  /**
   * overtimelog findFirstOrThrow
   */
  export type overtimelogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter, which overtimelog to fetch.
     */
    where?: overtimelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overtimelogs to fetch.
     */
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for overtimelogs.
     */
    cursor?: overtimelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overtimelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overtimelogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of overtimelogs.
     */
    distinct?: OvertimelogScalarFieldEnum | OvertimelogScalarFieldEnum[]
  }

  /**
   * overtimelog findMany
   */
  export type overtimelogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter, which overtimelogs to fetch.
     */
    where?: overtimelogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of overtimelogs to fetch.
     */
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing overtimelogs.
     */
    cursor?: overtimelogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` overtimelogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` overtimelogs.
     */
    skip?: number
    distinct?: OvertimelogScalarFieldEnum | OvertimelogScalarFieldEnum[]
  }

  /**
   * overtimelog create
   */
  export type overtimelogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * The data needed to create a overtimelog.
     */
    data: XOR<overtimelogCreateInput, overtimelogUncheckedCreateInput>
  }

  /**
   * overtimelog createMany
   */
  export type overtimelogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many overtimelogs.
     */
    data: overtimelogCreateManyInput | overtimelogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * overtimelog update
   */
  export type overtimelogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * The data needed to update a overtimelog.
     */
    data: XOR<overtimelogUpdateInput, overtimelogUncheckedUpdateInput>
    /**
     * Choose, which overtimelog to update.
     */
    where: overtimelogWhereUniqueInput
  }

  /**
   * overtimelog updateMany
   */
  export type overtimelogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update overtimelogs.
     */
    data: XOR<overtimelogUpdateManyMutationInput, overtimelogUncheckedUpdateManyInput>
    /**
     * Filter which overtimelogs to update
     */
    where?: overtimelogWhereInput
    /**
     * Limit how many overtimelogs to update.
     */
    limit?: number
  }

  /**
   * overtimelog upsert
   */
  export type overtimelogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * The filter to search for the overtimelog to update in case it exists.
     */
    where: overtimelogWhereUniqueInput
    /**
     * In case the overtimelog found by the `where` argument doesn't exist, create a new overtimelog with this data.
     */
    create: XOR<overtimelogCreateInput, overtimelogUncheckedCreateInput>
    /**
     * In case the overtimelog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<overtimelogUpdateInput, overtimelogUncheckedUpdateInput>
  }

  /**
   * overtimelog delete
   */
  export type overtimelogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    /**
     * Filter which overtimelog to delete.
     */
    where: overtimelogWhereUniqueInput
  }

  /**
   * overtimelog deleteMany
   */
  export type overtimelogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which overtimelogs to delete
     */
    where?: overtimelogWhereInput
    /**
     * Limit how many overtimelogs to delete.
     */
    limit?: number
  }

  /**
   * overtimelog.user
   */
  export type overtimelog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * overtimelog without action
   */
  export type overtimelogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
  }


  /**
   * Model payrollpolicy
   */

  export type AggregatePayrollpolicy = {
    _count: PayrollpolicyCountAggregateOutputType | null
    _avg: PayrollpolicyAvgAggregateOutputType | null
    _sum: PayrollpolicySumAggregateOutputType | null
    _min: PayrollpolicyMinAggregateOutputType | null
    _max: PayrollpolicyMaxAggregateOutputType | null
  }

  export type PayrollpolicyAvgAggregateOutputType = {
    id: number | null
    otMultiplierWeekday1: Decimal | null
    otMultiplierWeekday2: Decimal | null
    otMultiplierSunday: Decimal | null
    otMultiplierHoliday: Decimal | null
    otMultiplierSleepover: Decimal | null
  }

  export type PayrollpolicySumAggregateOutputType = {
    id: number | null
    otMultiplierWeekday1: Decimal | null
    otMultiplierWeekday2: Decimal | null
    otMultiplierSunday: Decimal | null
    otMultiplierHoliday: Decimal | null
    otMultiplierSleepover: Decimal | null
  }

  export type PayrollpolicyMinAggregateOutputType = {
    id: number | null
    name: string | null
    isDefault: boolean | null
    otMultiplierWeekday1: Decimal | null
    otMultiplierWeekday2: Decimal | null
    otMultiplierSunday: Decimal | null
    otMultiplierHoliday: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    otMultiplierSleepover: Decimal | null
  }

  export type PayrollpolicyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isDefault: boolean | null
    otMultiplierWeekday1: Decimal | null
    otMultiplierWeekday2: Decimal | null
    otMultiplierSunday: Decimal | null
    otMultiplierHoliday: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    otMultiplierSleepover: Decimal | null
  }

  export type PayrollpolicyCountAggregateOutputType = {
    id: number
    name: number
    isDefault: number
    otMultiplierWeekday1: number
    otMultiplierWeekday2: number
    otMultiplierSunday: number
    otMultiplierHoliday: number
    createdAt: number
    updatedAt: number
    otMultiplierSleepover: number
    _all: number
  }


  export type PayrollpolicyAvgAggregateInputType = {
    id?: true
    otMultiplierWeekday1?: true
    otMultiplierWeekday2?: true
    otMultiplierSunday?: true
    otMultiplierHoliday?: true
    otMultiplierSleepover?: true
  }

  export type PayrollpolicySumAggregateInputType = {
    id?: true
    otMultiplierWeekday1?: true
    otMultiplierWeekday2?: true
    otMultiplierSunday?: true
    otMultiplierHoliday?: true
    otMultiplierSleepover?: true
  }

  export type PayrollpolicyMinAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    otMultiplierWeekday1?: true
    otMultiplierWeekday2?: true
    otMultiplierSunday?: true
    otMultiplierHoliday?: true
    createdAt?: true
    updatedAt?: true
    otMultiplierSleepover?: true
  }

  export type PayrollpolicyMaxAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    otMultiplierWeekday1?: true
    otMultiplierWeekday2?: true
    otMultiplierSunday?: true
    otMultiplierHoliday?: true
    createdAt?: true
    updatedAt?: true
    otMultiplierSleepover?: true
  }

  export type PayrollpolicyCountAggregateInputType = {
    id?: true
    name?: true
    isDefault?: true
    otMultiplierWeekday1?: true
    otMultiplierWeekday2?: true
    otMultiplierSunday?: true
    otMultiplierHoliday?: true
    createdAt?: true
    updatedAt?: true
    otMultiplierSleepover?: true
    _all?: true
  }

  export type PayrollpolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payrollpolicy to aggregate.
     */
    where?: payrollpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payrollpolicies to fetch.
     */
    orderBy?: payrollpolicyOrderByWithRelationInput | payrollpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payrollpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payrollpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payrollpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payrollpolicies
    **/
    _count?: true | PayrollpolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollpolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollpolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollpolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollpolicyMaxAggregateInputType
  }

  export type GetPayrollpolicyAggregateType<T extends PayrollpolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollpolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollpolicy[P]>
      : GetScalarType<T[P], AggregatePayrollpolicy[P]>
  }




  export type payrollpolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payrollpolicyWhereInput
    orderBy?: payrollpolicyOrderByWithAggregationInput | payrollpolicyOrderByWithAggregationInput[]
    by: PayrollpolicyScalarFieldEnum[] | PayrollpolicyScalarFieldEnum
    having?: payrollpolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollpolicyCountAggregateInputType | true
    _avg?: PayrollpolicyAvgAggregateInputType
    _sum?: PayrollpolicySumAggregateInputType
    _min?: PayrollpolicyMinAggregateInputType
    _max?: PayrollpolicyMaxAggregateInputType
  }

  export type PayrollpolicyGroupByOutputType = {
    id: number
    name: string
    isDefault: boolean
    otMultiplierWeekday1: Decimal
    otMultiplierWeekday2: Decimal
    otMultiplierSunday: Decimal
    otMultiplierHoliday: Decimal
    createdAt: Date
    updatedAt: Date
    otMultiplierSleepover: Decimal
    _count: PayrollpolicyCountAggregateOutputType | null
    _avg: PayrollpolicyAvgAggregateOutputType | null
    _sum: PayrollpolicySumAggregateOutputType | null
    _min: PayrollpolicyMinAggregateOutputType | null
    _max: PayrollpolicyMaxAggregateOutputType | null
  }

  type GetPayrollpolicyGroupByPayload<T extends payrollpolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollpolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollpolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollpolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollpolicyGroupByOutputType[P]>
        }
      >
    >


  export type payrollpolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isDefault?: boolean
    otMultiplierWeekday1?: boolean
    otMultiplierWeekday2?: boolean
    otMultiplierSunday?: boolean
    otMultiplierHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otMultiplierSleepover?: boolean
    department?: boolean | payrollpolicy$departmentArgs<ExtArgs>
    _count?: boolean | PayrollpolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollpolicy"]>



  export type payrollpolicySelectScalar = {
    id?: boolean
    name?: boolean
    isDefault?: boolean
    otMultiplierWeekday1?: boolean
    otMultiplierWeekday2?: boolean
    otMultiplierSunday?: boolean
    otMultiplierHoliday?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    otMultiplierSleepover?: boolean
  }

  export type payrollpolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isDefault" | "otMultiplierWeekday1" | "otMultiplierWeekday2" | "otMultiplierSunday" | "otMultiplierHoliday" | "createdAt" | "updatedAt" | "otMultiplierSleepover", ExtArgs["result"]["payrollpolicy"]>
  export type payrollpolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | payrollpolicy$departmentArgs<ExtArgs>
    _count?: boolean | PayrollpolicyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $payrollpolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payrollpolicy"
    objects: {
      department: Prisma.$departmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isDefault: boolean
      otMultiplierWeekday1: Prisma.Decimal
      otMultiplierWeekday2: Prisma.Decimal
      otMultiplierSunday: Prisma.Decimal
      otMultiplierHoliday: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      otMultiplierSleepover: Prisma.Decimal
    }, ExtArgs["result"]["payrollpolicy"]>
    composites: {}
  }

  type payrollpolicyGetPayload<S extends boolean | null | undefined | payrollpolicyDefaultArgs> = $Result.GetResult<Prisma.$payrollpolicyPayload, S>

  type payrollpolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payrollpolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollpolicyCountAggregateInputType | true
    }

  export interface payrollpolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payrollpolicy'], meta: { name: 'payrollpolicy' } }
    /**
     * Find zero or one Payrollpolicy that matches the filter.
     * @param {payrollpolicyFindUniqueArgs} args - Arguments to find a Payrollpolicy
     * @example
     * // Get one Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payrollpolicyFindUniqueArgs>(args: SelectSubset<T, payrollpolicyFindUniqueArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payrollpolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payrollpolicyFindUniqueOrThrowArgs} args - Arguments to find a Payrollpolicy
     * @example
     * // Get one Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payrollpolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, payrollpolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payrollpolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyFindFirstArgs} args - Arguments to find a Payrollpolicy
     * @example
     * // Get one Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payrollpolicyFindFirstArgs>(args?: SelectSubset<T, payrollpolicyFindFirstArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payrollpolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyFindFirstOrThrowArgs} args - Arguments to find a Payrollpolicy
     * @example
     * // Get one Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payrollpolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, payrollpolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrollpolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrollpolicies
     * const payrollpolicies = await prisma.payrollpolicy.findMany()
     * 
     * // Get first 10 Payrollpolicies
     * const payrollpolicies = await prisma.payrollpolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollpolicyWithIdOnly = await prisma.payrollpolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payrollpolicyFindManyArgs>(args?: SelectSubset<T, payrollpolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payrollpolicy.
     * @param {payrollpolicyCreateArgs} args - Arguments to create a Payrollpolicy.
     * @example
     * // Create one Payrollpolicy
     * const Payrollpolicy = await prisma.payrollpolicy.create({
     *   data: {
     *     // ... data to create a Payrollpolicy
     *   }
     * })
     * 
     */
    create<T extends payrollpolicyCreateArgs>(args: SelectSubset<T, payrollpolicyCreateArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrollpolicies.
     * @param {payrollpolicyCreateManyArgs} args - Arguments to create many Payrollpolicies.
     * @example
     * // Create many Payrollpolicies
     * const payrollpolicy = await prisma.payrollpolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payrollpolicyCreateManyArgs>(args?: SelectSubset<T, payrollpolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payrollpolicy.
     * @param {payrollpolicyDeleteArgs} args - Arguments to delete one Payrollpolicy.
     * @example
     * // Delete one Payrollpolicy
     * const Payrollpolicy = await prisma.payrollpolicy.delete({
     *   where: {
     *     // ... filter to delete one Payrollpolicy
     *   }
     * })
     * 
     */
    delete<T extends payrollpolicyDeleteArgs>(args: SelectSubset<T, payrollpolicyDeleteArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payrollpolicy.
     * @param {payrollpolicyUpdateArgs} args - Arguments to update one Payrollpolicy.
     * @example
     * // Update one Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payrollpolicyUpdateArgs>(args: SelectSubset<T, payrollpolicyUpdateArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrollpolicies.
     * @param {payrollpolicyDeleteManyArgs} args - Arguments to filter Payrollpolicies to delete.
     * @example
     * // Delete a few Payrollpolicies
     * const { count } = await prisma.payrollpolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payrollpolicyDeleteManyArgs>(args?: SelectSubset<T, payrollpolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrollpolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrollpolicies
     * const payrollpolicy = await prisma.payrollpolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payrollpolicyUpdateManyArgs>(args: SelectSubset<T, payrollpolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payrollpolicy.
     * @param {payrollpolicyUpsertArgs} args - Arguments to update or create a Payrollpolicy.
     * @example
     * // Update or create a Payrollpolicy
     * const payrollpolicy = await prisma.payrollpolicy.upsert({
     *   create: {
     *     // ... data to create a Payrollpolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payrollpolicy we want to update
     *   }
     * })
     */
    upsert<T extends payrollpolicyUpsertArgs>(args: SelectSubset<T, payrollpolicyUpsertArgs<ExtArgs>>): Prisma__payrollpolicyClient<$Result.GetResult<Prisma.$payrollpolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrollpolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyCountArgs} args - Arguments to filter Payrollpolicies to count.
     * @example
     * // Count the number of Payrollpolicies
     * const count = await prisma.payrollpolicy.count({
     *   where: {
     *     // ... the filter for the Payrollpolicies we want to count
     *   }
     * })
    **/
    count<T extends payrollpolicyCountArgs>(
      args?: Subset<T, payrollpolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollpolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payrollpolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollpolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollpolicyAggregateArgs>(args: Subset<T, PayrollpolicyAggregateArgs>): Prisma.PrismaPromise<GetPayrollpolicyAggregateType<T>>

    /**
     * Group by Payrollpolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payrollpolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payrollpolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payrollpolicyGroupByArgs['orderBy'] }
        : { orderBy?: payrollpolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payrollpolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollpolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payrollpolicy model
   */
  readonly fields: payrollpolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payrollpolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payrollpolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends payrollpolicy$departmentArgs<ExtArgs> = {}>(args?: Subset<T, payrollpolicy$departmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$departmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payrollpolicy model
   */
  interface payrollpolicyFieldRefs {
    readonly id: FieldRef<"payrollpolicy", 'Int'>
    readonly name: FieldRef<"payrollpolicy", 'String'>
    readonly isDefault: FieldRef<"payrollpolicy", 'Boolean'>
    readonly otMultiplierWeekday1: FieldRef<"payrollpolicy", 'Decimal'>
    readonly otMultiplierWeekday2: FieldRef<"payrollpolicy", 'Decimal'>
    readonly otMultiplierSunday: FieldRef<"payrollpolicy", 'Decimal'>
    readonly otMultiplierHoliday: FieldRef<"payrollpolicy", 'Decimal'>
    readonly createdAt: FieldRef<"payrollpolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"payrollpolicy", 'DateTime'>
    readonly otMultiplierSleepover: FieldRef<"payrollpolicy", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * payrollpolicy findUnique
   */
  export type payrollpolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter, which payrollpolicy to fetch.
     */
    where: payrollpolicyWhereUniqueInput
  }

  /**
   * payrollpolicy findUniqueOrThrow
   */
  export type payrollpolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter, which payrollpolicy to fetch.
     */
    where: payrollpolicyWhereUniqueInput
  }

  /**
   * payrollpolicy findFirst
   */
  export type payrollpolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter, which payrollpolicy to fetch.
     */
    where?: payrollpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payrollpolicies to fetch.
     */
    orderBy?: payrollpolicyOrderByWithRelationInput | payrollpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payrollpolicies.
     */
    cursor?: payrollpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payrollpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payrollpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payrollpolicies.
     */
    distinct?: PayrollpolicyScalarFieldEnum | PayrollpolicyScalarFieldEnum[]
  }

  /**
   * payrollpolicy findFirstOrThrow
   */
  export type payrollpolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter, which payrollpolicy to fetch.
     */
    where?: payrollpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payrollpolicies to fetch.
     */
    orderBy?: payrollpolicyOrderByWithRelationInput | payrollpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payrollpolicies.
     */
    cursor?: payrollpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payrollpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payrollpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payrollpolicies.
     */
    distinct?: PayrollpolicyScalarFieldEnum | PayrollpolicyScalarFieldEnum[]
  }

  /**
   * payrollpolicy findMany
   */
  export type payrollpolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter, which payrollpolicies to fetch.
     */
    where?: payrollpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payrollpolicies to fetch.
     */
    orderBy?: payrollpolicyOrderByWithRelationInput | payrollpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payrollpolicies.
     */
    cursor?: payrollpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payrollpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payrollpolicies.
     */
    skip?: number
    distinct?: PayrollpolicyScalarFieldEnum | PayrollpolicyScalarFieldEnum[]
  }

  /**
   * payrollpolicy create
   */
  export type payrollpolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a payrollpolicy.
     */
    data: XOR<payrollpolicyCreateInput, payrollpolicyUncheckedCreateInput>
  }

  /**
   * payrollpolicy createMany
   */
  export type payrollpolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payrollpolicies.
     */
    data: payrollpolicyCreateManyInput | payrollpolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payrollpolicy update
   */
  export type payrollpolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a payrollpolicy.
     */
    data: XOR<payrollpolicyUpdateInput, payrollpolicyUncheckedUpdateInput>
    /**
     * Choose, which payrollpolicy to update.
     */
    where: payrollpolicyWhereUniqueInput
  }

  /**
   * payrollpolicy updateMany
   */
  export type payrollpolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payrollpolicies.
     */
    data: XOR<payrollpolicyUpdateManyMutationInput, payrollpolicyUncheckedUpdateManyInput>
    /**
     * Filter which payrollpolicies to update
     */
    where?: payrollpolicyWhereInput
    /**
     * Limit how many payrollpolicies to update.
     */
    limit?: number
  }

  /**
   * payrollpolicy upsert
   */
  export type payrollpolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the payrollpolicy to update in case it exists.
     */
    where: payrollpolicyWhereUniqueInput
    /**
     * In case the payrollpolicy found by the `where` argument doesn't exist, create a new payrollpolicy with this data.
     */
    create: XOR<payrollpolicyCreateInput, payrollpolicyUncheckedCreateInput>
    /**
     * In case the payrollpolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payrollpolicyUpdateInput, payrollpolicyUncheckedUpdateInput>
  }

  /**
   * payrollpolicy delete
   */
  export type payrollpolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
    /**
     * Filter which payrollpolicy to delete.
     */
    where: payrollpolicyWhereUniqueInput
  }

  /**
   * payrollpolicy deleteMany
   */
  export type payrollpolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payrollpolicies to delete
     */
    where?: payrollpolicyWhereInput
    /**
     * Limit how many payrollpolicies to delete.
     */
    limit?: number
  }

  /**
   * payrollpolicy.department
   */
  export type payrollpolicy$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the department
     */
    omit?: departmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: departmentInclude<ExtArgs> | null
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    cursor?: departmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * payrollpolicy without action
   */
  export type payrollpolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payrollpolicy
     */
    select?: payrollpolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the payrollpolicy
     */
    omit?: payrollpolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payrollpolicyInclude<ExtArgs> | null
  }


  /**
   * Model performancereview
   */

  export type AggregatePerformancereview = {
    _count: PerformancereviewCountAggregateOutputType | null
    _avg: PerformancereviewAvgAggregateOutputType | null
    _sum: PerformancereviewSumAggregateOutputType | null
    _min: PerformancereviewMinAggregateOutputType | null
    _max: PerformancereviewMaxAggregateOutputType | null
  }

  export type PerformancereviewAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    score: number | null
  }

  export type PerformancereviewSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    score: number | null
  }

  export type PerformancereviewMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformancereviewMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformancereviewCountAggregateOutputType = {
    id: number
    employeeId: number
    reviewDate: number
    reviewerName: number
    score: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformancereviewAvgAggregateInputType = {
    id?: true
    employeeId?: true
    score?: true
  }

  export type PerformancereviewSumAggregateInputType = {
    id?: true
    employeeId?: true
    score?: true
  }

  export type PerformancereviewMinAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformancereviewMaxAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformancereviewCountAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformancereviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which performancereview to aggregate.
     */
    where?: performancereviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performancereviews to fetch.
     */
    orderBy?: performancereviewOrderByWithRelationInput | performancereviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: performancereviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performancereviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performancereviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned performancereviews
    **/
    _count?: true | PerformancereviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformancereviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformancereviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformancereviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformancereviewMaxAggregateInputType
  }

  export type GetPerformancereviewAggregateType<T extends PerformancereviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformancereview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformancereview[P]>
      : GetScalarType<T[P], AggregatePerformancereview[P]>
  }




  export type performancereviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performancereviewWhereInput
    orderBy?: performancereviewOrderByWithAggregationInput | performancereviewOrderByWithAggregationInput[]
    by: PerformancereviewScalarFieldEnum[] | PerformancereviewScalarFieldEnum
    having?: performancereviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformancereviewCountAggregateInputType | true
    _avg?: PerformancereviewAvgAggregateInputType
    _sum?: PerformancereviewSumAggregateInputType
    _min?: PerformancereviewMinAggregateInputType
    _max?: PerformancereviewMaxAggregateInputType
  }

  export type PerformancereviewGroupByOutputType = {
    id: number
    employeeId: number
    reviewDate: Date
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: PerformancereviewCountAggregateOutputType | null
    _avg: PerformancereviewAvgAggregateOutputType | null
    _sum: PerformancereviewSumAggregateOutputType | null
    _min: PerformancereviewMinAggregateOutputType | null
    _max: PerformancereviewMaxAggregateOutputType | null
  }

  type GetPerformancereviewGroupByPayload<T extends performancereviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformancereviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformancereviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformancereviewGroupByOutputType[P]>
            : GetScalarType<T[P], PerformancereviewGroupByOutputType[P]>
        }
      >
    >


  export type performancereviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewerName?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performancereview"]>



  export type performancereviewSelectScalar = {
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewerName?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type performancereviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "reviewDate" | "reviewerName" | "score" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["performancereview"]>
  export type performancereviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $performancereviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "performancereview"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      reviewDate: Date
      reviewerName: string | null
      score: number | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performancereview"]>
    composites: {}
  }

  type performancereviewGetPayload<S extends boolean | null | undefined | performancereviewDefaultArgs> = $Result.GetResult<Prisma.$performancereviewPayload, S>

  type performancereviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<performancereviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformancereviewCountAggregateInputType | true
    }

  export interface performancereviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['performancereview'], meta: { name: 'performancereview' } }
    /**
     * Find zero or one Performancereview that matches the filter.
     * @param {performancereviewFindUniqueArgs} args - Arguments to find a Performancereview
     * @example
     * // Get one Performancereview
     * const performancereview = await prisma.performancereview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends performancereviewFindUniqueArgs>(args: SelectSubset<T, performancereviewFindUniqueArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Performancereview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {performancereviewFindUniqueOrThrowArgs} args - Arguments to find a Performancereview
     * @example
     * // Get one Performancereview
     * const performancereview = await prisma.performancereview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends performancereviewFindUniqueOrThrowArgs>(args: SelectSubset<T, performancereviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performancereview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewFindFirstArgs} args - Arguments to find a Performancereview
     * @example
     * // Get one Performancereview
     * const performancereview = await prisma.performancereview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends performancereviewFindFirstArgs>(args?: SelectSubset<T, performancereviewFindFirstArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performancereview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewFindFirstOrThrowArgs} args - Arguments to find a Performancereview
     * @example
     * // Get one Performancereview
     * const performancereview = await prisma.performancereview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends performancereviewFindFirstOrThrowArgs>(args?: SelectSubset<T, performancereviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Performancereviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Performancereviews
     * const performancereviews = await prisma.performancereview.findMany()
     * 
     * // Get first 10 Performancereviews
     * const performancereviews = await prisma.performancereview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performancereviewWithIdOnly = await prisma.performancereview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends performancereviewFindManyArgs>(args?: SelectSubset<T, performancereviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Performancereview.
     * @param {performancereviewCreateArgs} args - Arguments to create a Performancereview.
     * @example
     * // Create one Performancereview
     * const Performancereview = await prisma.performancereview.create({
     *   data: {
     *     // ... data to create a Performancereview
     *   }
     * })
     * 
     */
    create<T extends performancereviewCreateArgs>(args: SelectSubset<T, performancereviewCreateArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Performancereviews.
     * @param {performancereviewCreateManyArgs} args - Arguments to create many Performancereviews.
     * @example
     * // Create many Performancereviews
     * const performancereview = await prisma.performancereview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends performancereviewCreateManyArgs>(args?: SelectSubset<T, performancereviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Performancereview.
     * @param {performancereviewDeleteArgs} args - Arguments to delete one Performancereview.
     * @example
     * // Delete one Performancereview
     * const Performancereview = await prisma.performancereview.delete({
     *   where: {
     *     // ... filter to delete one Performancereview
     *   }
     * })
     * 
     */
    delete<T extends performancereviewDeleteArgs>(args: SelectSubset<T, performancereviewDeleteArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Performancereview.
     * @param {performancereviewUpdateArgs} args - Arguments to update one Performancereview.
     * @example
     * // Update one Performancereview
     * const performancereview = await prisma.performancereview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends performancereviewUpdateArgs>(args: SelectSubset<T, performancereviewUpdateArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Performancereviews.
     * @param {performancereviewDeleteManyArgs} args - Arguments to filter Performancereviews to delete.
     * @example
     * // Delete a few Performancereviews
     * const { count } = await prisma.performancereview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends performancereviewDeleteManyArgs>(args?: SelectSubset<T, performancereviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Performancereviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Performancereviews
     * const performancereview = await prisma.performancereview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends performancereviewUpdateManyArgs>(args: SelectSubset<T, performancereviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Performancereview.
     * @param {performancereviewUpsertArgs} args - Arguments to update or create a Performancereview.
     * @example
     * // Update or create a Performancereview
     * const performancereview = await prisma.performancereview.upsert({
     *   create: {
     *     // ... data to create a Performancereview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Performancereview we want to update
     *   }
     * })
     */
    upsert<T extends performancereviewUpsertArgs>(args: SelectSubset<T, performancereviewUpsertArgs<ExtArgs>>): Prisma__performancereviewClient<$Result.GetResult<Prisma.$performancereviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Performancereviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewCountArgs} args - Arguments to filter Performancereviews to count.
     * @example
     * // Count the number of Performancereviews
     * const count = await prisma.performancereview.count({
     *   where: {
     *     // ... the filter for the Performancereviews we want to count
     *   }
     * })
    **/
    count<T extends performancereviewCountArgs>(
      args?: Subset<T, performancereviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformancereviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Performancereview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancereviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformancereviewAggregateArgs>(args: Subset<T, PerformancereviewAggregateArgs>): Prisma.PrismaPromise<GetPerformancereviewAggregateType<T>>

    /**
     * Group by Performancereview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performancereviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends performancereviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: performancereviewGroupByArgs['orderBy'] }
        : { orderBy?: performancereviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, performancereviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformancereviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the performancereview model
   */
  readonly fields: performancereviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for performancereview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__performancereviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the performancereview model
   */
  interface performancereviewFieldRefs {
    readonly id: FieldRef<"performancereview", 'Int'>
    readonly employeeId: FieldRef<"performancereview", 'Int'>
    readonly reviewDate: FieldRef<"performancereview", 'DateTime'>
    readonly reviewerName: FieldRef<"performancereview", 'String'>
    readonly score: FieldRef<"performancereview", 'Int'>
    readonly comments: FieldRef<"performancereview", 'String'>
    readonly createdAt: FieldRef<"performancereview", 'DateTime'>
    readonly updatedAt: FieldRef<"performancereview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * performancereview findUnique
   */
  export type performancereviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter, which performancereview to fetch.
     */
    where: performancereviewWhereUniqueInput
  }

  /**
   * performancereview findUniqueOrThrow
   */
  export type performancereviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter, which performancereview to fetch.
     */
    where: performancereviewWhereUniqueInput
  }

  /**
   * performancereview findFirst
   */
  export type performancereviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter, which performancereview to fetch.
     */
    where?: performancereviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performancereviews to fetch.
     */
    orderBy?: performancereviewOrderByWithRelationInput | performancereviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for performancereviews.
     */
    cursor?: performancereviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performancereviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performancereviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of performancereviews.
     */
    distinct?: PerformancereviewScalarFieldEnum | PerformancereviewScalarFieldEnum[]
  }

  /**
   * performancereview findFirstOrThrow
   */
  export type performancereviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter, which performancereview to fetch.
     */
    where?: performancereviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performancereviews to fetch.
     */
    orderBy?: performancereviewOrderByWithRelationInput | performancereviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for performancereviews.
     */
    cursor?: performancereviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performancereviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performancereviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of performancereviews.
     */
    distinct?: PerformancereviewScalarFieldEnum | PerformancereviewScalarFieldEnum[]
  }

  /**
   * performancereview findMany
   */
  export type performancereviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter, which performancereviews to fetch.
     */
    where?: performancereviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performancereviews to fetch.
     */
    orderBy?: performancereviewOrderByWithRelationInput | performancereviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing performancereviews.
     */
    cursor?: performancereviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performancereviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performancereviews.
     */
    skip?: number
    distinct?: PerformancereviewScalarFieldEnum | PerformancereviewScalarFieldEnum[]
  }

  /**
   * performancereview create
   */
  export type performancereviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * The data needed to create a performancereview.
     */
    data: XOR<performancereviewCreateInput, performancereviewUncheckedCreateInput>
  }

  /**
   * performancereview createMany
   */
  export type performancereviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many performancereviews.
     */
    data: performancereviewCreateManyInput | performancereviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * performancereview update
   */
  export type performancereviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * The data needed to update a performancereview.
     */
    data: XOR<performancereviewUpdateInput, performancereviewUncheckedUpdateInput>
    /**
     * Choose, which performancereview to update.
     */
    where: performancereviewWhereUniqueInput
  }

  /**
   * performancereview updateMany
   */
  export type performancereviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update performancereviews.
     */
    data: XOR<performancereviewUpdateManyMutationInput, performancereviewUncheckedUpdateManyInput>
    /**
     * Filter which performancereviews to update
     */
    where?: performancereviewWhereInput
    /**
     * Limit how many performancereviews to update.
     */
    limit?: number
  }

  /**
   * performancereview upsert
   */
  export type performancereviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * The filter to search for the performancereview to update in case it exists.
     */
    where: performancereviewWhereUniqueInput
    /**
     * In case the performancereview found by the `where` argument doesn't exist, create a new performancereview with this data.
     */
    create: XOR<performancereviewCreateInput, performancereviewUncheckedCreateInput>
    /**
     * In case the performancereview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<performancereviewUpdateInput, performancereviewUncheckedUpdateInput>
  }

  /**
   * performancereview delete
   */
  export type performancereviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
    /**
     * Filter which performancereview to delete.
     */
    where: performancereviewWhereUniqueInput
  }

  /**
   * performancereview deleteMany
   */
  export type performancereviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which performancereviews to delete
     */
    where?: performancereviewWhereInput
    /**
     * Limit how many performancereviews to delete.
     */
    limit?: number
  }

  /**
   * performancereview without action
   */
  export type performancereviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performancereview
     */
    select?: performancereviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performancereview
     */
    omit?: performancereviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performancereviewInclude<ExtArgs> | null
  }


  /**
   * Model position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    id: number | null
  }

  export type PositionSumAggregateOutputType = {
    id: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    id?: true
  }

  export type PositionSumAggregateInputType = {
    id?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which position to aggregate.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type positionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: positionWhereInput
    orderBy?: positionOrderByWithAggregationInput | positionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: positionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends positionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type positionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | position$employeeArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>



  export type positionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type positionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type positionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | position$employeeArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $positionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "position"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type positionGetPayload<S extends boolean | null | undefined | positionDefaultArgs> = $Result.GetResult<Prisma.$positionPayload, S>

  type positionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<positionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface positionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['position'], meta: { name: 'position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {positionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends positionFindUniqueArgs>(args: SelectSubset<T, positionFindUniqueArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {positionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends positionFindUniqueOrThrowArgs>(args: SelectSubset<T, positionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends positionFindFirstArgs>(args?: SelectSubset<T, positionFindFirstArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends positionFindFirstOrThrowArgs>(args?: SelectSubset<T, positionFindFirstOrThrowArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends positionFindManyArgs>(args?: SelectSubset<T, positionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {positionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends positionCreateArgs>(args: SelectSubset<T, positionCreateArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {positionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends positionCreateManyArgs>(args?: SelectSubset<T, positionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Position.
     * @param {positionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends positionDeleteArgs>(args: SelectSubset<T, positionDeleteArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {positionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends positionUpdateArgs>(args: SelectSubset<T, positionUpdateArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {positionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends positionDeleteManyArgs>(args?: SelectSubset<T, positionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends positionUpdateManyArgs>(args: SelectSubset<T, positionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {positionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends positionUpsertArgs>(args: SelectSubset<T, positionUpsertArgs<ExtArgs>>): Prisma__positionClient<$Result.GetResult<Prisma.$positionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends positionCountArgs>(
      args?: Subset<T, positionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {positionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends positionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: positionGroupByArgs['orderBy'] }
        : { orderBy?: positionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, positionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the position model
   */
  readonly fields: positionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__positionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends position$employeeArgs<ExtArgs> = {}>(args?: Subset<T, position$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the position model
   */
  interface positionFieldRefs {
    readonly id: FieldRef<"position", 'Int'>
    readonly name: FieldRef<"position", 'String'>
    readonly description: FieldRef<"position", 'String'>
    readonly createdAt: FieldRef<"position", 'DateTime'>
    readonly updatedAt: FieldRef<"position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * position findUnique
   */
  export type positionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position findUniqueOrThrow
   */
  export type positionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position findFirst
   */
  export type positionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position findFirstOrThrow
   */
  export type positionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which position to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position findMany
   */
  export type positionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter, which positions to fetch.
     */
    where?: positionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of positions to fetch.
     */
    orderBy?: positionOrderByWithRelationInput | positionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing positions.
     */
    cursor?: positionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * position create
   */
  export type positionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The data needed to create a position.
     */
    data: XOR<positionCreateInput, positionUncheckedCreateInput>
  }

  /**
   * position createMany
   */
  export type positionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many positions.
     */
    data: positionCreateManyInput | positionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * position update
   */
  export type positionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The data needed to update a position.
     */
    data: XOR<positionUpdateInput, positionUncheckedUpdateInput>
    /**
     * Choose, which position to update.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position updateMany
   */
  export type positionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update positions.
     */
    data: XOR<positionUpdateManyMutationInput, positionUncheckedUpdateManyInput>
    /**
     * Filter which positions to update
     */
    where?: positionWhereInput
    /**
     * Limit how many positions to update.
     */
    limit?: number
  }

  /**
   * position upsert
   */
  export type positionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * The filter to search for the position to update in case it exists.
     */
    where: positionWhereUniqueInput
    /**
     * In case the position found by the `where` argument doesn't exist, create a new position with this data.
     */
    create: XOR<positionCreateInput, positionUncheckedCreateInput>
    /**
     * In case the position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<positionUpdateInput, positionUncheckedUpdateInput>
  }

  /**
   * position delete
   */
  export type positionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
    /**
     * Filter which position to delete.
     */
    where: positionWhereUniqueInput
  }

  /**
   * position deleteMany
   */
  export type positionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which positions to delete
     */
    where?: positionWhereInput
    /**
     * Limit how many positions to delete.
     */
    limit?: number
  }

  /**
   * position.employee
   */
  export type position$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    cursor?: employeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * position without action
   */
  export type positionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the position
     */
    select?: positionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the position
     */
    omit?: positionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: positionInclude<ExtArgs> | null
  }


  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roleWhereInput
    orderBy?: roleOrderByWithAggregationInput | roleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type roleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type roleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userrole?: boolean | role$userroleArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role"
    objects: {
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> = $Result.GetResult<Prisma.$rolePayload, S>

  type roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role'], meta: { name: 'role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roleFindManyArgs>(args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends roleCreateArgs>(args: SelectSubset<T, roleCreateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roleCreateManyArgs>(args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends roleDeleteArgs>(args: SelectSubset<T, roleDeleteArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roleUpdateArgs>(args: SelectSubset<T, roleUpdateArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roleDeleteManyArgs>(args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roleUpdateManyArgs>(args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(args: SelectSubset<T, roleUpsertArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs['orderBy'] }
        : { orderBy?: roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role model
   */
  readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userrole<T extends role$userroleArgs<ExtArgs> = {}>(args?: Subset<T, role$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly id: FieldRef<"role", 'Int'>
    readonly name: FieldRef<"role", 'String'>
    readonly description: FieldRef<"role", 'String'>
    readonly createdAt: FieldRef<"role", 'DateTime'>
    readonly updatedAt: FieldRef<"role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role findMany
   */
  export type roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * role create
   */
  export type roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>
  }

  /**
   * role createMany
   */
  export type roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role update
   */
  export type roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * role upsert
   */
  export type roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>
  }

  /**
   * role delete
   */
  export type roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput
  }

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * role.userrole
   */
  export type role$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * role without action
   */
  export type roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null
  }


  /**
   * Model salary
   */

  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    baseSalary: Decimal | null
    deductions: Decimal | null
  }

  export type SalarySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    baseSalary: Decimal | null
    deductions: Decimal | null
  }

  export type SalaryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salaryMonth: Date | null
    amount: Decimal | null
    status: $Enums.salary_status | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    baseSalary: Decimal | null
    deductions: Decimal | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salaryMonth: Date | null
    amount: Decimal | null
    status: $Enums.salary_status | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    baseSalary: Decimal | null
    deductions: Decimal | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    employeeId: number
    salaryMonth: number
    amount: number
    status: number
    overtimeHours: number
    overtimePay: number
    paidAt: number
    createdAt: number
    updatedAt: number
    baseSalary: number
    deductions: number
    _all: number
  }


  export type SalaryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    overtimeHours?: true
    overtimePay?: true
    baseSalary?: true
    deductions?: true
  }

  export type SalarySumAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    overtimeHours?: true
    overtimePay?: true
    baseSalary?: true
    deductions?: true
  }

  export type SalaryMinAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    baseSalary?: true
    deductions?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    baseSalary?: true
    deductions?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    baseSalary?: true
    deductions?: true
    _all?: true
  }

  export type SalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which salary to aggregate.
     */
    where?: salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salaries to fetch.
     */
    orderBy?: salaryOrderByWithRelationInput | salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type salaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: salaryWhereInput
    orderBy?: salaryOrderByWithAggregationInput | salaryOrderByWithAggregationInput[]
    by: SalaryScalarFieldEnum[] | SalaryScalarFieldEnum
    having?: salaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _avg?: SalaryAvgAggregateInputType
    _sum?: SalarySumAggregateInputType
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }

  export type SalaryGroupByOutputType = {
    id: number
    employeeId: number
    salaryMonth: Date
    amount: Decimal
    status: $Enums.salary_status
    overtimeHours: Decimal
    overtimePay: Decimal
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    baseSalary: Decimal
    deductions: Decimal
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends salaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type salarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    salaryMonth?: boolean
    amount?: boolean
    status?: boolean
    overtimeHours?: boolean
    overtimePay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseSalary?: boolean
    deductions?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>



  export type salarySelectScalar = {
    id?: boolean
    employeeId?: boolean
    salaryMonth?: boolean
    amount?: boolean
    status?: boolean
    overtimeHours?: boolean
    overtimePay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    baseSalary?: boolean
    deductions?: boolean
  }

  export type salaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "salaryMonth" | "amount" | "status" | "overtimeHours" | "overtimePay" | "paidAt" | "createdAt" | "updatedAt" | "baseSalary" | "deductions", ExtArgs["result"]["salary"]>
  export type salaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $salaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "salary"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      salaryMonth: Date
      amount: Prisma.Decimal
      status: $Enums.salary_status
      overtimeHours: Prisma.Decimal
      overtimePay: Prisma.Decimal
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
      baseSalary: Prisma.Decimal
      deductions: Prisma.Decimal
    }, ExtArgs["result"]["salary"]>
    composites: {}
  }

  type salaryGetPayload<S extends boolean | null | undefined | salaryDefaultArgs> = $Result.GetResult<Prisma.$salaryPayload, S>

  type salaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<salaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryCountAggregateInputType | true
    }

  export interface salaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['salary'], meta: { name: 'salary' } }
    /**
     * Find zero or one Salary that matches the filter.
     * @param {salaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends salaryFindUniqueArgs>(args: SelectSubset<T, salaryFindUniqueArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {salaryFindUniqueOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends salaryFindUniqueOrThrowArgs>(args: SelectSubset<T, salaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends salaryFindFirstArgs>(args?: SelectSubset<T, salaryFindFirstArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryFindFirstOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends salaryFindFirstOrThrowArgs>(args?: SelectSubset<T, salaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends salaryFindManyArgs>(args?: SelectSubset<T, salaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salary.
     * @param {salaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
     */
    create<T extends salaryCreateArgs>(args: SelectSubset<T, salaryCreateArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salaries.
     * @param {salaryCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends salaryCreateManyArgs>(args?: SelectSubset<T, salaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Salary.
     * @param {salaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
     */
    delete<T extends salaryDeleteArgs>(args: SelectSubset<T, salaryDeleteArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salary.
     * @param {salaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends salaryUpdateArgs>(args: SelectSubset<T, salaryUpdateArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salaries.
     * @param {salaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends salaryDeleteManyArgs>(args?: SelectSubset<T, salaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends salaryUpdateManyArgs>(args: SelectSubset<T, salaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salary.
     * @param {salaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
     */
    upsert<T extends salaryUpsertArgs>(args: SelectSubset<T, salaryUpsertArgs<ExtArgs>>): Prisma__salaryClient<$Result.GetResult<Prisma.$salaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends salaryCountArgs>(
      args?: Subset<T, salaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): Prisma.PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {salaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends salaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: salaryGroupByArgs['orderBy'] }
        : { orderBy?: salaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, salaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the salary model
   */
  readonly fields: salaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__salaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the salary model
   */
  interface salaryFieldRefs {
    readonly id: FieldRef<"salary", 'Int'>
    readonly employeeId: FieldRef<"salary", 'Int'>
    readonly salaryMonth: FieldRef<"salary", 'DateTime'>
    readonly amount: FieldRef<"salary", 'Decimal'>
    readonly status: FieldRef<"salary", 'salary_status'>
    readonly overtimeHours: FieldRef<"salary", 'Decimal'>
    readonly overtimePay: FieldRef<"salary", 'Decimal'>
    readonly paidAt: FieldRef<"salary", 'DateTime'>
    readonly createdAt: FieldRef<"salary", 'DateTime'>
    readonly updatedAt: FieldRef<"salary", 'DateTime'>
    readonly baseSalary: FieldRef<"salary", 'Decimal'>
    readonly deductions: FieldRef<"salary", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * salary findUnique
   */
  export type salaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter, which salary to fetch.
     */
    where: salaryWhereUniqueInput
  }

  /**
   * salary findUniqueOrThrow
   */
  export type salaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter, which salary to fetch.
     */
    where: salaryWhereUniqueInput
  }

  /**
   * salary findFirst
   */
  export type salaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter, which salary to fetch.
     */
    where?: salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salaries to fetch.
     */
    orderBy?: salaryOrderByWithRelationInput | salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salaries.
     */
    cursor?: salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * salary findFirstOrThrow
   */
  export type salaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter, which salary to fetch.
     */
    where?: salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salaries to fetch.
     */
    orderBy?: salaryOrderByWithRelationInput | salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for salaries.
     */
    cursor?: salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * salary findMany
   */
  export type salaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter, which salaries to fetch.
     */
    where?: salaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of salaries to fetch.
     */
    orderBy?: salaryOrderByWithRelationInput | salaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing salaries.
     */
    cursor?: salaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` salaries.
     */
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * salary create
   */
  export type salaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * The data needed to create a salary.
     */
    data: XOR<salaryCreateInput, salaryUncheckedCreateInput>
  }

  /**
   * salary createMany
   */
  export type salaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many salaries.
     */
    data: salaryCreateManyInput | salaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * salary update
   */
  export type salaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * The data needed to update a salary.
     */
    data: XOR<salaryUpdateInput, salaryUncheckedUpdateInput>
    /**
     * Choose, which salary to update.
     */
    where: salaryWhereUniqueInput
  }

  /**
   * salary updateMany
   */
  export type salaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update salaries.
     */
    data: XOR<salaryUpdateManyMutationInput, salaryUncheckedUpdateManyInput>
    /**
     * Filter which salaries to update
     */
    where?: salaryWhereInput
    /**
     * Limit how many salaries to update.
     */
    limit?: number
  }

  /**
   * salary upsert
   */
  export type salaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * The filter to search for the salary to update in case it exists.
     */
    where: salaryWhereUniqueInput
    /**
     * In case the salary found by the `where` argument doesn't exist, create a new salary with this data.
     */
    create: XOR<salaryCreateInput, salaryUncheckedCreateInput>
    /**
     * In case the salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<salaryUpdateInput, salaryUncheckedUpdateInput>
  }

  /**
   * salary delete
   */
  export type salaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
    /**
     * Filter which salary to delete.
     */
    where: salaryWhereUniqueInput
  }

  /**
   * salary deleteMany
   */
  export type salaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which salaries to delete
     */
    where?: salaryWhereInput
    /**
     * Limit how many salaries to delete.
     */
    limit?: number
  }

  /**
   * salary without action
   */
  export type salaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the salary
     */
    select?: salarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the salary
     */
    omit?: salaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: salaryInclude<ExtArgs> | null
  }


  /**
   * Model sessiondefinition
   */

  export type AggregateSessiondefinition = {
    _count: SessiondefinitionCountAggregateOutputType | null
    _avg: SessiondefinitionAvgAggregateOutputType | null
    _sum: SessiondefinitionSumAggregateOutputType | null
    _min: SessiondefinitionMinAggregateOutputType | null
    _max: SessiondefinitionMaxAggregateOutputType | null
  }

  export type SessiondefinitionAvgAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
  }

  export type SessiondefinitionSumAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
  }

  export type SessiondefinitionMinAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
    expectedClockIn: Date | null
    expectedClockOut: Date | null
  }

  export type SessiondefinitionMaxAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
    expectedClockIn: Date | null
    expectedClockOut: Date | null
  }

  export type SessiondefinitionCountAggregateOutputType = {
    id: number
    sessionNumber: number
    expectedClockIn: number
    expectedClockOut: number
    _all: number
  }


  export type SessiondefinitionAvgAggregateInputType = {
    id?: true
    sessionNumber?: true
  }

  export type SessiondefinitionSumAggregateInputType = {
    id?: true
    sessionNumber?: true
  }

  export type SessiondefinitionMinAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
  }

  export type SessiondefinitionMaxAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
  }

  export type SessiondefinitionCountAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
    _all?: true
  }

  export type SessiondefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessiondefinition to aggregate.
     */
    where?: sessiondefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessiondefinitions to fetch.
     */
    orderBy?: sessiondefinitionOrderByWithRelationInput | sessiondefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessiondefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessiondefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessiondefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessiondefinitions
    **/
    _count?: true | SessiondefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessiondefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessiondefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessiondefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessiondefinitionMaxAggregateInputType
  }

  export type GetSessiondefinitionAggregateType<T extends SessiondefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessiondefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessiondefinition[P]>
      : GetScalarType<T[P], AggregateSessiondefinition[P]>
  }




  export type sessiondefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessiondefinitionWhereInput
    orderBy?: sessiondefinitionOrderByWithAggregationInput | sessiondefinitionOrderByWithAggregationInput[]
    by: SessiondefinitionScalarFieldEnum[] | SessiondefinitionScalarFieldEnum
    having?: sessiondefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessiondefinitionCountAggregateInputType | true
    _avg?: SessiondefinitionAvgAggregateInputType
    _sum?: SessiondefinitionSumAggregateInputType
    _min?: SessiondefinitionMinAggregateInputType
    _max?: SessiondefinitionMaxAggregateInputType
  }

  export type SessiondefinitionGroupByOutputType = {
    id: number
    sessionNumber: number
    expectedClockIn: Date
    expectedClockOut: Date
    _count: SessiondefinitionCountAggregateOutputType | null
    _avg: SessiondefinitionAvgAggregateOutputType | null
    _sum: SessiondefinitionSumAggregateOutputType | null
    _min: SessiondefinitionMinAggregateOutputType | null
    _max: SessiondefinitionMaxAggregateOutputType | null
  }

  type GetSessiondefinitionGroupByPayload<T extends sessiondefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessiondefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessiondefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessiondefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], SessiondefinitionGroupByOutputType[P]>
        }
      >
    >


  export type sessiondefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionNumber?: boolean
    expectedClockIn?: boolean
    expectedClockOut?: boolean
    attendancelog?: boolean | sessiondefinition$attendancelogArgs<ExtArgs>
    _count?: boolean | SessiondefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessiondefinition"]>



  export type sessiondefinitionSelectScalar = {
    id?: boolean
    sessionNumber?: boolean
    expectedClockIn?: boolean
    expectedClockOut?: boolean
  }

  export type sessiondefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionNumber" | "expectedClockIn" | "expectedClockOut", ExtArgs["result"]["sessiondefinition"]>
  export type sessiondefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendancelog?: boolean | sessiondefinition$attendancelogArgs<ExtArgs>
    _count?: boolean | SessiondefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $sessiondefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessiondefinition"
    objects: {
      attendancelog: Prisma.$attendancelogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionNumber: number
      expectedClockIn: Date
      expectedClockOut: Date
    }, ExtArgs["result"]["sessiondefinition"]>
    composites: {}
  }

  type sessiondefinitionGetPayload<S extends boolean | null | undefined | sessiondefinitionDefaultArgs> = $Result.GetResult<Prisma.$sessiondefinitionPayload, S>

  type sessiondefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessiondefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessiondefinitionCountAggregateInputType | true
    }

  export interface sessiondefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessiondefinition'], meta: { name: 'sessiondefinition' } }
    /**
     * Find zero or one Sessiondefinition that matches the filter.
     * @param {sessiondefinitionFindUniqueArgs} args - Arguments to find a Sessiondefinition
     * @example
     * // Get one Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessiondefinitionFindUniqueArgs>(args: SelectSubset<T, sessiondefinitionFindUniqueArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessiondefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessiondefinitionFindUniqueOrThrowArgs} args - Arguments to find a Sessiondefinition
     * @example
     * // Get one Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessiondefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, sessiondefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessiondefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionFindFirstArgs} args - Arguments to find a Sessiondefinition
     * @example
     * // Get one Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessiondefinitionFindFirstArgs>(args?: SelectSubset<T, sessiondefinitionFindFirstArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessiondefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionFindFirstOrThrowArgs} args - Arguments to find a Sessiondefinition
     * @example
     * // Get one Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessiondefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, sessiondefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessiondefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessiondefinitions
     * const sessiondefinitions = await prisma.sessiondefinition.findMany()
     * 
     * // Get first 10 Sessiondefinitions
     * const sessiondefinitions = await prisma.sessiondefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessiondefinitionWithIdOnly = await prisma.sessiondefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessiondefinitionFindManyArgs>(args?: SelectSubset<T, sessiondefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessiondefinition.
     * @param {sessiondefinitionCreateArgs} args - Arguments to create a Sessiondefinition.
     * @example
     * // Create one Sessiondefinition
     * const Sessiondefinition = await prisma.sessiondefinition.create({
     *   data: {
     *     // ... data to create a Sessiondefinition
     *   }
     * })
     * 
     */
    create<T extends sessiondefinitionCreateArgs>(args: SelectSubset<T, sessiondefinitionCreateArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessiondefinitions.
     * @param {sessiondefinitionCreateManyArgs} args - Arguments to create many Sessiondefinitions.
     * @example
     * // Create many Sessiondefinitions
     * const sessiondefinition = await prisma.sessiondefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessiondefinitionCreateManyArgs>(args?: SelectSubset<T, sessiondefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessiondefinition.
     * @param {sessiondefinitionDeleteArgs} args - Arguments to delete one Sessiondefinition.
     * @example
     * // Delete one Sessiondefinition
     * const Sessiondefinition = await prisma.sessiondefinition.delete({
     *   where: {
     *     // ... filter to delete one Sessiondefinition
     *   }
     * })
     * 
     */
    delete<T extends sessiondefinitionDeleteArgs>(args: SelectSubset<T, sessiondefinitionDeleteArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessiondefinition.
     * @param {sessiondefinitionUpdateArgs} args - Arguments to update one Sessiondefinition.
     * @example
     * // Update one Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessiondefinitionUpdateArgs>(args: SelectSubset<T, sessiondefinitionUpdateArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessiondefinitions.
     * @param {sessiondefinitionDeleteManyArgs} args - Arguments to filter Sessiondefinitions to delete.
     * @example
     * // Delete a few Sessiondefinitions
     * const { count } = await prisma.sessiondefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessiondefinitionDeleteManyArgs>(args?: SelectSubset<T, sessiondefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessiondefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessiondefinitions
     * const sessiondefinition = await prisma.sessiondefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessiondefinitionUpdateManyArgs>(args: SelectSubset<T, sessiondefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessiondefinition.
     * @param {sessiondefinitionUpsertArgs} args - Arguments to update or create a Sessiondefinition.
     * @example
     * // Update or create a Sessiondefinition
     * const sessiondefinition = await prisma.sessiondefinition.upsert({
     *   create: {
     *     // ... data to create a Sessiondefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessiondefinition we want to update
     *   }
     * })
     */
    upsert<T extends sessiondefinitionUpsertArgs>(args: SelectSubset<T, sessiondefinitionUpsertArgs<ExtArgs>>): Prisma__sessiondefinitionClient<$Result.GetResult<Prisma.$sessiondefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessiondefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionCountArgs} args - Arguments to filter Sessiondefinitions to count.
     * @example
     * // Count the number of Sessiondefinitions
     * const count = await prisma.sessiondefinition.count({
     *   where: {
     *     // ... the filter for the Sessiondefinitions we want to count
     *   }
     * })
    **/
    count<T extends sessiondefinitionCountArgs>(
      args?: Subset<T, sessiondefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessiondefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessiondefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessiondefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessiondefinitionAggregateArgs>(args: Subset<T, SessiondefinitionAggregateArgs>): Prisma.PrismaPromise<GetSessiondefinitionAggregateType<T>>

    /**
     * Group by Sessiondefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessiondefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessiondefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessiondefinitionGroupByArgs['orderBy'] }
        : { orderBy?: sessiondefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessiondefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessiondefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessiondefinition model
   */
  readonly fields: sessiondefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessiondefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessiondefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendancelog<T extends sessiondefinition$attendancelogArgs<ExtArgs> = {}>(args?: Subset<T, sessiondefinition$attendancelogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessiondefinition model
   */
  interface sessiondefinitionFieldRefs {
    readonly id: FieldRef<"sessiondefinition", 'Int'>
    readonly sessionNumber: FieldRef<"sessiondefinition", 'Int'>
    readonly expectedClockIn: FieldRef<"sessiondefinition", 'DateTime'>
    readonly expectedClockOut: FieldRef<"sessiondefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessiondefinition findUnique
   */
  export type sessiondefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter, which sessiondefinition to fetch.
     */
    where: sessiondefinitionWhereUniqueInput
  }

  /**
   * sessiondefinition findUniqueOrThrow
   */
  export type sessiondefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter, which sessiondefinition to fetch.
     */
    where: sessiondefinitionWhereUniqueInput
  }

  /**
   * sessiondefinition findFirst
   */
  export type sessiondefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter, which sessiondefinition to fetch.
     */
    where?: sessiondefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessiondefinitions to fetch.
     */
    orderBy?: sessiondefinitionOrderByWithRelationInput | sessiondefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessiondefinitions.
     */
    cursor?: sessiondefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessiondefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessiondefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessiondefinitions.
     */
    distinct?: SessiondefinitionScalarFieldEnum | SessiondefinitionScalarFieldEnum[]
  }

  /**
   * sessiondefinition findFirstOrThrow
   */
  export type sessiondefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter, which sessiondefinition to fetch.
     */
    where?: sessiondefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessiondefinitions to fetch.
     */
    orderBy?: sessiondefinitionOrderByWithRelationInput | sessiondefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessiondefinitions.
     */
    cursor?: sessiondefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessiondefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessiondefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessiondefinitions.
     */
    distinct?: SessiondefinitionScalarFieldEnum | SessiondefinitionScalarFieldEnum[]
  }

  /**
   * sessiondefinition findMany
   */
  export type sessiondefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter, which sessiondefinitions to fetch.
     */
    where?: sessiondefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessiondefinitions to fetch.
     */
    orderBy?: sessiondefinitionOrderByWithRelationInput | sessiondefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessiondefinitions.
     */
    cursor?: sessiondefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessiondefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessiondefinitions.
     */
    skip?: number
    distinct?: SessiondefinitionScalarFieldEnum | SessiondefinitionScalarFieldEnum[]
  }

  /**
   * sessiondefinition create
   */
  export type sessiondefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a sessiondefinition.
     */
    data: XOR<sessiondefinitionCreateInput, sessiondefinitionUncheckedCreateInput>
  }

  /**
   * sessiondefinition createMany
   */
  export type sessiondefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessiondefinitions.
     */
    data: sessiondefinitionCreateManyInput | sessiondefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessiondefinition update
   */
  export type sessiondefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a sessiondefinition.
     */
    data: XOR<sessiondefinitionUpdateInput, sessiondefinitionUncheckedUpdateInput>
    /**
     * Choose, which sessiondefinition to update.
     */
    where: sessiondefinitionWhereUniqueInput
  }

  /**
   * sessiondefinition updateMany
   */
  export type sessiondefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessiondefinitions.
     */
    data: XOR<sessiondefinitionUpdateManyMutationInput, sessiondefinitionUncheckedUpdateManyInput>
    /**
     * Filter which sessiondefinitions to update
     */
    where?: sessiondefinitionWhereInput
    /**
     * Limit how many sessiondefinitions to update.
     */
    limit?: number
  }

  /**
   * sessiondefinition upsert
   */
  export type sessiondefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the sessiondefinition to update in case it exists.
     */
    where: sessiondefinitionWhereUniqueInput
    /**
     * In case the sessiondefinition found by the `where` argument doesn't exist, create a new sessiondefinition with this data.
     */
    create: XOR<sessiondefinitionCreateInput, sessiondefinitionUncheckedCreateInput>
    /**
     * In case the sessiondefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessiondefinitionUpdateInput, sessiondefinitionUncheckedUpdateInput>
  }

  /**
   * sessiondefinition delete
   */
  export type sessiondefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
    /**
     * Filter which sessiondefinition to delete.
     */
    where: sessiondefinitionWhereUniqueInput
  }

  /**
   * sessiondefinition deleteMany
   */
  export type sessiondefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessiondefinitions to delete
     */
    where?: sessiondefinitionWhereInput
    /**
     * Limit how many sessiondefinitions to delete.
     */
    limit?: number
  }

  /**
   * sessiondefinition.attendancelog
   */
  export type sessiondefinition$attendancelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendancelog
     */
    select?: attendancelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendancelog
     */
    omit?: attendancelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendancelogInclude<ExtArgs> | null
    where?: attendancelogWhereInput
    orderBy?: attendancelogOrderByWithRelationInput | attendancelogOrderByWithRelationInput[]
    cursor?: attendancelogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendancelogScalarFieldEnum | AttendancelogScalarFieldEnum[]
  }

  /**
   * sessiondefinition without action
   */
  export type sessiondefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessiondefinition
     */
    select?: sessiondefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessiondefinition
     */
    omit?: sessiondefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessiondefinitionInclude<ExtArgs> | null
  }


  /**
   * Model shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    id: number | null
  }

  export type ShiftSumAggregateOutputType = {
    id: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    isFlexible: boolean | null
    description: string | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    isFlexible: boolean | null
    description: string | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    isFlexible: number
    description: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    id?: true
  }

  export type ShiftSumAggregateInputType = {
    id?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shift to aggregate.
     */
    where?: shiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shifts to fetch.
     */
    orderBy?: shiftOrderByWithRelationInput | shiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type shiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: shiftWhereInput
    orderBy?: shiftOrderByWithAggregationInput | shiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: shiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: number
    name: string
    startTime: Date
    endTime: Date
    isFlexible: boolean
    description: string | null
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends shiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type shiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isFlexible?: boolean
    description?: boolean
    employeeshift?: boolean | shift$employeeshiftArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>



  export type shiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isFlexible?: boolean
    description?: boolean
  }

  export type shiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "isFlexible" | "description", ExtArgs["result"]["shift"]>
  export type shiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeshift?: boolean | shift$employeeshiftArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $shiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "shift"
    objects: {
      employeeshift: Prisma.$employeeshiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startTime: Date
      endTime: Date
      isFlexible: boolean
      description: string | null
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type shiftGetPayload<S extends boolean | null | undefined | shiftDefaultArgs> = $Result.GetResult<Prisma.$shiftPayload, S>

  type shiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<shiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface shiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['shift'], meta: { name: 'shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {shiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends shiftFindUniqueArgs>(args: SelectSubset<T, shiftFindUniqueArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {shiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends shiftFindUniqueOrThrowArgs>(args: SelectSubset<T, shiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends shiftFindFirstArgs>(args?: SelectSubset<T, shiftFindFirstArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends shiftFindFirstOrThrowArgs>(args?: SelectSubset<T, shiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends shiftFindManyArgs>(args?: SelectSubset<T, shiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {shiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends shiftCreateArgs>(args: SelectSubset<T, shiftCreateArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {shiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends shiftCreateManyArgs>(args?: SelectSubset<T, shiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shift.
     * @param {shiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends shiftDeleteArgs>(args: SelectSubset<T, shiftDeleteArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {shiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends shiftUpdateArgs>(args: SelectSubset<T, shiftUpdateArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {shiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends shiftDeleteManyArgs>(args?: SelectSubset<T, shiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends shiftUpdateManyArgs>(args: SelectSubset<T, shiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {shiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends shiftUpsertArgs>(args: SelectSubset<T, shiftUpsertArgs<ExtArgs>>): Prisma__shiftClient<$Result.GetResult<Prisma.$shiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends shiftCountArgs>(
      args?: Subset<T, shiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends shiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: shiftGroupByArgs['orderBy'] }
        : { orderBy?: shiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, shiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the shift model
   */
  readonly fields: shiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__shiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeshift<T extends shift$employeeshiftArgs<ExtArgs> = {}>(args?: Subset<T, shift$employeeshiftArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeshiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the shift model
   */
  interface shiftFieldRefs {
    readonly id: FieldRef<"shift", 'Int'>
    readonly name: FieldRef<"shift", 'String'>
    readonly startTime: FieldRef<"shift", 'DateTime'>
    readonly endTime: FieldRef<"shift", 'DateTime'>
    readonly isFlexible: FieldRef<"shift", 'Boolean'>
    readonly description: FieldRef<"shift", 'String'>
  }
    

  // Custom InputTypes
  /**
   * shift findUnique
   */
  export type shiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter, which shift to fetch.
     */
    where: shiftWhereUniqueInput
  }

  /**
   * shift findUniqueOrThrow
   */
  export type shiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter, which shift to fetch.
     */
    where: shiftWhereUniqueInput
  }

  /**
   * shift findFirst
   */
  export type shiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter, which shift to fetch.
     */
    where?: shiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shifts to fetch.
     */
    orderBy?: shiftOrderByWithRelationInput | shiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shifts.
     */
    cursor?: shiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * shift findFirstOrThrow
   */
  export type shiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter, which shift to fetch.
     */
    where?: shiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shifts to fetch.
     */
    orderBy?: shiftOrderByWithRelationInput | shiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shifts.
     */
    cursor?: shiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * shift findMany
   */
  export type shiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter, which shifts to fetch.
     */
    where?: shiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shifts to fetch.
     */
    orderBy?: shiftOrderByWithRelationInput | shiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shifts.
     */
    cursor?: shiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * shift create
   */
  export type shiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * The data needed to create a shift.
     */
    data: XOR<shiftCreateInput, shiftUncheckedCreateInput>
  }

  /**
   * shift createMany
   */
  export type shiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many shifts.
     */
    data: shiftCreateManyInput | shiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * shift update
   */
  export type shiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * The data needed to update a shift.
     */
    data: XOR<shiftUpdateInput, shiftUncheckedUpdateInput>
    /**
     * Choose, which shift to update.
     */
    where: shiftWhereUniqueInput
  }

  /**
   * shift updateMany
   */
  export type shiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update shifts.
     */
    data: XOR<shiftUpdateManyMutationInput, shiftUncheckedUpdateManyInput>
    /**
     * Filter which shifts to update
     */
    where?: shiftWhereInput
    /**
     * Limit how many shifts to update.
     */
    limit?: number
  }

  /**
   * shift upsert
   */
  export type shiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * The filter to search for the shift to update in case it exists.
     */
    where: shiftWhereUniqueInput
    /**
     * In case the shift found by the `where` argument doesn't exist, create a new shift with this data.
     */
    create: XOR<shiftCreateInput, shiftUncheckedCreateInput>
    /**
     * In case the shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shiftUpdateInput, shiftUncheckedUpdateInput>
  }

  /**
   * shift delete
   */
  export type shiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
    /**
     * Filter which shift to delete.
     */
    where: shiftWhereUniqueInput
  }

  /**
   * shift deleteMany
   */
  export type shiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which shifts to delete
     */
    where?: shiftWhereInput
    /**
     * Limit how many shifts to delete.
     */
    limit?: number
  }

  /**
   * shift.employeeshift
   */
  export type shift$employeeshiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeshift
     */
    select?: employeeshiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeshift
     */
    omit?: employeeshiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeshiftInclude<ExtArgs> | null
    where?: employeeshiftWhereInput
    orderBy?: employeeshiftOrderByWithRelationInput | employeeshiftOrderByWithRelationInput[]
    cursor?: employeeshiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeshiftScalarFieldEnum | EmployeeshiftScalarFieldEnum[]
  }

  /**
   * shift without action
   */
  export type shiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the shift
     */
    select?: shiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the shift
     */
    omit?: shiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: shiftInclude<ExtArgs> | null
  }


  /**
   * Model termination
   */

  export type AggregateTermination = {
    _count: TerminationCountAggregateOutputType | null
    _avg: TerminationAvgAggregateOutputType | null
    _sum: TerminationSumAggregateOutputType | null
    _min: TerminationMinAggregateOutputType | null
    _max: TerminationMaxAggregateOutputType | null
  }

  export type TerminationAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type TerminationSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type TerminationMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    reason: string | null
    status: $Enums.termination_status | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowStatus: $Enums.termination_workflowStatus | null
  }

  export type TerminationMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    reason: string | null
    status: $Enums.termination_status | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workflowStatus: $Enums.termination_workflowStatus | null
  }

  export type TerminationCountAggregateOutputType = {
    id: number
    employeeId: number
    terminationDate: number
    reason: number
    status: number
    remarks: number
    createdAt: number
    updatedAt: number
    workflowStatus: number
    _all: number
  }


  export type TerminationAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type TerminationSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type TerminationMinAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    workflowStatus?: true
  }

  export type TerminationMaxAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    workflowStatus?: true
  }

  export type TerminationCountAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    workflowStatus?: true
    _all?: true
  }

  export type TerminationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which termination to aggregate.
     */
    where?: terminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminations to fetch.
     */
    orderBy?: terminationOrderByWithRelationInput | terminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: terminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned terminations
    **/
    _count?: true | TerminationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerminationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerminationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminationMaxAggregateInputType
  }

  export type GetTerminationAggregateType<T extends TerminationAggregateArgs> = {
        [P in keyof T & keyof AggregateTermination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermination[P]>
      : GetScalarType<T[P], AggregateTermination[P]>
  }




  export type terminationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: terminationWhereInput
    orderBy?: terminationOrderByWithAggregationInput | terminationOrderByWithAggregationInput[]
    by: TerminationScalarFieldEnum[] | TerminationScalarFieldEnum
    having?: terminationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminationCountAggregateInputType | true
    _avg?: TerminationAvgAggregateInputType
    _sum?: TerminationSumAggregateInputType
    _min?: TerminationMinAggregateInputType
    _max?: TerminationMaxAggregateInputType
  }

  export type TerminationGroupByOutputType = {
    id: number
    employeeId: number
    terminationDate: Date
    reason: string | null
    status: $Enums.termination_status
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    workflowStatus: $Enums.termination_workflowStatus
    _count: TerminationCountAggregateOutputType | null
    _avg: TerminationAvgAggregateOutputType | null
    _sum: TerminationSumAggregateOutputType | null
    _min: TerminationMinAggregateOutputType | null
    _max: TerminationMaxAggregateOutputType | null
  }

  type GetTerminationGroupByPayload<T extends terminationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminationGroupByOutputType[P]>
            : GetScalarType<T[P], TerminationGroupByOutputType[P]>
        }
      >
    >


  export type terminationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    reason?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowStatus?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termination"]>



  export type terminationSelectScalar = {
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    reason?: boolean
    status?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workflowStatus?: boolean
  }

  export type terminationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "terminationDate" | "reason" | "status" | "remarks" | "createdAt" | "updatedAt" | "workflowStatus", ExtArgs["result"]["termination"]>
  export type terminationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
  }

  export type $terminationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "termination"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      terminationDate: Date
      reason: string | null
      status: $Enums.termination_status
      remarks: string | null
      createdAt: Date
      updatedAt: Date
      workflowStatus: $Enums.termination_workflowStatus
    }, ExtArgs["result"]["termination"]>
    composites: {}
  }

  type terminationGetPayload<S extends boolean | null | undefined | terminationDefaultArgs> = $Result.GetResult<Prisma.$terminationPayload, S>

  type terminationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<terminationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerminationCountAggregateInputType | true
    }

  export interface terminationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['termination'], meta: { name: 'termination' } }
    /**
     * Find zero or one Termination that matches the filter.
     * @param {terminationFindUniqueArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends terminationFindUniqueArgs>(args: SelectSubset<T, terminationFindUniqueArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Termination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {terminationFindUniqueOrThrowArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends terminationFindUniqueOrThrowArgs>(args: SelectSubset<T, terminationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Termination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationFindFirstArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends terminationFindFirstArgs>(args?: SelectSubset<T, terminationFindFirstArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Termination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationFindFirstOrThrowArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends terminationFindFirstOrThrowArgs>(args?: SelectSubset<T, terminationFindFirstOrThrowArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Terminations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terminations
     * const terminations = await prisma.termination.findMany()
     * 
     * // Get first 10 Terminations
     * const terminations = await prisma.termination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminationWithIdOnly = await prisma.termination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends terminationFindManyArgs>(args?: SelectSubset<T, terminationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Termination.
     * @param {terminationCreateArgs} args - Arguments to create a Termination.
     * @example
     * // Create one Termination
     * const Termination = await prisma.termination.create({
     *   data: {
     *     // ... data to create a Termination
     *   }
     * })
     * 
     */
    create<T extends terminationCreateArgs>(args: SelectSubset<T, terminationCreateArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Terminations.
     * @param {terminationCreateManyArgs} args - Arguments to create many Terminations.
     * @example
     * // Create many Terminations
     * const termination = await prisma.termination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends terminationCreateManyArgs>(args?: SelectSubset<T, terminationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Termination.
     * @param {terminationDeleteArgs} args - Arguments to delete one Termination.
     * @example
     * // Delete one Termination
     * const Termination = await prisma.termination.delete({
     *   where: {
     *     // ... filter to delete one Termination
     *   }
     * })
     * 
     */
    delete<T extends terminationDeleteArgs>(args: SelectSubset<T, terminationDeleteArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Termination.
     * @param {terminationUpdateArgs} args - Arguments to update one Termination.
     * @example
     * // Update one Termination
     * const termination = await prisma.termination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends terminationUpdateArgs>(args: SelectSubset<T, terminationUpdateArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Terminations.
     * @param {terminationDeleteManyArgs} args - Arguments to filter Terminations to delete.
     * @example
     * // Delete a few Terminations
     * const { count } = await prisma.termination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends terminationDeleteManyArgs>(args?: SelectSubset<T, terminationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terminations
     * const termination = await prisma.termination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends terminationUpdateManyArgs>(args: SelectSubset<T, terminationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Termination.
     * @param {terminationUpsertArgs} args - Arguments to update or create a Termination.
     * @example
     * // Update or create a Termination
     * const termination = await prisma.termination.upsert({
     *   create: {
     *     // ... data to create a Termination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Termination we want to update
     *   }
     * })
     */
    upsert<T extends terminationUpsertArgs>(args: SelectSubset<T, terminationUpsertArgs<ExtArgs>>): Prisma__terminationClient<$Result.GetResult<Prisma.$terminationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Terminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationCountArgs} args - Arguments to filter Terminations to count.
     * @example
     * // Count the number of Terminations
     * const count = await prisma.termination.count({
     *   where: {
     *     // ... the filter for the Terminations we want to count
     *   }
     * })
    **/
    count<T extends terminationCountArgs>(
      args?: Subset<T, terminationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Termination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminationAggregateArgs>(args: Subset<T, TerminationAggregateArgs>): Prisma.PrismaPromise<GetTerminationAggregateType<T>>

    /**
     * Group by Termination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {terminationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends terminationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: terminationGroupByArgs['orderBy'] }
        : { orderBy?: terminationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, terminationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the termination model
   */
  readonly fields: terminationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for termination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__terminationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the termination model
   */
  interface terminationFieldRefs {
    readonly id: FieldRef<"termination", 'Int'>
    readonly employeeId: FieldRef<"termination", 'Int'>
    readonly terminationDate: FieldRef<"termination", 'DateTime'>
    readonly reason: FieldRef<"termination", 'String'>
    readonly status: FieldRef<"termination", 'termination_status'>
    readonly remarks: FieldRef<"termination", 'String'>
    readonly createdAt: FieldRef<"termination", 'DateTime'>
    readonly updatedAt: FieldRef<"termination", 'DateTime'>
    readonly workflowStatus: FieldRef<"termination", 'termination_workflowStatus'>
  }
    

  // Custom InputTypes
  /**
   * termination findUnique
   */
  export type terminationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter, which termination to fetch.
     */
    where: terminationWhereUniqueInput
  }

  /**
   * termination findUniqueOrThrow
   */
  export type terminationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter, which termination to fetch.
     */
    where: terminationWhereUniqueInput
  }

  /**
   * termination findFirst
   */
  export type terminationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter, which termination to fetch.
     */
    where?: terminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminations to fetch.
     */
    orderBy?: terminationOrderByWithRelationInput | terminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terminations.
     */
    cursor?: terminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terminations.
     */
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * termination findFirstOrThrow
   */
  export type terminationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter, which termination to fetch.
     */
    where?: terminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminations to fetch.
     */
    orderBy?: terminationOrderByWithRelationInput | terminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for terminations.
     */
    cursor?: terminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of terminations.
     */
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * termination findMany
   */
  export type terminationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter, which terminations to fetch.
     */
    where?: terminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of terminations to fetch.
     */
    orderBy?: terminationOrderByWithRelationInput | terminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing terminations.
     */
    cursor?: terminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` terminations.
     */
    skip?: number
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * termination create
   */
  export type terminationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * The data needed to create a termination.
     */
    data: XOR<terminationCreateInput, terminationUncheckedCreateInput>
  }

  /**
   * termination createMany
   */
  export type terminationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many terminations.
     */
    data: terminationCreateManyInput | terminationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * termination update
   */
  export type terminationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * The data needed to update a termination.
     */
    data: XOR<terminationUpdateInput, terminationUncheckedUpdateInput>
    /**
     * Choose, which termination to update.
     */
    where: terminationWhereUniqueInput
  }

  /**
   * termination updateMany
   */
  export type terminationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update terminations.
     */
    data: XOR<terminationUpdateManyMutationInput, terminationUncheckedUpdateManyInput>
    /**
     * Filter which terminations to update
     */
    where?: terminationWhereInput
    /**
     * Limit how many terminations to update.
     */
    limit?: number
  }

  /**
   * termination upsert
   */
  export type terminationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * The filter to search for the termination to update in case it exists.
     */
    where: terminationWhereUniqueInput
    /**
     * In case the termination found by the `where` argument doesn't exist, create a new termination with this data.
     */
    create: XOR<terminationCreateInput, terminationUncheckedCreateInput>
    /**
     * In case the termination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<terminationUpdateInput, terminationUncheckedUpdateInput>
  }

  /**
   * termination delete
   */
  export type terminationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
    /**
     * Filter which termination to delete.
     */
    where: terminationWhereUniqueInput
  }

  /**
   * termination deleteMany
   */
  export type terminationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which terminations to delete
     */
    where?: terminationWhereInput
    /**
     * Limit how many terminations to delete.
     */
    limit?: number
  }

  /**
   * termination without action
   */
  export type terminationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the termination
     */
    select?: terminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the termination
     */
    omit?: terminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: terminationInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    notifyOnComplaint: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    notifyOnComplaint: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    notifyOnComplaint: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    notifyOnComplaint: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifyOnComplaint?: boolean
    employee?: boolean | user$employeeArgs<ExtArgs>
    leave?: boolean | user$leaveArgs<ExtArgs>
    overtimelog?: boolean | user$overtimelogArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type userSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifyOnComplaint?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "isActive" | "createdAt" | "updatedAt" | "notifyOnComplaint", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | user$employeeArgs<ExtArgs>
    leave?: boolean | user$leaveArgs<ExtArgs>
    overtimelog?: boolean | user$overtimelogArgs<ExtArgs>
    userrole?: boolean | user$userroleArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs> | null
      leave: Prisma.$leavePayload<ExtArgs>[]
      overtimelog: Prisma.$overtimelogPayload<ExtArgs>[]
      userrole: Prisma.$userrolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      notifyOnComplaint: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends user$employeeArgs<ExtArgs> = {}>(args?: Subset<T, user$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    leave<T extends user$leaveArgs<ExtArgs> = {}>(args?: Subset<T, user$leaveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$leavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimelog<T extends user$overtimelogArgs<ExtArgs> = {}>(args?: Subset<T, user$overtimelogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$overtimelogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userrole<T extends user$userroleArgs<ExtArgs> = {}>(args?: Subset<T, user$userroleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly username: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly isActive: FieldRef<"user", 'Boolean'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
    readonly notifyOnComplaint: FieldRef<"user", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.employee
   */
  export type user$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * user.leave
   */
  export type user$leaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the leave
     */
    select?: leaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the leave
     */
    omit?: leaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: leaveInclude<ExtArgs> | null
    where?: leaveWhereInput
    orderBy?: leaveOrderByWithRelationInput | leaveOrderByWithRelationInput[]
    cursor?: leaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * user.overtimelog
   */
  export type user$overtimelogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the overtimelog
     */
    select?: overtimelogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the overtimelog
     */
    omit?: overtimelogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: overtimelogInclude<ExtArgs> | null
    where?: overtimelogWhereInput
    orderBy?: overtimelogOrderByWithRelationInput | overtimelogOrderByWithRelationInput[]
    cursor?: overtimelogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimelogScalarFieldEnum | OvertimelogScalarFieldEnum[]
  }

  /**
   * user.userrole
   */
  export type user$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    cursor?: userroleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserroleSumAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserroleMinAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserroleMaxAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserroleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserroleSumAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserroleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserroleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserroleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    userId: number
    roleId: number
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>



  export type userroleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type userroleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userrole"]>
  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | roleDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      role: Prisma.$rolePayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      roleId: number
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userroleWithUserIdOnly = await prisma.userrole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends roleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roleDefaultArgs<ExtArgs>>): Prisma__roleClient<$Result.GetResult<Prisma.$rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */
  interface userroleFieldRefs {
    readonly userId: FieldRef<"userrole", 'Int'>
    readonly roleId: FieldRef<"userrole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to delete.
     */
    limit?: number
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivitylogScalarFieldEnum: {
    id: 'id',
    type: 'type',
    message: 'message',
    actorId: 'actorId',
    targetId: 'targetId',
    departmentId: 'departmentId',
    createdAt: 'createdAt'
  };

  export type ActivitylogScalarFieldEnum = (typeof ActivitylogScalarFieldEnum)[keyof typeof ActivitylogScalarFieldEnum]


  export const AgreementstatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type AgreementstatusScalarFieldEnum = (typeof AgreementstatusScalarFieldEnum)[keyof typeof AgreementstatusScalarFieldEnum]


  export const AttendancelogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    sessionId: 'sessionId',
    actualClockIn: 'actualClockIn',
    actualClockOut: 'actualClockOut',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AttendancelogScalarFieldEnum = (typeof AttendancelogScalarFieldEnum)[keyof typeof AttendancelogScalarFieldEnum]


  export const AttendancesummaryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    status: 'status',
    lateArrival: 'lateArrival',
    earlyDeparture: 'earlyDeparture',
    unplannedAbsence: 'unplannedAbsence',
    totalWorkHours: 'totalWorkHours',
    remarks: 'remarks',
    departmentId: 'departmentId'
  };

  export type AttendancesummaryScalarFieldEnum = (typeof AttendancesummaryScalarFieldEnum)[keyof typeof AttendancesummaryScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    subject: 'subject',
    description: 'description',
    status: 'status',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    payrollPolicyId: 'payrollPolicyId'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    baptismalName: 'baptismalName',
    dateOfBirth: 'dateOfBirth',
    sex: 'sex',
    nationality: 'nationality',
    maritalStatusId: 'maritalStatusId',
    departmentId: 'departmentId',
    positionId: 'positionId',
    employmentTypeId: 'employmentTypeId',
    employmentDate: 'employmentDate',
    jobStatusId: 'jobStatusId',
    phone: 'phone',
    address: 'address',
    subCity: 'subCity',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    repentanceFatherName: 'repentanceFatherName',
    repentanceFatherChurch: 'repentanceFatherChurch',
    repentanceFatherPhone: 'repentanceFatherPhone',
    academicQualification: 'academicQualification',
    educationalInstitution: 'educationalInstitution',
    salary: 'salary',
    bonusSalary: 'bonusSalary',
    accountNumber: 'accountNumber',
    agreementStatusId: 'agreementStatusId',
    photo: 'photo',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subDepartmentId: 'subDepartmentId'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EmployeeshiftScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo'
  };

  export type EmployeeshiftScalarFieldEnum = (typeof EmployeeshiftScalarFieldEnum)[keyof typeof EmployeeshiftScalarFieldEnum]


  export const EmploymenttypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type EmploymenttypeScalarFieldEnum = (typeof EmploymenttypeScalarFieldEnum)[keyof typeof EmploymenttypeScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    isPublic: 'isPublic',
    description: 'description'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    id: 'id',
    candidateName: 'candidateName',
    position: 'position',
    interviewDate: 'interviewDate',
    result: 'result',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const JobstatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type JobstatusScalarFieldEnum = (typeof JobstatusScalarFieldEnum)[keyof typeof JobstatusScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    reason: 'reason',
    approvedBy: 'approvedBy',
    requestedAt: 'requestedAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const MaritalstatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type MaritalstatusScalarFieldEnum = (typeof MaritalstatusScalarFieldEnum)[keyof typeof MaritalstatusScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const OvertimelogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    hours: 'hours',
    reason: 'reason',
    approvedBy: 'approvedBy',
    approvalStatus: 'approvalStatus',
    compensationMethod: 'compensationMethod',
    endTime: 'endTime',
    startTime: 'startTime',
    overtimeType: 'overtimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OvertimelogScalarFieldEnum = (typeof OvertimelogScalarFieldEnum)[keyof typeof OvertimelogScalarFieldEnum]


  export const PayrollpolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isDefault: 'isDefault',
    otMultiplierWeekday1: 'otMultiplierWeekday1',
    otMultiplierWeekday2: 'otMultiplierWeekday2',
    otMultiplierSunday: 'otMultiplierSunday',
    otMultiplierHoliday: 'otMultiplierHoliday',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    otMultiplierSleepover: 'otMultiplierSleepover'
  };

  export type PayrollpolicyScalarFieldEnum = (typeof PayrollpolicyScalarFieldEnum)[keyof typeof PayrollpolicyScalarFieldEnum]


  export const PerformancereviewScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    reviewDate: 'reviewDate',
    reviewerName: 'reviewerName',
    score: 'score',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformancereviewScalarFieldEnum = (typeof PerformancereviewScalarFieldEnum)[keyof typeof PerformancereviewScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    salaryMonth: 'salaryMonth',
    amount: 'amount',
    status: 'status',
    overtimeHours: 'overtimeHours',
    overtimePay: 'overtimePay',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    baseSalary: 'baseSalary',
    deductions: 'deductions'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const SessiondefinitionScalarFieldEnum: {
    id: 'id',
    sessionNumber: 'sessionNumber',
    expectedClockIn: 'expectedClockIn',
    expectedClockOut: 'expectedClockOut'
  };

  export type SessiondefinitionScalarFieldEnum = (typeof SessiondefinitionScalarFieldEnum)[keyof typeof SessiondefinitionScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    isFlexible: 'isFlexible',
    description: 'description'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const TerminationScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    terminationDate: 'terminationDate',
    reason: 'reason',
    status: 'status',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workflowStatus: 'workflowStatus'
  };

  export type TerminationScalarFieldEnum = (typeof TerminationScalarFieldEnum)[keyof typeof TerminationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    notifyOnComplaint: 'notifyOnComplaint'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const activitylogOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type activitylogOrderByRelevanceFieldEnum = (typeof activitylogOrderByRelevanceFieldEnum)[keyof typeof activitylogOrderByRelevanceFieldEnum]


  export const agreementstatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type agreementstatusOrderByRelevanceFieldEnum = (typeof agreementstatusOrderByRelevanceFieldEnum)[keyof typeof agreementstatusOrderByRelevanceFieldEnum]


  export const attendancesummaryOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type attendancesummaryOrderByRelevanceFieldEnum = (typeof attendancesummaryOrderByRelevanceFieldEnum)[keyof typeof attendancesummaryOrderByRelevanceFieldEnum]


  export const complaintOrderByRelevanceFieldEnum: {
    subject: 'subject',
    description: 'description',
    response: 'response'
  };

  export type complaintOrderByRelevanceFieldEnum = (typeof complaintOrderByRelevanceFieldEnum)[keyof typeof complaintOrderByRelevanceFieldEnum]


  export const departmentOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type departmentOrderByRelevanceFieldEnum = (typeof departmentOrderByRelevanceFieldEnum)[keyof typeof departmentOrderByRelevanceFieldEnum]


  export const employeeOrderByRelevanceFieldEnum: {
    firstName: 'firstName',
    lastName: 'lastName',
    baptismalName: 'baptismalName',
    nationality: 'nationality',
    phone: 'phone',
    address: 'address',
    subCity: 'subCity',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    repentanceFatherName: 'repentanceFatherName',
    repentanceFatherChurch: 'repentanceFatherChurch',
    repentanceFatherPhone: 'repentanceFatherPhone',
    academicQualification: 'academicQualification',
    educationalInstitution: 'educationalInstitution',
    accountNumber: 'accountNumber',
    photo: 'photo'
  };

  export type employeeOrderByRelevanceFieldEnum = (typeof employeeOrderByRelevanceFieldEnum)[keyof typeof employeeOrderByRelevanceFieldEnum]


  export const employmenttypeOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type employmenttypeOrderByRelevanceFieldEnum = (typeof employmenttypeOrderByRelevanceFieldEnum)[keyof typeof employmenttypeOrderByRelevanceFieldEnum]


  export const holidayOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type holidayOrderByRelevanceFieldEnum = (typeof holidayOrderByRelevanceFieldEnum)[keyof typeof holidayOrderByRelevanceFieldEnum]


  export const interviewOrderByRelevanceFieldEnum: {
    candidateName: 'candidateName',
    position: 'position',
    comments: 'comments'
  };

  export type interviewOrderByRelevanceFieldEnum = (typeof interviewOrderByRelevanceFieldEnum)[keyof typeof interviewOrderByRelevanceFieldEnum]


  export const jobstatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type jobstatusOrderByRelevanceFieldEnum = (typeof jobstatusOrderByRelevanceFieldEnum)[keyof typeof jobstatusOrderByRelevanceFieldEnum]


  export const leaveOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type leaveOrderByRelevanceFieldEnum = (typeof leaveOrderByRelevanceFieldEnum)[keyof typeof leaveOrderByRelevanceFieldEnum]


  export const maritalstatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type maritalstatusOrderByRelevanceFieldEnum = (typeof maritalstatusOrderByRelevanceFieldEnum)[keyof typeof maritalstatusOrderByRelevanceFieldEnum]


  export const meetingOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    time: 'time'
  };

  export type meetingOrderByRelevanceFieldEnum = (typeof meetingOrderByRelevanceFieldEnum)[keyof typeof meetingOrderByRelevanceFieldEnum]


  export const overtimelogOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type overtimelogOrderByRelevanceFieldEnum = (typeof overtimelogOrderByRelevanceFieldEnum)[keyof typeof overtimelogOrderByRelevanceFieldEnum]


  export const payrollpolicyOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type payrollpolicyOrderByRelevanceFieldEnum = (typeof payrollpolicyOrderByRelevanceFieldEnum)[keyof typeof payrollpolicyOrderByRelevanceFieldEnum]


  export const performancereviewOrderByRelevanceFieldEnum: {
    reviewerName: 'reviewerName',
    comments: 'comments'
  };

  export type performancereviewOrderByRelevanceFieldEnum = (typeof performancereviewOrderByRelevanceFieldEnum)[keyof typeof performancereviewOrderByRelevanceFieldEnum]


  export const positionOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type positionOrderByRelevanceFieldEnum = (typeof positionOrderByRelevanceFieldEnum)[keyof typeof positionOrderByRelevanceFieldEnum]


  export const roleOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type roleOrderByRelevanceFieldEnum = (typeof roleOrderByRelevanceFieldEnum)[keyof typeof roleOrderByRelevanceFieldEnum]


  export const shiftOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type shiftOrderByRelevanceFieldEnum = (typeof shiftOrderByRelevanceFieldEnum)[keyof typeof shiftOrderByRelevanceFieldEnum]


  export const terminationOrderByRelevanceFieldEnum: {
    reason: 'reason',
    remarks: 'remarks'
  };

  export type terminationOrderByRelevanceFieldEnum = (typeof terminationOrderByRelevanceFieldEnum)[keyof typeof terminationOrderByRelevanceFieldEnum]


  export const userOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password'
  };

  export type userOrderByRelevanceFieldEnum = (typeof userOrderByRelevanceFieldEnum)[keyof typeof userOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'activitylog_type'
   */
  export type Enumactivitylog_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'activitylog_type'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'attendancelog_status'
   */
  export type Enumattendancelog_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendancelog_status'>
    


  /**
   * Reference to a field of type 'attendancesummary_status'
   */
  export type Enumattendancesummary_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'attendancesummary_status'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'complaint_status'
   */
  export type Enumcomplaint_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'complaint_status'>
    


  /**
   * Reference to a field of type 'employee_sex'
   */
  export type Enumemployee_sexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'employee_sex'>
    


  /**
   * Reference to a field of type 'interview_result'
   */
  export type Enuminterview_resultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'interview_result'>
    


  /**
   * Reference to a field of type 'leave_leaveType'
   */
  export type Enumleave_leaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'leave_leaveType'>
    


  /**
   * Reference to a field of type 'leave_status'
   */
  export type Enumleave_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'leave_status'>
    


  /**
   * Reference to a field of type 'overtimelog_approvalStatus'
   */
  export type Enumovertimelog_approvalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'overtimelog_approvalStatus'>
    


  /**
   * Reference to a field of type 'overtimelog_compensationMethod'
   */
  export type Enumovertimelog_compensationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'overtimelog_compensationMethod'>
    


  /**
   * Reference to a field of type 'overtimelog_overtimeType'
   */
  export type Enumovertimelog_overtimeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'overtimelog_overtimeType'>
    


  /**
   * Reference to a field of type 'salary_status'
   */
  export type Enumsalary_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'salary_status'>
    


  /**
   * Reference to a field of type 'termination_status'
   */
  export type Enumtermination_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'termination_status'>
    


  /**
   * Reference to a field of type 'termination_workflowStatus'
   */
  export type Enumtermination_workflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'termination_workflowStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type activitylogWhereInput = {
    AND?: activitylogWhereInput | activitylogWhereInput[]
    OR?: activitylogWhereInput[]
    NOT?: activitylogWhereInput | activitylogWhereInput[]
    id?: IntFilter<"activitylog"> | number
    type?: Enumactivitylog_typeFilter<"activitylog"> | $Enums.activitylog_type
    message?: StringFilter<"activitylog"> | string
    actorId?: IntFilter<"activitylog"> | number
    targetId?: IntNullableFilter<"activitylog"> | number | null
    departmentId?: IntFilter<"activitylog"> | number
    createdAt?: DateTimeFilter<"activitylog"> | Date | string
    employee_activitylog_actorIdToemployee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    employee_activitylog_targetIdToemployee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }

  export type activitylogOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrderInput | SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    employee_activitylog_actorIdToemployee?: employeeOrderByWithRelationInput
    employee_activitylog_targetIdToemployee?: employeeOrderByWithRelationInput
    _relevance?: activitylogOrderByRelevanceInput
  }

  export type activitylogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: activitylogWhereInput | activitylogWhereInput[]
    OR?: activitylogWhereInput[]
    NOT?: activitylogWhereInput | activitylogWhereInput[]
    type?: Enumactivitylog_typeFilter<"activitylog"> | $Enums.activitylog_type
    message?: StringFilter<"activitylog"> | string
    actorId?: IntFilter<"activitylog"> | number
    targetId?: IntNullableFilter<"activitylog"> | number | null
    departmentId?: IntFilter<"activitylog"> | number
    createdAt?: DateTimeFilter<"activitylog"> | Date | string
    employee_activitylog_actorIdToemployee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    employee_activitylog_targetIdToemployee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }, "id">

  export type activitylogOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrderInput | SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    _count?: activitylogCountOrderByAggregateInput
    _avg?: activitylogAvgOrderByAggregateInput
    _max?: activitylogMaxOrderByAggregateInput
    _min?: activitylogMinOrderByAggregateInput
    _sum?: activitylogSumOrderByAggregateInput
  }

  export type activitylogScalarWhereWithAggregatesInput = {
    AND?: activitylogScalarWhereWithAggregatesInput | activitylogScalarWhereWithAggregatesInput[]
    OR?: activitylogScalarWhereWithAggregatesInput[]
    NOT?: activitylogScalarWhereWithAggregatesInput | activitylogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"activitylog"> | number
    type?: Enumactivitylog_typeWithAggregatesFilter<"activitylog"> | $Enums.activitylog_type
    message?: StringWithAggregatesFilter<"activitylog"> | string
    actorId?: IntWithAggregatesFilter<"activitylog"> | number
    targetId?: IntNullableWithAggregatesFilter<"activitylog"> | number | null
    departmentId?: IntWithAggregatesFilter<"activitylog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"activitylog"> | Date | string
  }

  export type agreementstatusWhereInput = {
    AND?: agreementstatusWhereInput | agreementstatusWhereInput[]
    OR?: agreementstatusWhereInput[]
    NOT?: agreementstatusWhereInput | agreementstatusWhereInput[]
    id?: IntFilter<"agreementstatus"> | number
    status?: StringFilter<"agreementstatus"> | string
    employee?: EmployeeListRelationFilter
  }

  export type agreementstatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
    _relevance?: agreementstatusOrderByRelevanceInput
  }

  export type agreementstatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: agreementstatusWhereInput | agreementstatusWhereInput[]
    OR?: agreementstatusWhereInput[]
    NOT?: agreementstatusWhereInput | agreementstatusWhereInput[]
    employee?: EmployeeListRelationFilter
  }, "id" | "status">

  export type agreementstatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: agreementstatusCountOrderByAggregateInput
    _avg?: agreementstatusAvgOrderByAggregateInput
    _max?: agreementstatusMaxOrderByAggregateInput
    _min?: agreementstatusMinOrderByAggregateInput
    _sum?: agreementstatusSumOrderByAggregateInput
  }

  export type agreementstatusScalarWhereWithAggregatesInput = {
    AND?: agreementstatusScalarWhereWithAggregatesInput | agreementstatusScalarWhereWithAggregatesInput[]
    OR?: agreementstatusScalarWhereWithAggregatesInput[]
    NOT?: agreementstatusScalarWhereWithAggregatesInput | agreementstatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"agreementstatus"> | number
    status?: StringWithAggregatesFilter<"agreementstatus"> | string
  }

  export type attendancelogWhereInput = {
    AND?: attendancelogWhereInput | attendancelogWhereInput[]
    OR?: attendancelogWhereInput[]
    NOT?: attendancelogWhereInput | attendancelogWhereInput[]
    id?: IntFilter<"attendancelog"> | number
    employeeId?: IntFilter<"attendancelog"> | number
    date?: DateTimeFilter<"attendancelog"> | Date | string
    sessionId?: IntFilter<"attendancelog"> | number
    actualClockIn?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    status?: Enumattendancelog_statusFilter<"attendancelog"> | $Enums.attendancelog_status
    createdAt?: DateTimeFilter<"attendancelog"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    sessiondefinition?: XOR<SessiondefinitionScalarRelationFilter, sessiondefinitionWhereInput>
  }

  export type attendancelogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrderInput | SortOrder
    actualClockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    employee?: employeeOrderByWithRelationInput
    sessiondefinition?: sessiondefinitionOrderByWithRelationInput
  }

  export type attendancelogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date_sessionId?: attendancelogEmployeeIdDateSessionIdCompoundUniqueInput
    AND?: attendancelogWhereInput | attendancelogWhereInput[]
    OR?: attendancelogWhereInput[]
    NOT?: attendancelogWhereInput | attendancelogWhereInput[]
    employeeId?: IntFilter<"attendancelog"> | number
    date?: DateTimeFilter<"attendancelog"> | Date | string
    sessionId?: IntFilter<"attendancelog"> | number
    actualClockIn?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    status?: Enumattendancelog_statusFilter<"attendancelog"> | $Enums.attendancelog_status
    createdAt?: DateTimeFilter<"attendancelog"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    sessiondefinition?: XOR<SessiondefinitionScalarRelationFilter, sessiondefinitionWhereInput>
  }, "id" | "employeeId_date_sessionId">

  export type attendancelogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrderInput | SortOrder
    actualClockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: attendancelogCountOrderByAggregateInput
    _avg?: attendancelogAvgOrderByAggregateInput
    _max?: attendancelogMaxOrderByAggregateInput
    _min?: attendancelogMinOrderByAggregateInput
    _sum?: attendancelogSumOrderByAggregateInput
  }

  export type attendancelogScalarWhereWithAggregatesInput = {
    AND?: attendancelogScalarWhereWithAggregatesInput | attendancelogScalarWhereWithAggregatesInput[]
    OR?: attendancelogScalarWhereWithAggregatesInput[]
    NOT?: attendancelogScalarWhereWithAggregatesInput | attendancelogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attendancelog"> | number
    employeeId?: IntWithAggregatesFilter<"attendancelog"> | number
    date?: DateTimeWithAggregatesFilter<"attendancelog"> | Date | string
    sessionId?: IntWithAggregatesFilter<"attendancelog"> | number
    actualClockIn?: DateTimeNullableWithAggregatesFilter<"attendancelog"> | Date | string | null
    actualClockOut?: DateTimeNullableWithAggregatesFilter<"attendancelog"> | Date | string | null
    status?: Enumattendancelog_statusWithAggregatesFilter<"attendancelog"> | $Enums.attendancelog_status
    createdAt?: DateTimeWithAggregatesFilter<"attendancelog"> | Date | string
  }

  export type attendancesummaryWhereInput = {
    AND?: attendancesummaryWhereInput | attendancesummaryWhereInput[]
    OR?: attendancesummaryWhereInput[]
    NOT?: attendancesummaryWhereInput | attendancesummaryWhereInput[]
    id?: IntFilter<"attendancesummary"> | number
    employeeId?: IntFilter<"attendancesummary"> | number
    date?: DateTimeFilter<"attendancesummary"> | Date | string
    status?: Enumattendancesummary_statusFilter<"attendancesummary"> | $Enums.attendancesummary_status
    lateArrival?: BoolFilter<"attendancesummary"> | boolean
    earlyDeparture?: BoolFilter<"attendancesummary"> | boolean
    unplannedAbsence?: BoolFilter<"attendancesummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"attendancesummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"attendancesummary"> | string | null
    departmentId?: IntNullableFilter<"attendancesummary"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type attendancesummaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    department?: departmentOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: attendancesummaryOrderByRelevanceInput
  }

  export type attendancesummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date?: attendancesummaryEmployeeIdDateCompoundUniqueInput
    AND?: attendancesummaryWhereInput | attendancesummaryWhereInput[]
    OR?: attendancesummaryWhereInput[]
    NOT?: attendancesummaryWhereInput | attendancesummaryWhereInput[]
    employeeId?: IntFilter<"attendancesummary"> | number
    date?: DateTimeFilter<"attendancesummary"> | Date | string
    status?: Enumattendancesummary_statusFilter<"attendancesummary"> | $Enums.attendancesummary_status
    lateArrival?: BoolFilter<"attendancesummary"> | boolean
    earlyDeparture?: BoolFilter<"attendancesummary"> | boolean
    unplannedAbsence?: BoolFilter<"attendancesummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"attendancesummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"attendancesummary"> | string | null
    departmentId?: IntNullableFilter<"attendancesummary"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id" | "employeeId_date">

  export type attendancesummaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: attendancesummaryCountOrderByAggregateInput
    _avg?: attendancesummaryAvgOrderByAggregateInput
    _max?: attendancesummaryMaxOrderByAggregateInput
    _min?: attendancesummaryMinOrderByAggregateInput
    _sum?: attendancesummarySumOrderByAggregateInput
  }

  export type attendancesummaryScalarWhereWithAggregatesInput = {
    AND?: attendancesummaryScalarWhereWithAggregatesInput | attendancesummaryScalarWhereWithAggregatesInput[]
    OR?: attendancesummaryScalarWhereWithAggregatesInput[]
    NOT?: attendancesummaryScalarWhereWithAggregatesInput | attendancesummaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attendancesummary"> | number
    employeeId?: IntWithAggregatesFilter<"attendancesummary"> | number
    date?: DateTimeWithAggregatesFilter<"attendancesummary"> | Date | string
    status?: Enumattendancesummary_statusWithAggregatesFilter<"attendancesummary"> | $Enums.attendancesummary_status
    lateArrival?: BoolWithAggregatesFilter<"attendancesummary"> | boolean
    earlyDeparture?: BoolWithAggregatesFilter<"attendancesummary"> | boolean
    unplannedAbsence?: BoolWithAggregatesFilter<"attendancesummary"> | boolean
    totalWorkHours?: DecimalNullableWithAggregatesFilter<"attendancesummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableWithAggregatesFilter<"attendancesummary"> | string | null
    departmentId?: IntNullableWithAggregatesFilter<"attendancesummary"> | number | null
  }

  export type complaintWhereInput = {
    AND?: complaintWhereInput | complaintWhereInput[]
    OR?: complaintWhereInput[]
    NOT?: complaintWhereInput | complaintWhereInput[]
    id?: IntFilter<"complaint"> | number
    employeeId?: IntFilter<"complaint"> | number
    subject?: StringFilter<"complaint"> | string
    description?: StringFilter<"complaint"> | string
    status?: Enumcomplaint_statusFilter<"complaint"> | $Enums.complaint_status
    response?: StringNullableFilter<"complaint"> | string | null
    createdAt?: DateTimeFilter<"complaint"> | Date | string
    updatedAt?: DateTimeFilter<"complaint"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type complaintOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: employeeOrderByWithRelationInput
    _relevance?: complaintOrderByRelevanceInput
  }

  export type complaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: complaintWhereInput | complaintWhereInput[]
    OR?: complaintWhereInput[]
    NOT?: complaintWhereInput | complaintWhereInput[]
    employeeId?: IntFilter<"complaint"> | number
    subject?: StringFilter<"complaint"> | string
    description?: StringFilter<"complaint"> | string
    status?: Enumcomplaint_statusFilter<"complaint"> | $Enums.complaint_status
    response?: StringNullableFilter<"complaint"> | string | null
    createdAt?: DateTimeFilter<"complaint"> | Date | string
    updatedAt?: DateTimeFilter<"complaint"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id">

  export type complaintOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: complaintCountOrderByAggregateInput
    _avg?: complaintAvgOrderByAggregateInput
    _max?: complaintMaxOrderByAggregateInput
    _min?: complaintMinOrderByAggregateInput
    _sum?: complaintSumOrderByAggregateInput
  }

  export type complaintScalarWhereWithAggregatesInput = {
    AND?: complaintScalarWhereWithAggregatesInput | complaintScalarWhereWithAggregatesInput[]
    OR?: complaintScalarWhereWithAggregatesInput[]
    NOT?: complaintScalarWhereWithAggregatesInput | complaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"complaint"> | number
    employeeId?: IntWithAggregatesFilter<"complaint"> | number
    subject?: StringWithAggregatesFilter<"complaint"> | string
    description?: StringWithAggregatesFilter<"complaint"> | string
    status?: Enumcomplaint_statusWithAggregatesFilter<"complaint"> | $Enums.complaint_status
    response?: StringNullableWithAggregatesFilter<"complaint"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"complaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"complaint"> | Date | string
  }

  export type departmentWhereInput = {
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    id?: IntFilter<"department"> | number
    name?: StringFilter<"department"> | string
    description?: StringNullableFilter<"department"> | string | null
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
    parentId?: IntNullableFilter<"department"> | number | null
    payrollPolicyId?: IntNullableFilter<"department"> | number | null
    attendancesummary?: AttendancesummaryListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    other_department?: DepartmentListRelationFilter
    payrollpolicy?: XOR<PayrollpolicyNullableScalarRelationFilter, payrollpolicyWhereInput> | null
    employee_employee_departmentIdTodepartment?: EmployeeListRelationFilter
    employee_employee_subDepartmentIdTodepartment?: EmployeeListRelationFilter
  }

  export type departmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    payrollPolicyId?: SortOrderInput | SortOrder
    attendancesummary?: attendancesummaryOrderByRelationAggregateInput
    department?: departmentOrderByWithRelationInput
    other_department?: departmentOrderByRelationAggregateInput
    payrollpolicy?: payrollpolicyOrderByWithRelationInput
    employee_employee_departmentIdTodepartment?: employeeOrderByRelationAggregateInput
    employee_employee_subDepartmentIdTodepartment?: employeeOrderByRelationAggregateInput
    _relevance?: departmentOrderByRelevanceInput
  }

  export type departmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    description?: StringNullableFilter<"department"> | string | null
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
    parentId?: IntNullableFilter<"department"> | number | null
    payrollPolicyId?: IntNullableFilter<"department"> | number | null
    attendancesummary?: AttendancesummaryListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    other_department?: DepartmentListRelationFilter
    payrollpolicy?: XOR<PayrollpolicyNullableScalarRelationFilter, payrollpolicyWhereInput> | null
    employee_employee_departmentIdTodepartment?: EmployeeListRelationFilter
    employee_employee_subDepartmentIdTodepartment?: EmployeeListRelationFilter
  }, "id" | "name">

  export type departmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    payrollPolicyId?: SortOrderInput | SortOrder
    _count?: departmentCountOrderByAggregateInput
    _avg?: departmentAvgOrderByAggregateInput
    _max?: departmentMaxOrderByAggregateInput
    _min?: departmentMinOrderByAggregateInput
    _sum?: departmentSumOrderByAggregateInput
  }

  export type departmentScalarWhereWithAggregatesInput = {
    AND?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    OR?: departmentScalarWhereWithAggregatesInput[]
    NOT?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"department"> | number
    name?: StringWithAggregatesFilter<"department"> | string
    description?: StringNullableWithAggregatesFilter<"department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"department"> | Date | string
    parentId?: IntNullableWithAggregatesFilter<"department"> | number | null
    payrollPolicyId?: IntNullableWithAggregatesFilter<"department"> | number | null
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    id?: IntFilter<"employee"> | number
    userId?: IntNullableFilter<"employee"> | number | null
    firstName?: StringFilter<"employee"> | string
    lastName?: StringFilter<"employee"> | string
    baptismalName?: StringNullableFilter<"employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"employee"> | Date | string | null
    sex?: Enumemployee_sexFilter<"employee"> | $Enums.employee_sex
    nationality?: StringNullableFilter<"employee"> | string | null
    maritalStatusId?: IntNullableFilter<"employee"> | number | null
    departmentId?: IntNullableFilter<"employee"> | number | null
    positionId?: IntNullableFilter<"employee"> | number | null
    employmentTypeId?: IntNullableFilter<"employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"employee"> | number | null
    phone?: StringNullableFilter<"employee"> | string | null
    address?: StringNullableFilter<"employee"> | string | null
    subCity?: StringNullableFilter<"employee"> | string | null
    emergencyContactName?: StringNullableFilter<"employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"employee"> | string | null
    academicQualification?: StringNullableFilter<"employee"> | string | null
    educationalInstitution?: StringNullableFilter<"employee"> | string | null
    salary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"employee"> | string | null
    agreementStatusId?: IntNullableFilter<"employee"> | number | null
    photo?: StringNullableFilter<"employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    createdAt?: DateTimeFilter<"employee"> | Date | string
    updatedAt?: DateTimeFilter<"employee"> | Date | string
    subDepartmentId?: IntNullableFilter<"employee"> | number | null
    activitylog_activitylog_actorIdToemployee?: ActivitylogListRelationFilter
    activitylog_activitylog_targetIdToemployee?: ActivitylogListRelationFilter
    attendancelog?: AttendancelogListRelationFilter
    attendancesummary?: AttendancesummaryListRelationFilter
    complaint?: ComplaintListRelationFilter
    agreementstatus?: XOR<AgreementstatusNullableScalarRelationFilter, agreementstatusWhereInput> | null
    department_employee_departmentIdTodepartment?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    employmenttype?: XOR<EmploymenttypeNullableScalarRelationFilter, employmenttypeWhereInput> | null
    jobstatus?: XOR<JobstatusNullableScalarRelationFilter, jobstatusWhereInput> | null
    maritalstatus?: XOR<MaritalstatusNullableScalarRelationFilter, maritalstatusWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, positionWhereInput> | null
    department_employee_subDepartmentIdTodepartment?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employeeshift?: EmployeeshiftListRelationFilter
    leave?: LeaveListRelationFilter
    meeting?: MeetingListRelationFilter
    overtimelog?: OvertimelogListRelationFilter
    performancereview?: PerformancereviewListRelationFilter
    salaryRecords?: SalaryListRelationFilter
    termination?: TerminationListRelationFilter
  }

  export type employeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrder
    nationality?: SortOrderInput | SortOrder
    maritalStatusId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    employmentTypeId?: SortOrderInput | SortOrder
    employmentDate?: SortOrderInput | SortOrder
    jobStatusId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subCity?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    repentanceFatherName?: SortOrderInput | SortOrder
    repentanceFatherChurch?: SortOrderInput | SortOrder
    repentanceFatherPhone?: SortOrderInput | SortOrder
    academicQualification?: SortOrderInput | SortOrder
    educationalInstitution?: SortOrderInput | SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    agreementStatusId?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subDepartmentId?: SortOrderInput | SortOrder
    activitylog_activitylog_actorIdToemployee?: activitylogOrderByRelationAggregateInput
    activitylog_activitylog_targetIdToemployee?: activitylogOrderByRelationAggregateInput
    attendancelog?: attendancelogOrderByRelationAggregateInput
    attendancesummary?: attendancesummaryOrderByRelationAggregateInput
    complaint?: complaintOrderByRelationAggregateInput
    agreementstatus?: agreementstatusOrderByWithRelationInput
    department_employee_departmentIdTodepartment?: departmentOrderByWithRelationInput
    employmenttype?: employmenttypeOrderByWithRelationInput
    jobstatus?: jobstatusOrderByWithRelationInput
    maritalstatus?: maritalstatusOrderByWithRelationInput
    position?: positionOrderByWithRelationInput
    department_employee_subDepartmentIdTodepartment?: departmentOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    employeeshift?: employeeshiftOrderByRelationAggregateInput
    leave?: leaveOrderByRelationAggregateInput
    meeting?: meetingOrderByRelationAggregateInput
    overtimelog?: overtimelogOrderByRelationAggregateInput
    performancereview?: performancereviewOrderByRelationAggregateInput
    salaryRecords?: salaryOrderByRelationAggregateInput
    termination?: terminationOrderByRelationAggregateInput
    _relevance?: employeeOrderByRelevanceInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    firstName?: StringFilter<"employee"> | string
    lastName?: StringFilter<"employee"> | string
    baptismalName?: StringNullableFilter<"employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"employee"> | Date | string | null
    sex?: Enumemployee_sexFilter<"employee"> | $Enums.employee_sex
    nationality?: StringNullableFilter<"employee"> | string | null
    maritalStatusId?: IntNullableFilter<"employee"> | number | null
    departmentId?: IntNullableFilter<"employee"> | number | null
    positionId?: IntNullableFilter<"employee"> | number | null
    employmentTypeId?: IntNullableFilter<"employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"employee"> | number | null
    phone?: StringNullableFilter<"employee"> | string | null
    address?: StringNullableFilter<"employee"> | string | null
    subCity?: StringNullableFilter<"employee"> | string | null
    emergencyContactName?: StringNullableFilter<"employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"employee"> | string | null
    academicQualification?: StringNullableFilter<"employee"> | string | null
    educationalInstitution?: StringNullableFilter<"employee"> | string | null
    salary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"employee"> | string | null
    agreementStatusId?: IntNullableFilter<"employee"> | number | null
    photo?: StringNullableFilter<"employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    createdAt?: DateTimeFilter<"employee"> | Date | string
    updatedAt?: DateTimeFilter<"employee"> | Date | string
    subDepartmentId?: IntNullableFilter<"employee"> | number | null
    activitylog_activitylog_actorIdToemployee?: ActivitylogListRelationFilter
    activitylog_activitylog_targetIdToemployee?: ActivitylogListRelationFilter
    attendancelog?: AttendancelogListRelationFilter
    attendancesummary?: AttendancesummaryListRelationFilter
    complaint?: ComplaintListRelationFilter
    agreementstatus?: XOR<AgreementstatusNullableScalarRelationFilter, agreementstatusWhereInput> | null
    department_employee_departmentIdTodepartment?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    employmenttype?: XOR<EmploymenttypeNullableScalarRelationFilter, employmenttypeWhereInput> | null
    jobstatus?: XOR<JobstatusNullableScalarRelationFilter, jobstatusWhereInput> | null
    maritalstatus?: XOR<MaritalstatusNullableScalarRelationFilter, maritalstatusWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, positionWhereInput> | null
    department_employee_subDepartmentIdTodepartment?: XOR<DepartmentNullableScalarRelationFilter, departmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employeeshift?: EmployeeshiftListRelationFilter
    leave?: LeaveListRelationFilter
    meeting?: MeetingListRelationFilter
    overtimelog?: OvertimelogListRelationFilter
    performancereview?: PerformancereviewListRelationFilter
    salaryRecords?: SalaryListRelationFilter
    termination?: TerminationListRelationFilter
  }, "id" | "userId">

  export type employeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrder
    nationality?: SortOrderInput | SortOrder
    maritalStatusId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    employmentTypeId?: SortOrderInput | SortOrder
    employmentDate?: SortOrderInput | SortOrder
    jobStatusId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subCity?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    repentanceFatherName?: SortOrderInput | SortOrder
    repentanceFatherChurch?: SortOrderInput | SortOrder
    repentanceFatherPhone?: SortOrderInput | SortOrder
    academicQualification?: SortOrderInput | SortOrder
    educationalInstitution?: SortOrderInput | SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    agreementStatusId?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subDepartmentId?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _avg?: employeeAvgOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
    _sum?: employeeSumOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employee"> | number
    userId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    firstName?: StringWithAggregatesFilter<"employee"> | string
    lastName?: StringWithAggregatesFilter<"employee"> | string
    baptismalName?: StringNullableWithAggregatesFilter<"employee"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    sex?: Enumemployee_sexWithAggregatesFilter<"employee"> | $Enums.employee_sex
    nationality?: StringNullableWithAggregatesFilter<"employee"> | string | null
    maritalStatusId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    departmentId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    positionId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    employmentTypeId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    employmentDate?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    jobStatusId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    phone?: StringNullableWithAggregatesFilter<"employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"employee"> | string | null
    subCity?: StringNullableWithAggregatesFilter<"employee"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"employee"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"employee"> | string | null
    repentanceFatherName?: StringNullableWithAggregatesFilter<"employee"> | string | null
    repentanceFatherChurch?: StringNullableWithAggregatesFilter<"employee"> | string | null
    repentanceFatherPhone?: StringNullableWithAggregatesFilter<"employee"> | string | null
    academicQualification?: StringNullableWithAggregatesFilter<"employee"> | string | null
    educationalInstitution?: StringNullableWithAggregatesFilter<"employee"> | string | null
    salary?: DecimalWithAggregatesFilter<"employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalWithAggregatesFilter<"employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableWithAggregatesFilter<"employee"> | string | null
    agreementStatusId?: IntNullableWithAggregatesFilter<"employee"> | number | null
    photo?: StringNullableWithAggregatesFilter<"employee"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"employee"> | Date | string
    subDepartmentId?: IntNullableWithAggregatesFilter<"employee"> | number | null
  }

  export type employeeshiftWhereInput = {
    AND?: employeeshiftWhereInput | employeeshiftWhereInput[]
    OR?: employeeshiftWhereInput[]
    NOT?: employeeshiftWhereInput | employeeshiftWhereInput[]
    id?: IntFilter<"employeeshift"> | number
    employeeId?: IntFilter<"employeeshift"> | number
    shiftId?: IntFilter<"employeeshift"> | number
    effectiveFrom?: DateTimeFilter<"employeeshift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"employeeshift"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, shiftWhereInput>
  }

  export type employeeshiftOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    employee?: employeeOrderByWithRelationInput
    shift?: shiftOrderByWithRelationInput
  }

  export type employeeshiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: employeeshiftWhereInput | employeeshiftWhereInput[]
    OR?: employeeshiftWhereInput[]
    NOT?: employeeshiftWhereInput | employeeshiftWhereInput[]
    employeeId?: IntFilter<"employeeshift"> | number
    shiftId?: IntFilter<"employeeshift"> | number
    effectiveFrom?: DateTimeFilter<"employeeshift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"employeeshift"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, shiftWhereInput>
  }, "id">

  export type employeeshiftOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    _count?: employeeshiftCountOrderByAggregateInput
    _avg?: employeeshiftAvgOrderByAggregateInput
    _max?: employeeshiftMaxOrderByAggregateInput
    _min?: employeeshiftMinOrderByAggregateInput
    _sum?: employeeshiftSumOrderByAggregateInput
  }

  export type employeeshiftScalarWhereWithAggregatesInput = {
    AND?: employeeshiftScalarWhereWithAggregatesInput | employeeshiftScalarWhereWithAggregatesInput[]
    OR?: employeeshiftScalarWhereWithAggregatesInput[]
    NOT?: employeeshiftScalarWhereWithAggregatesInput | employeeshiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employeeshift"> | number
    employeeId?: IntWithAggregatesFilter<"employeeshift"> | number
    shiftId?: IntWithAggregatesFilter<"employeeshift"> | number
    effectiveFrom?: DateTimeWithAggregatesFilter<"employeeshift"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"employeeshift"> | Date | string | null
  }

  export type employmenttypeWhereInput = {
    AND?: employmenttypeWhereInput | employmenttypeWhereInput[]
    OR?: employmenttypeWhereInput[]
    NOT?: employmenttypeWhereInput | employmenttypeWhereInput[]
    id?: IntFilter<"employmenttype"> | number
    type?: StringFilter<"employmenttype"> | string
    employee?: EmployeeListRelationFilter
  }

  export type employmenttypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
    _relevance?: employmenttypeOrderByRelevanceInput
  }

  export type employmenttypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: string
    AND?: employmenttypeWhereInput | employmenttypeWhereInput[]
    OR?: employmenttypeWhereInput[]
    NOT?: employmenttypeWhereInput | employmenttypeWhereInput[]
    employee?: EmployeeListRelationFilter
  }, "id" | "type">

  export type employmenttypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: employmenttypeCountOrderByAggregateInput
    _avg?: employmenttypeAvgOrderByAggregateInput
    _max?: employmenttypeMaxOrderByAggregateInput
    _min?: employmenttypeMinOrderByAggregateInput
    _sum?: employmenttypeSumOrderByAggregateInput
  }

  export type employmenttypeScalarWhereWithAggregatesInput = {
    AND?: employmenttypeScalarWhereWithAggregatesInput | employmenttypeScalarWhereWithAggregatesInput[]
    OR?: employmenttypeScalarWhereWithAggregatesInput[]
    NOT?: employmenttypeScalarWhereWithAggregatesInput | employmenttypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employmenttype"> | number
    type?: StringWithAggregatesFilter<"employmenttype"> | string
  }

  export type holidayWhereInput = {
    AND?: holidayWhereInput | holidayWhereInput[]
    OR?: holidayWhereInput[]
    NOT?: holidayWhereInput | holidayWhereInput[]
    id?: IntFilter<"holiday"> | number
    name?: StringFilter<"holiday"> | string
    date?: DateTimeFilter<"holiday"> | Date | string
    isPublic?: BoolFilter<"holiday"> | boolean
    description?: StringNullableFilter<"holiday"> | string | null
  }

  export type holidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrderInput | SortOrder
    _relevance?: holidayOrderByRelevanceInput
  }

  export type holidayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    date?: Date | string
    AND?: holidayWhereInput | holidayWhereInput[]
    OR?: holidayWhereInput[]
    NOT?: holidayWhereInput | holidayWhereInput[]
    name?: StringFilter<"holiday"> | string
    isPublic?: BoolFilter<"holiday"> | boolean
    description?: StringNullableFilter<"holiday"> | string | null
  }, "id" | "date">

  export type holidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: holidayCountOrderByAggregateInput
    _avg?: holidayAvgOrderByAggregateInput
    _max?: holidayMaxOrderByAggregateInput
    _min?: holidayMinOrderByAggregateInput
    _sum?: holidaySumOrderByAggregateInput
  }

  export type holidayScalarWhereWithAggregatesInput = {
    AND?: holidayScalarWhereWithAggregatesInput | holidayScalarWhereWithAggregatesInput[]
    OR?: holidayScalarWhereWithAggregatesInput[]
    NOT?: holidayScalarWhereWithAggregatesInput | holidayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"holiday"> | number
    name?: StringWithAggregatesFilter<"holiday"> | string
    date?: DateTimeWithAggregatesFilter<"holiday"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"holiday"> | boolean
    description?: StringNullableWithAggregatesFilter<"holiday"> | string | null
  }

  export type interviewWhereInput = {
    AND?: interviewWhereInput | interviewWhereInput[]
    OR?: interviewWhereInput[]
    NOT?: interviewWhereInput | interviewWhereInput[]
    id?: IntFilter<"interview"> | number
    candidateName?: StringFilter<"interview"> | string
    position?: StringNullableFilter<"interview"> | string | null
    interviewDate?: DateTimeNullableFilter<"interview"> | Date | string | null
    result?: Enuminterview_resultFilter<"interview"> | $Enums.interview_result
    comments?: StringNullableFilter<"interview"> | string | null
    createdAt?: DateTimeFilter<"interview"> | Date | string
    updatedAt?: DateTimeFilter<"interview"> | Date | string
  }

  export type interviewOrderByWithRelationInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrderInput | SortOrder
    interviewDate?: SortOrderInput | SortOrder
    result?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: interviewOrderByRelevanceInput
  }

  export type interviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: interviewWhereInput | interviewWhereInput[]
    OR?: interviewWhereInput[]
    NOT?: interviewWhereInput | interviewWhereInput[]
    candidateName?: StringFilter<"interview"> | string
    position?: StringNullableFilter<"interview"> | string | null
    interviewDate?: DateTimeNullableFilter<"interview"> | Date | string | null
    result?: Enuminterview_resultFilter<"interview"> | $Enums.interview_result
    comments?: StringNullableFilter<"interview"> | string | null
    createdAt?: DateTimeFilter<"interview"> | Date | string
    updatedAt?: DateTimeFilter<"interview"> | Date | string
  }, "id">

  export type interviewOrderByWithAggregationInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrderInput | SortOrder
    interviewDate?: SortOrderInput | SortOrder
    result?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: interviewCountOrderByAggregateInput
    _avg?: interviewAvgOrderByAggregateInput
    _max?: interviewMaxOrderByAggregateInput
    _min?: interviewMinOrderByAggregateInput
    _sum?: interviewSumOrderByAggregateInput
  }

  export type interviewScalarWhereWithAggregatesInput = {
    AND?: interviewScalarWhereWithAggregatesInput | interviewScalarWhereWithAggregatesInput[]
    OR?: interviewScalarWhereWithAggregatesInput[]
    NOT?: interviewScalarWhereWithAggregatesInput | interviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"interview"> | number
    candidateName?: StringWithAggregatesFilter<"interview"> | string
    position?: StringNullableWithAggregatesFilter<"interview"> | string | null
    interviewDate?: DateTimeNullableWithAggregatesFilter<"interview"> | Date | string | null
    result?: Enuminterview_resultWithAggregatesFilter<"interview"> | $Enums.interview_result
    comments?: StringNullableWithAggregatesFilter<"interview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"interview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"interview"> | Date | string
  }

  export type jobstatusWhereInput = {
    AND?: jobstatusWhereInput | jobstatusWhereInput[]
    OR?: jobstatusWhereInput[]
    NOT?: jobstatusWhereInput | jobstatusWhereInput[]
    id?: IntFilter<"jobstatus"> | number
    status?: StringFilter<"jobstatus"> | string
    employee?: EmployeeListRelationFilter
  }

  export type jobstatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
    _relevance?: jobstatusOrderByRelevanceInput
  }

  export type jobstatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: jobstatusWhereInput | jobstatusWhereInput[]
    OR?: jobstatusWhereInput[]
    NOT?: jobstatusWhereInput | jobstatusWhereInput[]
    employee?: EmployeeListRelationFilter
  }, "id" | "status">

  export type jobstatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: jobstatusCountOrderByAggregateInput
    _avg?: jobstatusAvgOrderByAggregateInput
    _max?: jobstatusMaxOrderByAggregateInput
    _min?: jobstatusMinOrderByAggregateInput
    _sum?: jobstatusSumOrderByAggregateInput
  }

  export type jobstatusScalarWhereWithAggregatesInput = {
    AND?: jobstatusScalarWhereWithAggregatesInput | jobstatusScalarWhereWithAggregatesInput[]
    OR?: jobstatusScalarWhereWithAggregatesInput[]
    NOT?: jobstatusScalarWhereWithAggregatesInput | jobstatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobstatus"> | number
    status?: StringWithAggregatesFilter<"jobstatus"> | string
  }

  export type leaveWhereInput = {
    AND?: leaveWhereInput | leaveWhereInput[]
    OR?: leaveWhereInput[]
    NOT?: leaveWhereInput | leaveWhereInput[]
    id?: IntFilter<"leave"> | number
    employeeId?: IntFilter<"leave"> | number
    leaveType?: Enumleave_leaveTypeFilter<"leave"> | $Enums.leave_leaveType
    startDate?: DateTimeFilter<"leave"> | Date | string
    endDate?: DateTimeFilter<"leave"> | Date | string
    status?: Enumleave_statusFilter<"leave"> | $Enums.leave_status
    reason?: StringNullableFilter<"leave"> | string | null
    approvedBy?: IntNullableFilter<"leave"> | number | null
    requestedAt?: DateTimeFilter<"leave"> | Date | string
    updatedAt?: DateTimeFilter<"leave"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type leaveOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: leaveOrderByRelevanceInput
  }

  export type leaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: leaveWhereInput | leaveWhereInput[]
    OR?: leaveWhereInput[]
    NOT?: leaveWhereInput | leaveWhereInput[]
    employeeId?: IntFilter<"leave"> | number
    leaveType?: Enumleave_leaveTypeFilter<"leave"> | $Enums.leave_leaveType
    startDate?: DateTimeFilter<"leave"> | Date | string
    endDate?: DateTimeFilter<"leave"> | Date | string
    status?: Enumleave_statusFilter<"leave"> | $Enums.leave_status
    reason?: StringNullableFilter<"leave"> | string | null
    approvedBy?: IntNullableFilter<"leave"> | number | null
    requestedAt?: DateTimeFilter<"leave"> | Date | string
    updatedAt?: DateTimeFilter<"leave"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id">

  export type leaveOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: leaveCountOrderByAggregateInput
    _avg?: leaveAvgOrderByAggregateInput
    _max?: leaveMaxOrderByAggregateInput
    _min?: leaveMinOrderByAggregateInput
    _sum?: leaveSumOrderByAggregateInput
  }

  export type leaveScalarWhereWithAggregatesInput = {
    AND?: leaveScalarWhereWithAggregatesInput | leaveScalarWhereWithAggregatesInput[]
    OR?: leaveScalarWhereWithAggregatesInput[]
    NOT?: leaveScalarWhereWithAggregatesInput | leaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"leave"> | number
    employeeId?: IntWithAggregatesFilter<"leave"> | number
    leaveType?: Enumleave_leaveTypeWithAggregatesFilter<"leave"> | $Enums.leave_leaveType
    startDate?: DateTimeWithAggregatesFilter<"leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"leave"> | Date | string
    status?: Enumleave_statusWithAggregatesFilter<"leave"> | $Enums.leave_status
    reason?: StringNullableWithAggregatesFilter<"leave"> | string | null
    approvedBy?: IntNullableWithAggregatesFilter<"leave"> | number | null
    requestedAt?: DateTimeWithAggregatesFilter<"leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"leave"> | Date | string
  }

  export type maritalstatusWhereInput = {
    AND?: maritalstatusWhereInput | maritalstatusWhereInput[]
    OR?: maritalstatusWhereInput[]
    NOT?: maritalstatusWhereInput | maritalstatusWhereInput[]
    id?: IntFilter<"maritalstatus"> | number
    status?: StringFilter<"maritalstatus"> | string
    employee?: EmployeeListRelationFilter
  }

  export type maritalstatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
    _relevance?: maritalstatusOrderByRelevanceInput
  }

  export type maritalstatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: maritalstatusWhereInput | maritalstatusWhereInput[]
    OR?: maritalstatusWhereInput[]
    NOT?: maritalstatusWhereInput | maritalstatusWhereInput[]
    employee?: EmployeeListRelationFilter
  }, "id" | "status">

  export type maritalstatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: maritalstatusCountOrderByAggregateInput
    _avg?: maritalstatusAvgOrderByAggregateInput
    _max?: maritalstatusMaxOrderByAggregateInput
    _min?: maritalstatusMinOrderByAggregateInput
    _sum?: maritalstatusSumOrderByAggregateInput
  }

  export type maritalstatusScalarWhereWithAggregatesInput = {
    AND?: maritalstatusScalarWhereWithAggregatesInput | maritalstatusScalarWhereWithAggregatesInput[]
    OR?: maritalstatusScalarWhereWithAggregatesInput[]
    NOT?: maritalstatusScalarWhereWithAggregatesInput | maritalstatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"maritalstatus"> | number
    status?: StringWithAggregatesFilter<"maritalstatus"> | string
  }

  export type meetingWhereInput = {
    AND?: meetingWhereInput | meetingWhereInput[]
    OR?: meetingWhereInput[]
    NOT?: meetingWhereInput | meetingWhereInput[]
    id?: IntFilter<"meeting"> | number
    title?: StringFilter<"meeting"> | string
    description?: StringNullableFilter<"meeting"> | string | null
    date?: DateTimeFilter<"meeting"> | Date | string
    time?: StringFilter<"meeting"> | string
    creatorId?: IntNullableFilter<"meeting"> | number | null
    createdAt?: DateTimeFilter<"meeting"> | Date | string
    updatedAt?: DateTimeFilter<"meeting"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }

  export type meetingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: employeeOrderByWithRelationInput
    _relevance?: meetingOrderByRelevanceInput
  }

  export type meetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: meetingWhereInput | meetingWhereInput[]
    OR?: meetingWhereInput[]
    NOT?: meetingWhereInput | meetingWhereInput[]
    title?: StringFilter<"meeting"> | string
    description?: StringNullableFilter<"meeting"> | string | null
    date?: DateTimeFilter<"meeting"> | Date | string
    time?: StringFilter<"meeting"> | string
    creatorId?: IntNullableFilter<"meeting"> | number | null
    createdAt?: DateTimeFilter<"meeting"> | Date | string
    updatedAt?: DateTimeFilter<"meeting"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
  }, "id">

  export type meetingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: meetingCountOrderByAggregateInput
    _avg?: meetingAvgOrderByAggregateInput
    _max?: meetingMaxOrderByAggregateInput
    _min?: meetingMinOrderByAggregateInput
    _sum?: meetingSumOrderByAggregateInput
  }

  export type meetingScalarWhereWithAggregatesInput = {
    AND?: meetingScalarWhereWithAggregatesInput | meetingScalarWhereWithAggregatesInput[]
    OR?: meetingScalarWhereWithAggregatesInput[]
    NOT?: meetingScalarWhereWithAggregatesInput | meetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"meeting"> | number
    title?: StringWithAggregatesFilter<"meeting"> | string
    description?: StringNullableWithAggregatesFilter<"meeting"> | string | null
    date?: DateTimeWithAggregatesFilter<"meeting"> | Date | string
    time?: StringWithAggregatesFilter<"meeting"> | string
    creatorId?: IntNullableWithAggregatesFilter<"meeting"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"meeting"> | Date | string
  }

  export type overtimelogWhereInput = {
    AND?: overtimelogWhereInput | overtimelogWhereInput[]
    OR?: overtimelogWhereInput[]
    NOT?: overtimelogWhereInput | overtimelogWhereInput[]
    id?: IntFilter<"overtimelog"> | number
    employeeId?: IntFilter<"overtimelog"> | number
    date?: DateTimeFilter<"overtimelog"> | Date | string
    hours?: DecimalNullableFilter<"overtimelog"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"overtimelog"> | string | null
    approvedBy?: IntNullableFilter<"overtimelog"> | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFilter<"overtimelog"> | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFilter<"overtimelog"> | $Enums.overtimelog_compensationMethod
    endTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    startTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFilter<"overtimelog"> | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFilter<"overtimelog"> | Date | string
    updatedAt?: DateTimeFilter<"overtimelog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type overtimelogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    endTime?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    overtimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: userOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    _relevance?: overtimelogOrderByRelevanceInput
  }

  export type overtimelogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: overtimelogWhereInput | overtimelogWhereInput[]
    OR?: overtimelogWhereInput[]
    NOT?: overtimelogWhereInput | overtimelogWhereInput[]
    employeeId?: IntFilter<"overtimelog"> | number
    date?: DateTimeFilter<"overtimelog"> | Date | string
    hours?: DecimalNullableFilter<"overtimelog"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"overtimelog"> | string | null
    approvedBy?: IntNullableFilter<"overtimelog"> | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFilter<"overtimelog"> | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFilter<"overtimelog"> | $Enums.overtimelog_compensationMethod
    endTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    startTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFilter<"overtimelog"> | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFilter<"overtimelog"> | Date | string
    updatedAt?: DateTimeFilter<"overtimelog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id">

  export type overtimelogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    endTime?: SortOrderInput | SortOrder
    startTime?: SortOrderInput | SortOrder
    overtimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: overtimelogCountOrderByAggregateInput
    _avg?: overtimelogAvgOrderByAggregateInput
    _max?: overtimelogMaxOrderByAggregateInput
    _min?: overtimelogMinOrderByAggregateInput
    _sum?: overtimelogSumOrderByAggregateInput
  }

  export type overtimelogScalarWhereWithAggregatesInput = {
    AND?: overtimelogScalarWhereWithAggregatesInput | overtimelogScalarWhereWithAggregatesInput[]
    OR?: overtimelogScalarWhereWithAggregatesInput[]
    NOT?: overtimelogScalarWhereWithAggregatesInput | overtimelogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"overtimelog"> | number
    employeeId?: IntWithAggregatesFilter<"overtimelog"> | number
    date?: DateTimeWithAggregatesFilter<"overtimelog"> | Date | string
    hours?: DecimalNullableWithAggregatesFilter<"overtimelog"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableWithAggregatesFilter<"overtimelog"> | string | null
    approvedBy?: IntNullableWithAggregatesFilter<"overtimelog"> | number | null
    approvalStatus?: Enumovertimelog_approvalStatusWithAggregatesFilter<"overtimelog"> | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodWithAggregatesFilter<"overtimelog"> | $Enums.overtimelog_compensationMethod
    endTime?: DateTimeNullableWithAggregatesFilter<"overtimelog"> | Date | string | null
    startTime?: DateTimeNullableWithAggregatesFilter<"overtimelog"> | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeWithAggregatesFilter<"overtimelog"> | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeWithAggregatesFilter<"overtimelog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"overtimelog"> | Date | string
  }

  export type payrollpolicyWhereInput = {
    AND?: payrollpolicyWhereInput | payrollpolicyWhereInput[]
    OR?: payrollpolicyWhereInput[]
    NOT?: payrollpolicyWhereInput | payrollpolicyWhereInput[]
    id?: IntFilter<"payrollpolicy"> | number
    name?: StringFilter<"payrollpolicy"> | string
    isDefault?: BoolFilter<"payrollpolicy"> | boolean
    otMultiplierWeekday1?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"payrollpolicy"> | Date | string
    updatedAt?: DateTimeFilter<"payrollpolicy"> | Date | string
    otMultiplierSleepover?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    department?: DepartmentListRelationFilter
  }

  export type payrollpolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otMultiplierSleepover?: SortOrder
    department?: departmentOrderByRelationAggregateInput
    _relevance?: payrollpolicyOrderByRelevanceInput
  }

  export type payrollpolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: payrollpolicyWhereInput | payrollpolicyWhereInput[]
    OR?: payrollpolicyWhereInput[]
    NOT?: payrollpolicyWhereInput | payrollpolicyWhereInput[]
    isDefault?: BoolFilter<"payrollpolicy"> | boolean
    otMultiplierWeekday1?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"payrollpolicy"> | Date | string
    updatedAt?: DateTimeFilter<"payrollpolicy"> | Date | string
    otMultiplierSleepover?: DecimalFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    department?: DepartmentListRelationFilter
  }, "id" | "name">

  export type payrollpolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otMultiplierSleepover?: SortOrder
    _count?: payrollpolicyCountOrderByAggregateInput
    _avg?: payrollpolicyAvgOrderByAggregateInput
    _max?: payrollpolicyMaxOrderByAggregateInput
    _min?: payrollpolicyMinOrderByAggregateInput
    _sum?: payrollpolicySumOrderByAggregateInput
  }

  export type payrollpolicyScalarWhereWithAggregatesInput = {
    AND?: payrollpolicyScalarWhereWithAggregatesInput | payrollpolicyScalarWhereWithAggregatesInput[]
    OR?: payrollpolicyScalarWhereWithAggregatesInput[]
    NOT?: payrollpolicyScalarWhereWithAggregatesInput | payrollpolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payrollpolicy"> | number
    name?: StringWithAggregatesFilter<"payrollpolicy"> | string
    isDefault?: BoolWithAggregatesFilter<"payrollpolicy"> | boolean
    otMultiplierWeekday1?: DecimalWithAggregatesFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalWithAggregatesFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalWithAggregatesFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalWithAggregatesFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"payrollpolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"payrollpolicy"> | Date | string
    otMultiplierSleepover?: DecimalWithAggregatesFilter<"payrollpolicy"> | Decimal | DecimalJsLike | number | string
  }

  export type performancereviewWhereInput = {
    AND?: performancereviewWhereInput | performancereviewWhereInput[]
    OR?: performancereviewWhereInput[]
    NOT?: performancereviewWhereInput | performancereviewWhereInput[]
    id?: IntFilter<"performancereview"> | number
    employeeId?: IntFilter<"performancereview"> | number
    reviewDate?: DateTimeFilter<"performancereview"> | Date | string
    reviewerName?: StringNullableFilter<"performancereview"> | string | null
    score?: IntNullableFilter<"performancereview"> | number | null
    comments?: StringNullableFilter<"performancereview"> | string | null
    createdAt?: DateTimeFilter<"performancereview"> | Date | string
    updatedAt?: DateTimeFilter<"performancereview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type performancereviewOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: employeeOrderByWithRelationInput
    _relevance?: performancereviewOrderByRelevanceInput
  }

  export type performancereviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: performancereviewWhereInput | performancereviewWhereInput[]
    OR?: performancereviewWhereInput[]
    NOT?: performancereviewWhereInput | performancereviewWhereInput[]
    employeeId?: IntFilter<"performancereview"> | number
    reviewDate?: DateTimeFilter<"performancereview"> | Date | string
    reviewerName?: StringNullableFilter<"performancereview"> | string | null
    score?: IntNullableFilter<"performancereview"> | number | null
    comments?: StringNullableFilter<"performancereview"> | string | null
    createdAt?: DateTimeFilter<"performancereview"> | Date | string
    updatedAt?: DateTimeFilter<"performancereview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id">

  export type performancereviewOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: performancereviewCountOrderByAggregateInput
    _avg?: performancereviewAvgOrderByAggregateInput
    _max?: performancereviewMaxOrderByAggregateInput
    _min?: performancereviewMinOrderByAggregateInput
    _sum?: performancereviewSumOrderByAggregateInput
  }

  export type performancereviewScalarWhereWithAggregatesInput = {
    AND?: performancereviewScalarWhereWithAggregatesInput | performancereviewScalarWhereWithAggregatesInput[]
    OR?: performancereviewScalarWhereWithAggregatesInput[]
    NOT?: performancereviewScalarWhereWithAggregatesInput | performancereviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"performancereview"> | number
    employeeId?: IntWithAggregatesFilter<"performancereview"> | number
    reviewDate?: DateTimeWithAggregatesFilter<"performancereview"> | Date | string
    reviewerName?: StringNullableWithAggregatesFilter<"performancereview"> | string | null
    score?: IntNullableWithAggregatesFilter<"performancereview"> | number | null
    comments?: StringNullableWithAggregatesFilter<"performancereview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"performancereview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"performancereview"> | Date | string
  }

  export type positionWhereInput = {
    AND?: positionWhereInput | positionWhereInput[]
    OR?: positionWhereInput[]
    NOT?: positionWhereInput | positionWhereInput[]
    id?: IntFilter<"position"> | number
    name?: StringFilter<"position"> | string
    description?: StringNullableFilter<"position"> | string | null
    createdAt?: DateTimeFilter<"position"> | Date | string
    updatedAt?: DateTimeFilter<"position"> | Date | string
    employee?: EmployeeListRelationFilter
  }

  export type positionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: employeeOrderByRelationAggregateInput
    _relevance?: positionOrderByRelevanceInput
  }

  export type positionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: positionWhereInput | positionWhereInput[]
    OR?: positionWhereInput[]
    NOT?: positionWhereInput | positionWhereInput[]
    description?: StringNullableFilter<"position"> | string | null
    createdAt?: DateTimeFilter<"position"> | Date | string
    updatedAt?: DateTimeFilter<"position"> | Date | string
    employee?: EmployeeListRelationFilter
  }, "id" | "name">

  export type positionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: positionCountOrderByAggregateInput
    _avg?: positionAvgOrderByAggregateInput
    _max?: positionMaxOrderByAggregateInput
    _min?: positionMinOrderByAggregateInput
    _sum?: positionSumOrderByAggregateInput
  }

  export type positionScalarWhereWithAggregatesInput = {
    AND?: positionScalarWhereWithAggregatesInput | positionScalarWhereWithAggregatesInput[]
    OR?: positionScalarWhereWithAggregatesInput[]
    NOT?: positionScalarWhereWithAggregatesInput | positionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"position"> | number
    name?: StringWithAggregatesFilter<"position"> | string
    description?: StringNullableWithAggregatesFilter<"position"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"position"> | Date | string
  }

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    id?: IntFilter<"role"> | number
    name?: StringFilter<"role"> | string
    description?: StringNullableFilter<"role"> | string | null
    createdAt?: DateTimeFilter<"role"> | Date | string
    updatedAt?: DateTimeFilter<"role"> | Date | string
    userrole?: UserroleListRelationFilter
  }

  export type roleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userrole?: userroleOrderByRelationAggregateInput
    _relevance?: roleOrderByRelevanceInput
  }

  export type roleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: roleWhereInput | roleWhereInput[]
    OR?: roleWhereInput[]
    NOT?: roleWhereInput | roleWhereInput[]
    description?: StringNullableFilter<"role"> | string | null
    createdAt?: DateTimeFilter<"role"> | Date | string
    updatedAt?: DateTimeFilter<"role"> | Date | string
    userrole?: UserroleListRelationFilter
  }, "id" | "name">

  export type roleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: roleCountOrderByAggregateInput
    _avg?: roleAvgOrderByAggregateInput
    _max?: roleMaxOrderByAggregateInput
    _min?: roleMinOrderByAggregateInput
    _sum?: roleSumOrderByAggregateInput
  }

  export type roleScalarWhereWithAggregatesInput = {
    AND?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    OR?: roleScalarWhereWithAggregatesInput[]
    NOT?: roleScalarWhereWithAggregatesInput | roleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"role"> | number
    name?: StringWithAggregatesFilter<"role"> | string
    description?: StringNullableWithAggregatesFilter<"role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"role"> | Date | string
  }

  export type salaryWhereInput = {
    AND?: salaryWhereInput | salaryWhereInput[]
    OR?: salaryWhereInput[]
    NOT?: salaryWhereInput | salaryWhereInput[]
    id?: IntFilter<"salary"> | number
    employeeId?: IntFilter<"salary"> | number
    salaryMonth?: DateTimeFilter<"salary"> | Date | string
    amount?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFilter<"salary"> | $Enums.salary_status
    overtimeHours?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"salary"> | Date | string | null
    createdAt?: DateTimeFilter<"salary"> | Date | string
    updatedAt?: DateTimeFilter<"salary"> | Date | string
    baseSalary?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type salaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
    employee?: employeeOrderByWithRelationInput
  }

  export type salaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_salaryMonth?: salaryEmployeeIdSalaryMonthCompoundUniqueInput
    AND?: salaryWhereInput | salaryWhereInput[]
    OR?: salaryWhereInput[]
    NOT?: salaryWhereInput | salaryWhereInput[]
    employeeId?: IntFilter<"salary"> | number
    salaryMonth?: DateTimeFilter<"salary"> | Date | string
    amount?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFilter<"salary"> | $Enums.salary_status
    overtimeHours?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"salary"> | Date | string | null
    createdAt?: DateTimeFilter<"salary"> | Date | string
    updatedAt?: DateTimeFilter<"salary"> | Date | string
    baseSalary?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id" | "employeeId_salaryMonth">

  export type salaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
    _count?: salaryCountOrderByAggregateInput
    _avg?: salaryAvgOrderByAggregateInput
    _max?: salaryMaxOrderByAggregateInput
    _min?: salaryMinOrderByAggregateInput
    _sum?: salarySumOrderByAggregateInput
  }

  export type salaryScalarWhereWithAggregatesInput = {
    AND?: salaryScalarWhereWithAggregatesInput | salaryScalarWhereWithAggregatesInput[]
    OR?: salaryScalarWhereWithAggregatesInput[]
    NOT?: salaryScalarWhereWithAggregatesInput | salaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"salary"> | number
    employeeId?: IntWithAggregatesFilter<"salary"> | number
    salaryMonth?: DateTimeWithAggregatesFilter<"salary"> | Date | string
    amount?: DecimalWithAggregatesFilter<"salary"> | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusWithAggregatesFilter<"salary"> | $Enums.salary_status
    overtimeHours?: DecimalWithAggregatesFilter<"salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalWithAggregatesFilter<"salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"salary"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"salary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"salary"> | Date | string
    baseSalary?: DecimalWithAggregatesFilter<"salary"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalWithAggregatesFilter<"salary"> | Decimal | DecimalJsLike | number | string
  }

  export type sessiondefinitionWhereInput = {
    AND?: sessiondefinitionWhereInput | sessiondefinitionWhereInput[]
    OR?: sessiondefinitionWhereInput[]
    NOT?: sessiondefinitionWhereInput | sessiondefinitionWhereInput[]
    id?: IntFilter<"sessiondefinition"> | number
    sessionNumber?: IntFilter<"sessiondefinition"> | number
    expectedClockIn?: DateTimeFilter<"sessiondefinition"> | Date | string
    expectedClockOut?: DateTimeFilter<"sessiondefinition"> | Date | string
    attendancelog?: AttendancelogListRelationFilter
  }

  export type sessiondefinitionOrderByWithRelationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
    attendancelog?: attendancelogOrderByRelationAggregateInput
  }

  export type sessiondefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionNumber?: number
    AND?: sessiondefinitionWhereInput | sessiondefinitionWhereInput[]
    OR?: sessiondefinitionWhereInput[]
    NOT?: sessiondefinitionWhereInput | sessiondefinitionWhereInput[]
    expectedClockIn?: DateTimeFilter<"sessiondefinition"> | Date | string
    expectedClockOut?: DateTimeFilter<"sessiondefinition"> | Date | string
    attendancelog?: AttendancelogListRelationFilter
  }, "id" | "sessionNumber">

  export type sessiondefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
    _count?: sessiondefinitionCountOrderByAggregateInput
    _avg?: sessiondefinitionAvgOrderByAggregateInput
    _max?: sessiondefinitionMaxOrderByAggregateInput
    _min?: sessiondefinitionMinOrderByAggregateInput
    _sum?: sessiondefinitionSumOrderByAggregateInput
  }

  export type sessiondefinitionScalarWhereWithAggregatesInput = {
    AND?: sessiondefinitionScalarWhereWithAggregatesInput | sessiondefinitionScalarWhereWithAggregatesInput[]
    OR?: sessiondefinitionScalarWhereWithAggregatesInput[]
    NOT?: sessiondefinitionScalarWhereWithAggregatesInput | sessiondefinitionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sessiondefinition"> | number
    sessionNumber?: IntWithAggregatesFilter<"sessiondefinition"> | number
    expectedClockIn?: DateTimeWithAggregatesFilter<"sessiondefinition"> | Date | string
    expectedClockOut?: DateTimeWithAggregatesFilter<"sessiondefinition"> | Date | string
  }

  export type shiftWhereInput = {
    AND?: shiftWhereInput | shiftWhereInput[]
    OR?: shiftWhereInput[]
    NOT?: shiftWhereInput | shiftWhereInput[]
    id?: IntFilter<"shift"> | number
    name?: StringFilter<"shift"> | string
    startTime?: DateTimeFilter<"shift"> | Date | string
    endTime?: DateTimeFilter<"shift"> | Date | string
    isFlexible?: BoolFilter<"shift"> | boolean
    description?: StringNullableFilter<"shift"> | string | null
    employeeshift?: EmployeeshiftListRelationFilter
  }

  export type shiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrderInput | SortOrder
    employeeshift?: employeeshiftOrderByRelationAggregateInput
    _relevance?: shiftOrderByRelevanceInput
  }

  export type shiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: shiftWhereInput | shiftWhereInput[]
    OR?: shiftWhereInput[]
    NOT?: shiftWhereInput | shiftWhereInput[]
    name?: StringFilter<"shift"> | string
    startTime?: DateTimeFilter<"shift"> | Date | string
    endTime?: DateTimeFilter<"shift"> | Date | string
    isFlexible?: BoolFilter<"shift"> | boolean
    description?: StringNullableFilter<"shift"> | string | null
    employeeshift?: EmployeeshiftListRelationFilter
  }, "id">

  export type shiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: shiftCountOrderByAggregateInput
    _avg?: shiftAvgOrderByAggregateInput
    _max?: shiftMaxOrderByAggregateInput
    _min?: shiftMinOrderByAggregateInput
    _sum?: shiftSumOrderByAggregateInput
  }

  export type shiftScalarWhereWithAggregatesInput = {
    AND?: shiftScalarWhereWithAggregatesInput | shiftScalarWhereWithAggregatesInput[]
    OR?: shiftScalarWhereWithAggregatesInput[]
    NOT?: shiftScalarWhereWithAggregatesInput | shiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"shift"> | number
    name?: StringWithAggregatesFilter<"shift"> | string
    startTime?: DateTimeWithAggregatesFilter<"shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"shift"> | Date | string
    isFlexible?: BoolWithAggregatesFilter<"shift"> | boolean
    description?: StringNullableWithAggregatesFilter<"shift"> | string | null
  }

  export type terminationWhereInput = {
    AND?: terminationWhereInput | terminationWhereInput[]
    OR?: terminationWhereInput[]
    NOT?: terminationWhereInput | terminationWhereInput[]
    id?: IntFilter<"termination"> | number
    employeeId?: IntFilter<"termination"> | number
    terminationDate?: DateTimeFilter<"termination"> | Date | string
    reason?: StringNullableFilter<"termination"> | string | null
    status?: Enumtermination_statusFilter<"termination"> | $Enums.termination_status
    remarks?: StringNullableFilter<"termination"> | string | null
    createdAt?: DateTimeFilter<"termination"> | Date | string
    updatedAt?: DateTimeFilter<"termination"> | Date | string
    workflowStatus?: Enumtermination_workflowStatusFilter<"termination"> | $Enums.termination_workflowStatus
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }

  export type terminationOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowStatus?: SortOrder
    employee?: employeeOrderByWithRelationInput
    _relevance?: terminationOrderByRelevanceInput
  }

  export type terminationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: terminationWhereInput | terminationWhereInput[]
    OR?: terminationWhereInput[]
    NOT?: terminationWhereInput | terminationWhereInput[]
    employeeId?: IntFilter<"termination"> | number
    terminationDate?: DateTimeFilter<"termination"> | Date | string
    reason?: StringNullableFilter<"termination"> | string | null
    status?: Enumtermination_statusFilter<"termination"> | $Enums.termination_status
    remarks?: StringNullableFilter<"termination"> | string | null
    createdAt?: DateTimeFilter<"termination"> | Date | string
    updatedAt?: DateTimeFilter<"termination"> | Date | string
    workflowStatus?: Enumtermination_workflowStatusFilter<"termination"> | $Enums.termination_workflowStatus
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
  }, "id">

  export type terminationOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowStatus?: SortOrder
    _count?: terminationCountOrderByAggregateInput
    _avg?: terminationAvgOrderByAggregateInput
    _max?: terminationMaxOrderByAggregateInput
    _min?: terminationMinOrderByAggregateInput
    _sum?: terminationSumOrderByAggregateInput
  }

  export type terminationScalarWhereWithAggregatesInput = {
    AND?: terminationScalarWhereWithAggregatesInput | terminationScalarWhereWithAggregatesInput[]
    OR?: terminationScalarWhereWithAggregatesInput[]
    NOT?: terminationScalarWhereWithAggregatesInput | terminationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"termination"> | number
    employeeId?: IntWithAggregatesFilter<"termination"> | number
    terminationDate?: DateTimeWithAggregatesFilter<"termination"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"termination"> | string | null
    status?: Enumtermination_statusWithAggregatesFilter<"termination"> | $Enums.termination_status
    remarks?: StringNullableWithAggregatesFilter<"termination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"termination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"termination"> | Date | string
    workflowStatus?: Enumtermination_workflowStatusWithAggregatesFilter<"termination"> | $Enums.termination_workflowStatus
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    username?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    isActive?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    notifyOnComplaint?: BoolFilter<"user"> | boolean
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    leave?: LeaveListRelationFilter
    overtimelog?: OvertimelogListRelationFilter
    userrole?: UserroleListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
    employee?: employeeOrderByWithRelationInput
    leave?: leaveOrderByRelationAggregateInput
    overtimelog?: overtimelogOrderByRelationAggregateInput
    userrole?: userroleOrderByRelationAggregateInput
    _relevance?: userOrderByRelevanceInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    password?: StringFilter<"user"> | string
    isActive?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
    notifyOnComplaint?: BoolFilter<"user"> | boolean
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    leave?: LeaveListRelationFilter
    overtimelog?: OvertimelogListRelationFilter
    userrole?: UserroleListRelationFilter
  }, "id" | "username" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    username?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    isActive?: BoolWithAggregatesFilter<"user"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    notifyOnComplaint?: BoolWithAggregatesFilter<"user"> | boolean
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type userroleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    role?: roleOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: userroleUserIdRoleIdCompoundUniqueInput
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "userId_roleId">

  export type userroleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"userrole"> | number
    roleId?: IntWithAggregatesFilter<"userrole"> | number
  }

  export type activitylogCreateInput = {
    type: $Enums.activitylog_type
    message: string
    departmentId: number
    createdAt?: Date | string
    employee_activitylog_actorIdToemployee: employeeCreateNestedOneWithoutActivitylog_activitylog_actorIdToemployeeInput
    employee_activitylog_targetIdToemployee?: employeeCreateNestedOneWithoutActivitylog_activitylog_targetIdToemployeeInput
  }

  export type activitylogUncheckedCreateInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    actorId: number
    targetId?: number | null
    departmentId: number
    createdAt?: Date | string
  }

  export type activitylogUpdateInput = {
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_activitylog_actorIdToemployee?: employeeUpdateOneRequiredWithoutActivitylog_activitylog_actorIdToemployeeNestedInput
    employee_activitylog_targetIdToemployee?: employeeUpdateOneWithoutActivitylog_activitylog_targetIdToemployeeNestedInput
  }

  export type activitylogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogCreateManyInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    actorId: number
    targetId?: number | null
    departmentId: number
    createdAt?: Date | string
  }

  export type activitylogUpdateManyMutationInput = {
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agreementstatusCreateInput = {
    status: string
    employee?: employeeCreateNestedManyWithoutAgreementstatusInput
  }

  export type agreementstatusUncheckedCreateInput = {
    id?: number
    status: string
    employee?: employeeUncheckedCreateNestedManyWithoutAgreementstatusInput
  }

  export type agreementstatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUpdateManyWithoutAgreementstatusNestedInput
  }

  export type agreementstatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUncheckedUpdateManyWithoutAgreementstatusNestedInput
  }

  export type agreementstatusCreateManyInput = {
    id?: number
    status: string
  }

  export type agreementstatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type agreementstatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type attendancelogCreateInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
    employee: employeeCreateNestedOneWithoutAttendancelogInput
    sessiondefinition: sessiondefinitionCreateNestedOneWithoutAttendancelogInput
  }

  export type attendancelogUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancelogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutAttendancelogNestedInput
    sessiondefinition?: sessiondefinitionUpdateOneRequiredWithoutAttendancelogNestedInput
  }

  export type attendancelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancelogCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancelogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancesummaryCreateInput = {
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    department?: departmentCreateNestedOneWithoutAttendancesummaryInput
    employee: employeeCreateNestedOneWithoutAttendancesummaryInput
  }

  export type attendancesummaryUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type attendancesummaryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutAttendancesummaryNestedInput
    employee?: employeeUpdateOneRequiredWithoutAttendancesummaryNestedInput
  }

  export type attendancesummaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type attendancesummaryCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type attendancesummaryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendancesummaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type complaintCreateInput = {
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    employee: employeeCreateNestedOneWithoutComplaintInput
  }

  export type complaintUncheckedCreateInput = {
    id?: number
    employeeId: number
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type complaintUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutComplaintNestedInput
  }

  export type complaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintCreateManyInput = {
    id?: number
    employeeId: number
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type complaintUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
  }

  export type departmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeCreateInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateManyInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeshiftCreateInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    employee: employeeCreateNestedOneWithoutEmployeeshiftInput
    shift: shiftCreateNestedOneWithoutEmployeeshiftInput
  }

  export type employeeshiftUncheckedCreateInput = {
    id?: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type employeeshiftUpdateInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutEmployeeshiftNestedInput
    shift?: shiftUpdateOneRequiredWithoutEmployeeshiftNestedInput
  }

  export type employeeshiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeshiftCreateManyInput = {
    id?: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type employeeshiftUpdateManyMutationInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeshiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employmenttypeCreateInput = {
    type: string
    employee?: employeeCreateNestedManyWithoutEmploymenttypeInput
  }

  export type employmenttypeUncheckedCreateInput = {
    id?: number
    type: string
    employee?: employeeUncheckedCreateNestedManyWithoutEmploymenttypeInput
  }

  export type employmenttypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    employee?: employeeUpdateManyWithoutEmploymenttypeNestedInput
  }

  export type employmenttypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    employee?: employeeUncheckedUpdateManyWithoutEmploymenttypeNestedInput
  }

  export type employmenttypeCreateManyInput = {
    id?: number
    type: string
  }

  export type employmenttypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type employmenttypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type holidayCreateInput = {
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type holidayUncheckedCreateInput = {
    id?: number
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type holidayUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type holidayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type holidayCreateManyInput = {
    id?: number
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type holidayUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type holidayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type interviewCreateInput = {
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.interview_result
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type interviewUncheckedCreateInput = {
    id?: number
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.interview_result
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type interviewUpdateInput = {
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: Enuminterview_resultFieldUpdateOperationsInput | $Enums.interview_result
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: Enuminterview_resultFieldUpdateOperationsInput | $Enums.interview_result
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewCreateManyInput = {
    id?: number
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.interview_result
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type interviewUpdateManyMutationInput = {
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: Enuminterview_resultFieldUpdateOperationsInput | $Enums.interview_result
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type interviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: Enuminterview_resultFieldUpdateOperationsInput | $Enums.interview_result
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobstatusCreateInput = {
    status: string
    employee?: employeeCreateNestedManyWithoutJobstatusInput
  }

  export type jobstatusUncheckedCreateInput = {
    id?: number
    status: string
    employee?: employeeUncheckedCreateNestedManyWithoutJobstatusInput
  }

  export type jobstatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUpdateManyWithoutJobstatusNestedInput
  }

  export type jobstatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUncheckedUpdateManyWithoutJobstatusNestedInput
  }

  export type jobstatusCreateManyInput = {
    id?: number
    status: string
  }

  export type jobstatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type jobstatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type leaveCreateInput = {
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    requestedAt?: Date | string
    updatedAt: Date | string
    user?: userCreateNestedOneWithoutLeaveInput
    employee: employeeCreateNestedOneWithoutLeaveInput
  }

  export type leaveUncheckedCreateInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type leaveUpdateInput = {
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutLeaveNestedInput
    employee?: employeeUpdateOneRequiredWithoutLeaveNestedInput
  }

  export type leaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaveCreateManyInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type leaveUpdateManyMutationInput = {
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type maritalstatusCreateInput = {
    status: string
    employee?: employeeCreateNestedManyWithoutMaritalstatusInput
  }

  export type maritalstatusUncheckedCreateInput = {
    id?: number
    status: string
    employee?: employeeUncheckedCreateNestedManyWithoutMaritalstatusInput
  }

  export type maritalstatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUpdateManyWithoutMaritalstatusNestedInput
  }

  export type maritalstatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employee?: employeeUncheckedUpdateManyWithoutMaritalstatusNestedInput
  }

  export type maritalstatusCreateManyInput = {
    id?: number
    status: string
  }

  export type maritalstatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type maritalstatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type meetingCreateInput = {
    title: string
    description?: string | null
    date: Date | string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: employeeCreateNestedOneWithoutMeetingInput
  }

  export type meetingUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    creatorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type meetingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneWithoutMeetingNestedInput
  }

  export type meetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    creatorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type meetingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogCreateInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedOneWithoutOvertimelogInput
    employee: employeeCreateNestedOneWithoutOvertimelogInput
  }

  export type overtimelogUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type overtimelogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutOvertimelogNestedInput
    employee?: employeeUpdateOneRequiredWithoutOvertimelogNestedInput
  }

  export type overtimelogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type overtimelogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type payrollpolicyCreateInput = {
    name: string
    isDefault?: boolean
    otMultiplierWeekday1?: Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    otMultiplierSleepover?: Decimal | DecimalJsLike | number | string
    department?: departmentCreateNestedManyWithoutPayrollpolicyInput
  }

  export type payrollpolicyUncheckedCreateInput = {
    id?: number
    name: string
    isDefault?: boolean
    otMultiplierWeekday1?: Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    otMultiplierSleepover?: Decimal | DecimalJsLike | number | string
    department?: departmentUncheckedCreateNestedManyWithoutPayrollpolicyInput
  }

  export type payrollpolicyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    department?: departmentUpdateManyWithoutPayrollpolicyNestedInput
  }

  export type payrollpolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    department?: departmentUncheckedUpdateManyWithoutPayrollpolicyNestedInput
  }

  export type payrollpolicyCreateManyInput = {
    id?: number
    name: string
    isDefault?: boolean
    otMultiplierWeekday1?: Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    otMultiplierSleepover?: Decimal | DecimalJsLike | number | string
  }

  export type payrollpolicyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type payrollpolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type performancereviewCreateInput = {
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    employee: employeeCreateNestedOneWithoutPerformancereviewInput
  }

  export type performancereviewUncheckedCreateInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type performancereviewUpdateInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutPerformancereviewNestedInput
  }

  export type performancereviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type performancereviewCreateManyInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type performancereviewUpdateManyMutationInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type performancereviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type positionCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    employee?: employeeCreateNestedManyWithoutPositionInput
  }

  export type positionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    employee?: employeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type positionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateManyWithoutPositionNestedInput
  }

  export type positionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type positionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type positionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type positionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roleCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userrole?: userroleCreateNestedManyWithoutRoleInput
  }

  export type roleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    userrole?: userroleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type roleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userrole?: userroleUpdateManyWithoutRoleNestedInput
  }

  export type roleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userrole?: userroleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type roleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type roleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salaryCreateInput = {
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    employee: employeeCreateNestedOneWithoutSalaryRecordsInput
  }

  export type salaryUncheckedCreateInput = {
    id?: number
    employeeId: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
  }

  export type salaryUpdateInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    employee?: employeeUpdateOneRequiredWithoutSalaryRecordsNestedInput
  }

  export type salaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type salaryCreateManyInput = {
    id?: number
    employeeId: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
  }

  export type salaryUpdateManyMutationInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type salaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type sessiondefinitionCreateInput = {
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
    attendancelog?: attendancelogCreateNestedManyWithoutSessiondefinitionInput
  }

  export type sessiondefinitionUncheckedCreateInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutSessiondefinitionInput
  }

  export type sessiondefinitionUpdateInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancelog?: attendancelogUpdateManyWithoutSessiondefinitionNestedInput
  }

  export type sessiondefinitionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancelog?: attendancelogUncheckedUpdateManyWithoutSessiondefinitionNestedInput
  }

  export type sessiondefinitionCreateManyInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type sessiondefinitionUpdateManyMutationInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessiondefinitionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type shiftCreateInput = {
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
    employeeshift?: employeeshiftCreateNestedManyWithoutShiftInput
  }

  export type shiftUncheckedCreateInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutShiftInput
  }

  export type shiftUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employeeshift?: employeeshiftUpdateManyWithoutShiftNestedInput
  }

  export type shiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type shiftCreateManyInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type shiftUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type terminationCreateInput = {
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
    employee: employeeCreateNestedOneWithoutTerminationInput
  }

  export type terminationUncheckedCreateInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
  }

  export type terminationUpdateInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
    employee?: employeeUpdateOneRequiredWithoutTerminationNestedInput
  }

  export type terminationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type terminationCreateManyInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
  }

  export type terminationUpdateManyMutationInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type terminationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type userCreateInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeCreateNestedOneWithoutUserInput
    leave?: leaveCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeUncheckedCreateNestedOneWithoutUserInput
    leave?: leaveUncheckedCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUpdateOneWithoutUserNestedInput
    leave?: leaveUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUncheckedUpdateOneWithoutUserNestedInput
    leave?: leaveUncheckedUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
  }

  export type userUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
  }

  export type userroleCreateInput = {
    role: roleCreateNestedOneWithoutUserroleInput
    user: userCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    userId: number
    roleId: number
  }

  export type userroleUpdateInput = {
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
    user?: userUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleCreateManyInput = {
    userId: number
    roleId: number
  }

  export type userroleUpdateManyMutationInput = {

  }

  export type userroleUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type Enumactivitylog_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.activitylog_type | Enumactivitylog_typeFieldRefInput<$PrismaModel>
    in?: $Enums.activitylog_type[]
    notIn?: $Enums.activitylog_type[]
    not?: NestedEnumactivitylog_typeFilter<$PrismaModel> | $Enums.activitylog_type
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: employeeWhereInput | null
    isNot?: employeeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activitylogOrderByRelevanceInput = {
    fields: activitylogOrderByRelevanceFieldEnum | activitylogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type activitylogCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type activitylogAvgOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrder
    departmentId?: SortOrder
  }

  export type activitylogMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type activitylogMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    message?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
  }

  export type activitylogSumOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    targetId?: SortOrder
    departmentId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type Enumactivitylog_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activitylog_type | Enumactivitylog_typeFieldRefInput<$PrismaModel>
    in?: $Enums.activitylog_type[]
    notIn?: $Enums.activitylog_type[]
    not?: NestedEnumactivitylog_typeWithAggregatesFilter<$PrismaModel> | $Enums.activitylog_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumactivitylog_typeFilter<$PrismaModel>
    _max?: NestedEnumactivitylog_typeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EmployeeListRelationFilter = {
    every?: employeeWhereInput
    some?: employeeWhereInput
    none?: employeeWhereInput
  }

  export type employeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type agreementstatusOrderByRelevanceInput = {
    fields: agreementstatusOrderByRelevanceFieldEnum | agreementstatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type agreementstatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type agreementstatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type agreementstatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type agreementstatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type agreementstatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Enumattendancelog_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancelog_status | Enumattendancelog_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancelog_status[]
    notIn?: $Enums.attendancelog_status[]
    not?: NestedEnumattendancelog_statusFilter<$PrismaModel> | $Enums.attendancelog_status
  }

  export type SessiondefinitionScalarRelationFilter = {
    is?: sessiondefinitionWhereInput
    isNot?: sessiondefinitionWhereInput
  }

  export type attendancelogEmployeeIdDateSessionIdCompoundUniqueInput = {
    employeeId: number
    date: Date | string
    sessionId: number
  }

  export type attendancelogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type attendancelogAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    sessionId?: SortOrder
  }

  export type attendancelogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type attendancelogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type attendancelogSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    sessionId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumattendancelog_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancelog_status | Enumattendancelog_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancelog_status[]
    notIn?: $Enums.attendancelog_status[]
    not?: NestedEnumattendancelog_statusWithAggregatesFilter<$PrismaModel> | $Enums.attendancelog_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattendancelog_statusFilter<$PrismaModel>
    _max?: NestedEnumattendancelog_statusFilter<$PrismaModel>
  }

  export type Enumattendancesummary_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancesummary_status | Enumattendancesummary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancesummary_status[]
    notIn?: $Enums.attendancesummary_status[]
    not?: NestedEnumattendancesummary_statusFilter<$PrismaModel> | $Enums.attendancesummary_status
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: departmentWhereInput | null
    isNot?: departmentWhereInput | null
  }

  export type attendancesummaryOrderByRelevanceInput = {
    fields: attendancesummaryOrderByRelevanceFieldEnum | attendancesummaryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type attendancesummaryEmployeeIdDateCompoundUniqueInput = {
    employeeId: number
    date: Date | string
  }

  export type attendancesummaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type attendancesummaryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalWorkHours?: SortOrder
    departmentId?: SortOrder
  }

  export type attendancesummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type attendancesummaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type attendancesummarySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalWorkHours?: SortOrder
    departmentId?: SortOrder
  }

  export type Enumattendancesummary_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancesummary_status | Enumattendancesummary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancesummary_status[]
    notIn?: $Enums.attendancesummary_status[]
    not?: NestedEnumattendancesummary_statusWithAggregatesFilter<$PrismaModel> | $Enums.attendancesummary_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattendancesummary_statusFilter<$PrismaModel>
    _max?: NestedEnumattendancesummary_statusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumcomplaint_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.complaint_status | Enumcomplaint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.complaint_status[]
    notIn?: $Enums.complaint_status[]
    not?: NestedEnumcomplaint_statusFilter<$PrismaModel> | $Enums.complaint_status
  }

  export type complaintOrderByRelevanceInput = {
    fields: complaintOrderByRelevanceFieldEnum | complaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type complaintCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type complaintAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type complaintMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type complaintMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type complaintSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type Enumcomplaint_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.complaint_status | Enumcomplaint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.complaint_status[]
    notIn?: $Enums.complaint_status[]
    not?: NestedEnumcomplaint_statusWithAggregatesFilter<$PrismaModel> | $Enums.complaint_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomplaint_statusFilter<$PrismaModel>
    _max?: NestedEnumcomplaint_statusFilter<$PrismaModel>
  }

  export type AttendancesummaryListRelationFilter = {
    every?: attendancesummaryWhereInput
    some?: attendancesummaryWhereInput
    none?: attendancesummaryWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: departmentWhereInput
    some?: departmentWhereInput
    none?: departmentWhereInput
  }

  export type PayrollpolicyNullableScalarRelationFilter = {
    is?: payrollpolicyWhereInput | null
    isNot?: payrollpolicyWhereInput | null
  }

  export type attendancesummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentOrderByRelevanceInput = {
    fields: departmentOrderByRelevanceFieldEnum | departmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type departmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    payrollPolicyId?: SortOrder
  }

  export type departmentAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    payrollPolicyId?: SortOrder
  }

  export type departmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    payrollPolicyId?: SortOrder
  }

  export type departmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    payrollPolicyId?: SortOrder
  }

  export type departmentSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    payrollPolicyId?: SortOrder
  }

  export type Enumemployee_sexFilter<$PrismaModel = never> = {
    equals?: $Enums.employee_sex | Enumemployee_sexFieldRefInput<$PrismaModel>
    in?: $Enums.employee_sex[]
    notIn?: $Enums.employee_sex[]
    not?: NestedEnumemployee_sexFilter<$PrismaModel> | $Enums.employee_sex
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ActivitylogListRelationFilter = {
    every?: activitylogWhereInput
    some?: activitylogWhereInput
    none?: activitylogWhereInput
  }

  export type AttendancelogListRelationFilter = {
    every?: attendancelogWhereInput
    some?: attendancelogWhereInput
    none?: attendancelogWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: complaintWhereInput
    some?: complaintWhereInput
    none?: complaintWhereInput
  }

  export type AgreementstatusNullableScalarRelationFilter = {
    is?: agreementstatusWhereInput | null
    isNot?: agreementstatusWhereInput | null
  }

  export type EmploymenttypeNullableScalarRelationFilter = {
    is?: employmenttypeWhereInput | null
    isNot?: employmenttypeWhereInput | null
  }

  export type JobstatusNullableScalarRelationFilter = {
    is?: jobstatusWhereInput | null
    isNot?: jobstatusWhereInput | null
  }

  export type MaritalstatusNullableScalarRelationFilter = {
    is?: maritalstatusWhereInput | null
    isNot?: maritalstatusWhereInput | null
  }

  export type PositionNullableScalarRelationFilter = {
    is?: positionWhereInput | null
    isNot?: positionWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type EmployeeshiftListRelationFilter = {
    every?: employeeshiftWhereInput
    some?: employeeshiftWhereInput
    none?: employeeshiftWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: leaveWhereInput
    some?: leaveWhereInput
    none?: leaveWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: meetingWhereInput
    some?: meetingWhereInput
    none?: meetingWhereInput
  }

  export type OvertimelogListRelationFilter = {
    every?: overtimelogWhereInput
    some?: overtimelogWhereInput
    none?: overtimelogWhereInput
  }

  export type PerformancereviewListRelationFilter = {
    every?: performancereviewWhereInput
    some?: performancereviewWhereInput
    none?: performancereviewWhereInput
  }

  export type SalaryListRelationFilter = {
    every?: salaryWhereInput
    some?: salaryWhereInput
    none?: salaryWhereInput
  }

  export type TerminationListRelationFilter = {
    every?: terminationWhereInput
    some?: terminationWhereInput
    none?: terminationWhereInput
  }

  export type activitylogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attendancelogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type complaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeshiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type leaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type meetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type overtimelogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type performancereviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type salaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type terminationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeOrderByRelevanceInput = {
    fields: employeeOrderByRelevanceFieldEnum | employeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type employeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subDepartmentId?: SortOrder
  }

  export type employeeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    jobStatusId?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    agreementStatusId?: SortOrder
    subDepartmentId?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subDepartmentId?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subDepartmentId?: SortOrder
  }

  export type employeeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    jobStatusId?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    agreementStatusId?: SortOrder
    subDepartmentId?: SortOrder
  }

  export type Enumemployee_sexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.employee_sex | Enumemployee_sexFieldRefInput<$PrismaModel>
    in?: $Enums.employee_sex[]
    notIn?: $Enums.employee_sex[]
    not?: NestedEnumemployee_sexWithAggregatesFilter<$PrismaModel> | $Enums.employee_sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemployee_sexFilter<$PrismaModel>
    _max?: NestedEnumemployee_sexFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ShiftScalarRelationFilter = {
    is?: shiftWhereInput
    isNot?: shiftWhereInput
  }

  export type employeeshiftCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type employeeshiftAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
  }

  export type employeeshiftMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type employeeshiftMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type employeeshiftSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
  }

  export type employmenttypeOrderByRelevanceInput = {
    fields: employmenttypeOrderByRelevanceFieldEnum | employmenttypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type employmenttypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type employmenttypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type employmenttypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type employmenttypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type employmenttypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type holidayOrderByRelevanceInput = {
    fields: holidayOrderByRelevanceFieldEnum | holidayOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type holidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type holidayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type holidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type holidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type holidaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enuminterview_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.interview_result | Enuminterview_resultFieldRefInput<$PrismaModel>
    in?: $Enums.interview_result[]
    notIn?: $Enums.interview_result[]
    not?: NestedEnuminterview_resultFilter<$PrismaModel> | $Enums.interview_result
  }

  export type interviewOrderByRelevanceInput = {
    fields: interviewOrderByRelevanceFieldEnum | interviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type interviewCountOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type interviewAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type interviewMaxOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type interviewMinOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type interviewSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enuminterview_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interview_result | Enuminterview_resultFieldRefInput<$PrismaModel>
    in?: $Enums.interview_result[]
    notIn?: $Enums.interview_result[]
    not?: NestedEnuminterview_resultWithAggregatesFilter<$PrismaModel> | $Enums.interview_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterview_resultFilter<$PrismaModel>
    _max?: NestedEnuminterview_resultFilter<$PrismaModel>
  }

  export type jobstatusOrderByRelevanceInput = {
    fields: jobstatusOrderByRelevanceFieldEnum | jobstatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobstatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type jobstatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jobstatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type jobstatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type jobstatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumleave_leaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_leaveType | Enumleave_leaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.leave_leaveType[]
    notIn?: $Enums.leave_leaveType[]
    not?: NestedEnumleave_leaveTypeFilter<$PrismaModel> | $Enums.leave_leaveType
  }

  export type Enumleave_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_status | Enumleave_statusFieldRefInput<$PrismaModel>
    in?: $Enums.leave_status[]
    notIn?: $Enums.leave_status[]
    not?: NestedEnumleave_statusFilter<$PrismaModel> | $Enums.leave_status
  }

  export type leaveOrderByRelevanceInput = {
    fields: leaveOrderByRelevanceFieldEnum | leaveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type leaveCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type leaveAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    approvedBy?: SortOrder
  }

  export type leaveMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type leaveMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type leaveSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    approvedBy?: SortOrder
  }

  export type Enumleave_leaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_leaveType | Enumleave_leaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.leave_leaveType[]
    notIn?: $Enums.leave_leaveType[]
    not?: NestedEnumleave_leaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.leave_leaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumleave_leaveTypeFilter<$PrismaModel>
    _max?: NestedEnumleave_leaveTypeFilter<$PrismaModel>
  }

  export type Enumleave_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_status | Enumleave_statusFieldRefInput<$PrismaModel>
    in?: $Enums.leave_status[]
    notIn?: $Enums.leave_status[]
    not?: NestedEnumleave_statusWithAggregatesFilter<$PrismaModel> | $Enums.leave_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumleave_statusFilter<$PrismaModel>
    _max?: NestedEnumleave_statusFilter<$PrismaModel>
  }

  export type maritalstatusOrderByRelevanceInput = {
    fields: maritalstatusOrderByRelevanceFieldEnum | maritalstatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type maritalstatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type maritalstatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type maritalstatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type maritalstatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type maritalstatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type meetingOrderByRelevanceInput = {
    fields: meetingOrderByRelevanceFieldEnum | meetingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type meetingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meetingAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type meetingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meetingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type meetingSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type Enumovertimelog_approvalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_approvalStatus | Enumovertimelog_approvalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_approvalStatus[]
    notIn?: $Enums.overtimelog_approvalStatus[]
    not?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel> | $Enums.overtimelog_approvalStatus
  }

  export type Enumovertimelog_compensationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_compensationMethod | Enumovertimelog_compensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_compensationMethod[]
    notIn?: $Enums.overtimelog_compensationMethod[]
    not?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel> | $Enums.overtimelog_compensationMethod
  }

  export type Enumovertimelog_overtimeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_overtimeType | Enumovertimelog_overtimeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_overtimeType[]
    notIn?: $Enums.overtimelog_overtimeType[]
    not?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel> | $Enums.overtimelog_overtimeType
  }

  export type overtimelogOrderByRelevanceInput = {
    fields: overtimelogOrderByRelevanceFieldEnum | overtimelogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type overtimelogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    overtimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type overtimelogAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hours?: SortOrder
    approvedBy?: SortOrder
  }

  export type overtimelogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    overtimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type overtimelogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    endTime?: SortOrder
    startTime?: SortOrder
    overtimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type overtimelogSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hours?: SortOrder
    approvedBy?: SortOrder
  }

  export type Enumovertimelog_approvalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_approvalStatus | Enumovertimelog_approvalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_approvalStatus[]
    notIn?: $Enums.overtimelog_approvalStatus[]
    not?: NestedEnumovertimelog_approvalStatusWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_approvalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel>
  }

  export type Enumovertimelog_compensationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_compensationMethod | Enumovertimelog_compensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_compensationMethod[]
    notIn?: $Enums.overtimelog_compensationMethod[]
    not?: NestedEnumovertimelog_compensationMethodWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_compensationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel>
  }

  export type Enumovertimelog_overtimeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_overtimeType | Enumovertimelog_overtimeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_overtimeType[]
    notIn?: $Enums.overtimelog_overtimeType[]
    not?: NestedEnumovertimelog_overtimeTypeWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_overtimeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel>
  }

  export type payrollpolicyOrderByRelevanceInput = {
    fields: payrollpolicyOrderByRelevanceFieldEnum | payrollpolicyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type payrollpolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otMultiplierSleepover?: SortOrder
  }

  export type payrollpolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    otMultiplierSleepover?: SortOrder
  }

  export type payrollpolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otMultiplierSleepover?: SortOrder
  }

  export type payrollpolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isDefault?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    otMultiplierSleepover?: SortOrder
  }

  export type payrollpolicySumOrderByAggregateInput = {
    id?: SortOrder
    otMultiplierWeekday1?: SortOrder
    otMultiplierWeekday2?: SortOrder
    otMultiplierSunday?: SortOrder
    otMultiplierHoliday?: SortOrder
    otMultiplierSleepover?: SortOrder
  }

  export type performancereviewOrderByRelevanceInput = {
    fields: performancereviewOrderByRelevanceFieldEnum | performancereviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type performancereviewCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type performancereviewAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    score?: SortOrder
  }

  export type performancereviewMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type performancereviewMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type performancereviewSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    score?: SortOrder
  }

  export type positionOrderByRelevanceInput = {
    fields: positionOrderByRelevanceFieldEnum | positionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type positionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type positionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type positionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type positionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type positionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserroleListRelationFilter = {
    every?: userroleWhereInput
    some?: userroleWhereInput
    none?: userroleWhereInput
  }

  export type userroleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roleOrderByRelevanceInput = {
    fields: roleOrderByRelevanceFieldEnum | roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type roleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type roleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type roleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type roleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type roleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumsalary_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.salary_status | Enumsalary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.salary_status[]
    notIn?: $Enums.salary_status[]
    not?: NestedEnumsalary_statusFilter<$PrismaModel> | $Enums.salary_status
  }

  export type salaryEmployeeIdSalaryMonthCompoundUniqueInput = {
    employeeId: number
    salaryMonth: Date | string
  }

  export type salaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
  }

  export type salaryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
  }

  export type salaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
  }

  export type salaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
  }

  export type salarySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    baseSalary?: SortOrder
    deductions?: SortOrder
  }

  export type Enumsalary_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salary_status | Enumsalary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.salary_status[]
    notIn?: $Enums.salary_status[]
    not?: NestedEnumsalary_statusWithAggregatesFilter<$PrismaModel> | $Enums.salary_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsalary_statusFilter<$PrismaModel>
    _max?: NestedEnumsalary_statusFilter<$PrismaModel>
  }

  export type sessiondefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type sessiondefinitionAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
  }

  export type sessiondefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type sessiondefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type sessiondefinitionSumOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
  }

  export type shiftOrderByRelevanceInput = {
    fields: shiftOrderByRelevanceFieldEnum | shiftOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type shiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type shiftAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type shiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type shiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type shiftSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumtermination_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_status | Enumtermination_statusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_status[]
    notIn?: $Enums.termination_status[]
    not?: NestedEnumtermination_statusFilter<$PrismaModel> | $Enums.termination_status
  }

  export type Enumtermination_workflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_workflowStatus | Enumtermination_workflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_workflowStatus[]
    notIn?: $Enums.termination_workflowStatus[]
    not?: NestedEnumtermination_workflowStatusFilter<$PrismaModel> | $Enums.termination_workflowStatus
  }

  export type terminationOrderByRelevanceInput = {
    fields: terminationOrderByRelevanceFieldEnum | terminationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type terminationCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowStatus?: SortOrder
  }

  export type terminationAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type terminationMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowStatus?: SortOrder
  }

  export type terminationMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workflowStatus?: SortOrder
  }

  export type terminationSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type Enumtermination_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_status | Enumtermination_statusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_status[]
    notIn?: $Enums.termination_status[]
    not?: NestedEnumtermination_statusWithAggregatesFilter<$PrismaModel> | $Enums.termination_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtermination_statusFilter<$PrismaModel>
    _max?: NestedEnumtermination_statusFilter<$PrismaModel>
  }

  export type Enumtermination_workflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_workflowStatus | Enumtermination_workflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_workflowStatus[]
    notIn?: $Enums.termination_workflowStatus[]
    not?: NestedEnumtermination_workflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.termination_workflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtermination_workflowStatusFilter<$PrismaModel>
    _max?: NestedEnumtermination_workflowStatusFilter<$PrismaModel>
  }

  export type userOrderByRelevanceInput = {
    fields: userOrderByRelevanceFieldEnum | userOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput
    isNot?: roleWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type userroleUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type userroleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type employeeCreateNestedOneWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    create?: XOR<employeeCreateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_actorIdToemployeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActivitylog_activitylog_actorIdToemployeeInput
    connect?: employeeWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    create?: XOR<employeeCreateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_targetIdToemployeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActivitylog_activitylog_targetIdToemployeeInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumactivitylog_typeFieldUpdateOperationsInput = {
    set?: $Enums.activitylog_type
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type employeeUpdateOneRequiredWithoutActivitylog_activitylog_actorIdToemployeeNestedInput = {
    create?: XOR<employeeCreateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_actorIdToemployeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActivitylog_activitylog_actorIdToemployeeInput
    upsert?: employeeUpsertWithoutActivitylog_activitylog_actorIdToemployeeInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput>, employeeUncheckedUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput>
  }

  export type employeeUpdateOneWithoutActivitylog_activitylog_targetIdToemployeeNestedInput = {
    create?: XOR<employeeCreateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_targetIdToemployeeInput>
    connectOrCreate?: employeeCreateOrConnectWithoutActivitylog_activitylog_targetIdToemployeeInput
    upsert?: employeeUpsertWithoutActivitylog_activitylog_targetIdToemployeeInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput>, employeeUncheckedUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type employeeCreateNestedManyWithoutAgreementstatusInput = {
    create?: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput> | employeeCreateWithoutAgreementstatusInput[] | employeeUncheckedCreateWithoutAgreementstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutAgreementstatusInput | employeeCreateOrConnectWithoutAgreementstatusInput[]
    createMany?: employeeCreateManyAgreementstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutAgreementstatusInput = {
    create?: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput> | employeeCreateWithoutAgreementstatusInput[] | employeeUncheckedCreateWithoutAgreementstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutAgreementstatusInput | employeeCreateOrConnectWithoutAgreementstatusInput[]
    createMany?: employeeCreateManyAgreementstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutAgreementstatusNestedInput = {
    create?: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput> | employeeCreateWithoutAgreementstatusInput[] | employeeUncheckedCreateWithoutAgreementstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutAgreementstatusInput | employeeCreateOrConnectWithoutAgreementstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutAgreementstatusInput | employeeUpsertWithWhereUniqueWithoutAgreementstatusInput[]
    createMany?: employeeCreateManyAgreementstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutAgreementstatusInput | employeeUpdateWithWhereUniqueWithoutAgreementstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutAgreementstatusInput | employeeUpdateManyWithWhereWithoutAgreementstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutAgreementstatusNestedInput = {
    create?: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput> | employeeCreateWithoutAgreementstatusInput[] | employeeUncheckedCreateWithoutAgreementstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutAgreementstatusInput | employeeCreateOrConnectWithoutAgreementstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutAgreementstatusInput | employeeUpsertWithWhereUniqueWithoutAgreementstatusInput[]
    createMany?: employeeCreateManyAgreementstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutAgreementstatusInput | employeeUpdateWithWhereUniqueWithoutAgreementstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutAgreementstatusInput | employeeUpdateManyWithWhereWithoutAgreementstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutAttendancelogInput = {
    create?: XOR<employeeCreateWithoutAttendancelogInput, employeeUncheckedCreateWithoutAttendancelogInput>
    connectOrCreate?: employeeCreateOrConnectWithoutAttendancelogInput
    connect?: employeeWhereUniqueInput
  }

  export type sessiondefinitionCreateNestedOneWithoutAttendancelogInput = {
    create?: XOR<sessiondefinitionCreateWithoutAttendancelogInput, sessiondefinitionUncheckedCreateWithoutAttendancelogInput>
    connectOrCreate?: sessiondefinitionCreateOrConnectWithoutAttendancelogInput
    connect?: sessiondefinitionWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type Enumattendancelog_statusFieldUpdateOperationsInput = {
    set?: $Enums.attendancelog_status
  }

  export type employeeUpdateOneRequiredWithoutAttendancelogNestedInput = {
    create?: XOR<employeeCreateWithoutAttendancelogInput, employeeUncheckedCreateWithoutAttendancelogInput>
    connectOrCreate?: employeeCreateOrConnectWithoutAttendancelogInput
    upsert?: employeeUpsertWithoutAttendancelogInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutAttendancelogInput, employeeUpdateWithoutAttendancelogInput>, employeeUncheckedUpdateWithoutAttendancelogInput>
  }

  export type sessiondefinitionUpdateOneRequiredWithoutAttendancelogNestedInput = {
    create?: XOR<sessiondefinitionCreateWithoutAttendancelogInput, sessiondefinitionUncheckedCreateWithoutAttendancelogInput>
    connectOrCreate?: sessiondefinitionCreateOrConnectWithoutAttendancelogInput
    upsert?: sessiondefinitionUpsertWithoutAttendancelogInput
    connect?: sessiondefinitionWhereUniqueInput
    update?: XOR<XOR<sessiondefinitionUpdateToOneWithWhereWithoutAttendancelogInput, sessiondefinitionUpdateWithoutAttendancelogInput>, sessiondefinitionUncheckedUpdateWithoutAttendancelogInput>
  }

  export type departmentCreateNestedOneWithoutAttendancesummaryInput = {
    create?: XOR<departmentCreateWithoutAttendancesummaryInput, departmentUncheckedCreateWithoutAttendancesummaryInput>
    connectOrCreate?: departmentCreateOrConnectWithoutAttendancesummaryInput
    connect?: departmentWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutAttendancesummaryInput = {
    create?: XOR<employeeCreateWithoutAttendancesummaryInput, employeeUncheckedCreateWithoutAttendancesummaryInput>
    connectOrCreate?: employeeCreateOrConnectWithoutAttendancesummaryInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumattendancesummary_statusFieldUpdateOperationsInput = {
    set?: $Enums.attendancesummary_status
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type departmentUpdateOneWithoutAttendancesummaryNestedInput = {
    create?: XOR<departmentCreateWithoutAttendancesummaryInput, departmentUncheckedCreateWithoutAttendancesummaryInput>
    connectOrCreate?: departmentCreateOrConnectWithoutAttendancesummaryInput
    upsert?: departmentUpsertWithoutAttendancesummaryInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutAttendancesummaryInput, departmentUpdateWithoutAttendancesummaryInput>, departmentUncheckedUpdateWithoutAttendancesummaryInput>
  }

  export type employeeUpdateOneRequiredWithoutAttendancesummaryNestedInput = {
    create?: XOR<employeeCreateWithoutAttendancesummaryInput, employeeUncheckedCreateWithoutAttendancesummaryInput>
    connectOrCreate?: employeeCreateOrConnectWithoutAttendancesummaryInput
    upsert?: employeeUpsertWithoutAttendancesummaryInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutAttendancesummaryInput, employeeUpdateWithoutAttendancesummaryInput>, employeeUncheckedUpdateWithoutAttendancesummaryInput>
  }

  export type employeeCreateNestedOneWithoutComplaintInput = {
    create?: XOR<employeeCreateWithoutComplaintInput, employeeUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: employeeCreateOrConnectWithoutComplaintInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumcomplaint_statusFieldUpdateOperationsInput = {
    set?: $Enums.complaint_status
  }

  export type employeeUpdateOneRequiredWithoutComplaintNestedInput = {
    create?: XOR<employeeCreateWithoutComplaintInput, employeeUncheckedCreateWithoutComplaintInput>
    connectOrCreate?: employeeCreateOrConnectWithoutComplaintInput
    upsert?: employeeUpsertWithoutComplaintInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutComplaintInput, employeeUpdateWithoutComplaintInput>, employeeUncheckedUpdateWithoutComplaintInput>
  }

  export type attendancesummaryCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput> | attendancesummaryCreateWithoutDepartmentInput[] | attendancesummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutDepartmentInput | attendancesummaryCreateOrConnectWithoutDepartmentInput[]
    createMany?: attendancesummaryCreateManyDepartmentInputEnvelope
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
  }

  export type departmentCreateNestedOneWithoutOther_departmentInput = {
    create?: XOR<departmentCreateWithoutOther_departmentInput, departmentUncheckedCreateWithoutOther_departmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutOther_departmentInput
    connect?: departmentWhereUniqueInput
  }

  export type departmentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput> | departmentCreateWithoutDepartmentInput[] | departmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentInput | departmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: departmentCreateManyDepartmentInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type payrollpolicyCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<payrollpolicyCreateWithoutDepartmentInput, payrollpolicyUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: payrollpolicyCreateOrConnectWithoutDepartmentInput
    connect?: payrollpolicyWhereUniqueInput
  }

  export type employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_departmentIdTodepartmentInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput> | attendancesummaryCreateWithoutDepartmentInput[] | attendancesummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutDepartmentInput | attendancesummaryCreateOrConnectWithoutDepartmentInput[]
    createMany?: attendancesummaryCreateManyDepartmentInputEnvelope
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
  }

  export type departmentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput> | departmentCreateWithoutDepartmentInput[] | departmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentInput | departmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: departmentCreateManyDepartmentInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_departmentIdTodepartmentInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type attendancesummaryUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput> | attendancesummaryCreateWithoutDepartmentInput[] | attendancesummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutDepartmentInput | attendancesummaryCreateOrConnectWithoutDepartmentInput[]
    upsert?: attendancesummaryUpsertWithWhereUniqueWithoutDepartmentInput | attendancesummaryUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: attendancesummaryCreateManyDepartmentInputEnvelope
    set?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    disconnect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    delete?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    update?: attendancesummaryUpdateWithWhereUniqueWithoutDepartmentInput | attendancesummaryUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: attendancesummaryUpdateManyWithWhereWithoutDepartmentInput | attendancesummaryUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
  }

  export type departmentUpdateOneWithoutOther_departmentNestedInput = {
    create?: XOR<departmentCreateWithoutOther_departmentInput, departmentUncheckedCreateWithoutOther_departmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutOther_departmentInput
    upsert?: departmentUpsertWithoutOther_departmentInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutOther_departmentInput, departmentUpdateWithoutOther_departmentInput>, departmentUncheckedUpdateWithoutOther_departmentInput>
  }

  export type departmentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput> | departmentCreateWithoutDepartmentInput[] | departmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentInput | departmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutDepartmentInput | departmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: departmentCreateManyDepartmentInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutDepartmentInput | departmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutDepartmentInput | departmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type payrollpolicyUpdateOneWithoutDepartmentNestedInput = {
    create?: XOR<payrollpolicyCreateWithoutDepartmentInput, payrollpolicyUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: payrollpolicyCreateOrConnectWithoutDepartmentInput
    upsert?: payrollpolicyUpsertWithoutDepartmentInput
    disconnect?: payrollpolicyWhereInput | boolean
    delete?: payrollpolicyWhereInput | boolean
    connect?: payrollpolicyWhereUniqueInput
    update?: XOR<XOR<payrollpolicyUpdateToOneWithWhereWithoutDepartmentInput, payrollpolicyUpdateWithoutDepartmentInput>, payrollpolicyUncheckedUpdateWithoutDepartmentInput>
  }

  export type employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpsertWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_departmentIdTodepartmentInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpdateWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpdateManyWithWhereWithoutDepartment_employee_departmentIdTodepartmentInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpsertWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpdateWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpdateManyWithWhereWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput> | attendancesummaryCreateWithoutDepartmentInput[] | attendancesummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutDepartmentInput | attendancesummaryCreateOrConnectWithoutDepartmentInput[]
    upsert?: attendancesummaryUpsertWithWhereUniqueWithoutDepartmentInput | attendancesummaryUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: attendancesummaryCreateManyDepartmentInputEnvelope
    set?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    disconnect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    delete?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    update?: attendancesummaryUpdateWithWhereUniqueWithoutDepartmentInput | attendancesummaryUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: attendancesummaryUpdateManyWithWhereWithoutDepartmentInput | attendancesummaryUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
  }

  export type departmentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput> | departmentCreateWithoutDepartmentInput[] | departmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutDepartmentInput | departmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutDepartmentInput | departmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: departmentCreateManyDepartmentInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutDepartmentInput | departmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutDepartmentInput | departmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpsertWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_departmentIdTodepartmentInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpdateWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutDepartment_employee_departmentIdTodepartmentInput | employeeUpdateManyWithWhereWithoutDepartment_employee_departmentIdTodepartmentInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput = {
    create?: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput> | employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[] | employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpsertWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    createMany?: employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpdateWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutDepartment_employee_subDepartmentIdTodepartmentInput | employeeUpdateManyWithWhereWithoutDepartment_employee_subDepartmentIdTodepartmentInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_actorIdToemployeeInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_targetIdToemployeeInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type attendancelogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput> | attendancelogCreateWithoutEmployeeInput[] | attendancelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutEmployeeInput | attendancelogCreateOrConnectWithoutEmployeeInput[]
    createMany?: attendancelogCreateManyEmployeeInputEnvelope
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
  }

  export type attendancesummaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput> | attendancesummaryCreateWithoutEmployeeInput[] | attendancesummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutEmployeeInput | attendancesummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: attendancesummaryCreateManyEmployeeInputEnvelope
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
  }

  export type complaintCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput> | complaintCreateWithoutEmployeeInput[] | complaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: complaintCreateOrConnectWithoutEmployeeInput | complaintCreateOrConnectWithoutEmployeeInput[]
    createMany?: complaintCreateManyEmployeeInputEnvelope
    connect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
  }

  export type agreementstatusCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<agreementstatusCreateWithoutEmployeeInput, agreementstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: agreementstatusCreateOrConnectWithoutEmployeeInput
    connect?: agreementstatusWhereUniqueInput
  }

  export type departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput = {
    create?: XOR<departmentCreateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_departmentIdTodepartmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutEmployee_employee_departmentIdTodepartmentInput
    connect?: departmentWhereUniqueInput
  }

  export type employmenttypeCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<employmenttypeCreateWithoutEmployeeInput, employmenttypeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: employmenttypeCreateOrConnectWithoutEmployeeInput
    connect?: employmenttypeWhereUniqueInput
  }

  export type jobstatusCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<jobstatusCreateWithoutEmployeeInput, jobstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: jobstatusCreateOrConnectWithoutEmployeeInput
    connect?: jobstatusWhereUniqueInput
  }

  export type maritalstatusCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<maritalstatusCreateWithoutEmployeeInput, maritalstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: maritalstatusCreateOrConnectWithoutEmployeeInput
    connect?: maritalstatusWhereUniqueInput
  }

  export type positionCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<positionCreateWithoutEmployeeInput, positionUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: positionCreateOrConnectWithoutEmployeeInput
    connect?: positionWhereUniqueInput
  }

  export type departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    create?: XOR<departmentCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    connect?: departmentWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<userCreateWithoutEmployeeInput, userUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: userCreateOrConnectWithoutEmployeeInput
    connect?: userWhereUniqueInput
  }

  export type employeeshiftCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput> | employeeshiftCreateWithoutEmployeeInput[] | employeeshiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutEmployeeInput | employeeshiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: employeeshiftCreateManyEmployeeInputEnvelope
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
  }

  export type leaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput> | leaveCreateWithoutEmployeeInput[] | leaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutEmployeeInput | leaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: leaveCreateManyEmployeeInputEnvelope
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
  }

  export type meetingCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput> | meetingCreateWithoutEmployeeInput[] | meetingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: meetingCreateOrConnectWithoutEmployeeInput | meetingCreateOrConnectWithoutEmployeeInput[]
    createMany?: meetingCreateManyEmployeeInputEnvelope
    connect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
  }

  export type overtimelogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput> | overtimelogCreateWithoutEmployeeInput[] | overtimelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutEmployeeInput | overtimelogCreateOrConnectWithoutEmployeeInput[]
    createMany?: overtimelogCreateManyEmployeeInputEnvelope
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
  }

  export type performancereviewCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput> | performancereviewCreateWithoutEmployeeInput[] | performancereviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: performancereviewCreateOrConnectWithoutEmployeeInput | performancereviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: performancereviewCreateManyEmployeeInputEnvelope
    connect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
  }

  export type salaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput> | salaryCreateWithoutEmployeeInput[] | salaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: salaryCreateOrConnectWithoutEmployeeInput | salaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: salaryCreateManyEmployeeInputEnvelope
    connect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
  }

  export type terminationCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput> | terminationCreateWithoutEmployeeInput[] | terminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: terminationCreateOrConnectWithoutEmployeeInput | terminationCreateOrConnectWithoutEmployeeInput[]
    createMany?: terminationCreateManyEmployeeInputEnvelope
    connect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
  }

  export type activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_actorIdToemployeeInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_targetIdToemployeeInputEnvelope
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
  }

  export type attendancelogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput> | attendancelogCreateWithoutEmployeeInput[] | attendancelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutEmployeeInput | attendancelogCreateOrConnectWithoutEmployeeInput[]
    createMany?: attendancelogCreateManyEmployeeInputEnvelope
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
  }

  export type attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput> | attendancesummaryCreateWithoutEmployeeInput[] | attendancesummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutEmployeeInput | attendancesummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: attendancesummaryCreateManyEmployeeInputEnvelope
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
  }

  export type complaintUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput> | complaintCreateWithoutEmployeeInput[] | complaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: complaintCreateOrConnectWithoutEmployeeInput | complaintCreateOrConnectWithoutEmployeeInput[]
    createMany?: complaintCreateManyEmployeeInputEnvelope
    connect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
  }

  export type employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput> | employeeshiftCreateWithoutEmployeeInput[] | employeeshiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutEmployeeInput | employeeshiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: employeeshiftCreateManyEmployeeInputEnvelope
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
  }

  export type leaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput> | leaveCreateWithoutEmployeeInput[] | leaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutEmployeeInput | leaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: leaveCreateManyEmployeeInputEnvelope
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
  }

  export type meetingUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput> | meetingCreateWithoutEmployeeInput[] | meetingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: meetingCreateOrConnectWithoutEmployeeInput | meetingCreateOrConnectWithoutEmployeeInput[]
    createMany?: meetingCreateManyEmployeeInputEnvelope
    connect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
  }

  export type overtimelogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput> | overtimelogCreateWithoutEmployeeInput[] | overtimelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutEmployeeInput | overtimelogCreateOrConnectWithoutEmployeeInput[]
    createMany?: overtimelogCreateManyEmployeeInputEnvelope
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
  }

  export type performancereviewUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput> | performancereviewCreateWithoutEmployeeInput[] | performancereviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: performancereviewCreateOrConnectWithoutEmployeeInput | performancereviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: performancereviewCreateManyEmployeeInputEnvelope
    connect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
  }

  export type salaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput> | salaryCreateWithoutEmployeeInput[] | salaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: salaryCreateOrConnectWithoutEmployeeInput | salaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: salaryCreateManyEmployeeInputEnvelope
    connect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
  }

  export type terminationUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput> | terminationCreateWithoutEmployeeInput[] | terminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: terminationCreateOrConnectWithoutEmployeeInput | terminationCreateOrConnectWithoutEmployeeInput[]
    createMany?: terminationCreateManyEmployeeInputEnvelope
    connect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
  }

  export type Enumemployee_sexFieldUpdateOperationsInput = {
    set?: $Enums.employee_sex
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_actorIdToemployeeInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpdateManyWithWhereWithoutEmployee_activitylog_actorIdToemployeeInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_targetIdToemployeeInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpdateManyWithWhereWithoutEmployee_activitylog_targetIdToemployeeInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type attendancelogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput> | attendancelogCreateWithoutEmployeeInput[] | attendancelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutEmployeeInput | attendancelogCreateOrConnectWithoutEmployeeInput[]
    upsert?: attendancelogUpsertWithWhereUniqueWithoutEmployeeInput | attendancelogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: attendancelogCreateManyEmployeeInputEnvelope
    set?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    disconnect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    delete?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    update?: attendancelogUpdateWithWhereUniqueWithoutEmployeeInput | attendancelogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: attendancelogUpdateManyWithWhereWithoutEmployeeInput | attendancelogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
  }

  export type attendancesummaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput> | attendancesummaryCreateWithoutEmployeeInput[] | attendancesummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutEmployeeInput | attendancesummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: attendancesummaryUpsertWithWhereUniqueWithoutEmployeeInput | attendancesummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: attendancesummaryCreateManyEmployeeInputEnvelope
    set?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    disconnect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    delete?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    update?: attendancesummaryUpdateWithWhereUniqueWithoutEmployeeInput | attendancesummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: attendancesummaryUpdateManyWithWhereWithoutEmployeeInput | attendancesummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
  }

  export type complaintUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput> | complaintCreateWithoutEmployeeInput[] | complaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: complaintCreateOrConnectWithoutEmployeeInput | complaintCreateOrConnectWithoutEmployeeInput[]
    upsert?: complaintUpsertWithWhereUniqueWithoutEmployeeInput | complaintUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: complaintCreateManyEmployeeInputEnvelope
    set?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    disconnect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    delete?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    connect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    update?: complaintUpdateWithWhereUniqueWithoutEmployeeInput | complaintUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: complaintUpdateManyWithWhereWithoutEmployeeInput | complaintUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: complaintScalarWhereInput | complaintScalarWhereInput[]
  }

  export type agreementstatusUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<agreementstatusCreateWithoutEmployeeInput, agreementstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: agreementstatusCreateOrConnectWithoutEmployeeInput
    upsert?: agreementstatusUpsertWithoutEmployeeInput
    disconnect?: agreementstatusWhereInput | boolean
    delete?: agreementstatusWhereInput | boolean
    connect?: agreementstatusWhereUniqueInput
    update?: XOR<XOR<agreementstatusUpdateToOneWithWhereWithoutEmployeeInput, agreementstatusUpdateWithoutEmployeeInput>, agreementstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput = {
    create?: XOR<departmentCreateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_departmentIdTodepartmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutEmployee_employee_departmentIdTodepartmentInput
    upsert?: departmentUpsertWithoutEmployee_employee_departmentIdTodepartmentInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUpdateWithoutEmployee_employee_departmentIdTodepartmentInput>, departmentUncheckedUpdateWithoutEmployee_employee_departmentIdTodepartmentInput>
  }

  export type employmenttypeUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<employmenttypeCreateWithoutEmployeeInput, employmenttypeUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: employmenttypeCreateOrConnectWithoutEmployeeInput
    upsert?: employmenttypeUpsertWithoutEmployeeInput
    disconnect?: employmenttypeWhereInput | boolean
    delete?: employmenttypeWhereInput | boolean
    connect?: employmenttypeWhereUniqueInput
    update?: XOR<XOR<employmenttypeUpdateToOneWithWhereWithoutEmployeeInput, employmenttypeUpdateWithoutEmployeeInput>, employmenttypeUncheckedUpdateWithoutEmployeeInput>
  }

  export type jobstatusUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<jobstatusCreateWithoutEmployeeInput, jobstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: jobstatusCreateOrConnectWithoutEmployeeInput
    upsert?: jobstatusUpsertWithoutEmployeeInput
    disconnect?: jobstatusWhereInput | boolean
    delete?: jobstatusWhereInput | boolean
    connect?: jobstatusWhereUniqueInput
    update?: XOR<XOR<jobstatusUpdateToOneWithWhereWithoutEmployeeInput, jobstatusUpdateWithoutEmployeeInput>, jobstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type maritalstatusUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<maritalstatusCreateWithoutEmployeeInput, maritalstatusUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: maritalstatusCreateOrConnectWithoutEmployeeInput
    upsert?: maritalstatusUpsertWithoutEmployeeInput
    disconnect?: maritalstatusWhereInput | boolean
    delete?: maritalstatusWhereInput | boolean
    connect?: maritalstatusWhereUniqueInput
    update?: XOR<XOR<maritalstatusUpdateToOneWithWhereWithoutEmployeeInput, maritalstatusUpdateWithoutEmployeeInput>, maritalstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type positionUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<positionCreateWithoutEmployeeInput, positionUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: positionCreateOrConnectWithoutEmployeeInput
    upsert?: positionUpsertWithoutEmployeeInput
    disconnect?: positionWhereInput | boolean
    delete?: positionWhereInput | boolean
    connect?: positionWhereUniqueInput
    update?: XOR<XOR<positionUpdateToOneWithWhereWithoutEmployeeInput, positionUpdateWithoutEmployeeInput>, positionUncheckedUpdateWithoutEmployeeInput>
  }

  export type departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput = {
    create?: XOR<departmentCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
    connectOrCreate?: departmentCreateOrConnectWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    upsert?: departmentUpsertWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    disconnect?: departmentWhereInput | boolean
    delete?: departmentWhereInput | boolean
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>, departmentUncheckedUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
  }

  export type userUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<userCreateWithoutEmployeeInput, userUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: userCreateOrConnectWithoutEmployeeInput
    upsert?: userUpsertWithoutEmployeeInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEmployeeInput, userUpdateWithoutEmployeeInput>, userUncheckedUpdateWithoutEmployeeInput>
  }

  export type employeeshiftUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput> | employeeshiftCreateWithoutEmployeeInput[] | employeeshiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutEmployeeInput | employeeshiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: employeeshiftUpsertWithWhereUniqueWithoutEmployeeInput | employeeshiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employeeshiftCreateManyEmployeeInputEnvelope
    set?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    disconnect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    delete?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    update?: employeeshiftUpdateWithWhereUniqueWithoutEmployeeInput | employeeshiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employeeshiftUpdateManyWithWhereWithoutEmployeeInput | employeeshiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
  }

  export type leaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput> | leaveCreateWithoutEmployeeInput[] | leaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutEmployeeInput | leaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: leaveUpsertWithWhereUniqueWithoutEmployeeInput | leaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: leaveCreateManyEmployeeInputEnvelope
    set?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    disconnect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    delete?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    update?: leaveUpdateWithWhereUniqueWithoutEmployeeInput | leaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: leaveUpdateManyWithWhereWithoutEmployeeInput | leaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: leaveScalarWhereInput | leaveScalarWhereInput[]
  }

  export type meetingUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput> | meetingCreateWithoutEmployeeInput[] | meetingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: meetingCreateOrConnectWithoutEmployeeInput | meetingCreateOrConnectWithoutEmployeeInput[]
    upsert?: meetingUpsertWithWhereUniqueWithoutEmployeeInput | meetingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: meetingCreateManyEmployeeInputEnvelope
    set?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    disconnect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    delete?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    connect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    update?: meetingUpdateWithWhereUniqueWithoutEmployeeInput | meetingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: meetingUpdateManyWithWhereWithoutEmployeeInput | meetingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: meetingScalarWhereInput | meetingScalarWhereInput[]
  }

  export type overtimelogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput> | overtimelogCreateWithoutEmployeeInput[] | overtimelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutEmployeeInput | overtimelogCreateOrConnectWithoutEmployeeInput[]
    upsert?: overtimelogUpsertWithWhereUniqueWithoutEmployeeInput | overtimelogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: overtimelogCreateManyEmployeeInputEnvelope
    set?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    disconnect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    delete?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    update?: overtimelogUpdateWithWhereUniqueWithoutEmployeeInput | overtimelogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: overtimelogUpdateManyWithWhereWithoutEmployeeInput | overtimelogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
  }

  export type performancereviewUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput> | performancereviewCreateWithoutEmployeeInput[] | performancereviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: performancereviewCreateOrConnectWithoutEmployeeInput | performancereviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: performancereviewUpsertWithWhereUniqueWithoutEmployeeInput | performancereviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: performancereviewCreateManyEmployeeInputEnvelope
    set?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    disconnect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    delete?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    connect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    update?: performancereviewUpdateWithWhereUniqueWithoutEmployeeInput | performancereviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: performancereviewUpdateManyWithWhereWithoutEmployeeInput | performancereviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: performancereviewScalarWhereInput | performancereviewScalarWhereInput[]
  }

  export type salaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput> | salaryCreateWithoutEmployeeInput[] | salaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: salaryCreateOrConnectWithoutEmployeeInput | salaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: salaryUpsertWithWhereUniqueWithoutEmployeeInput | salaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: salaryCreateManyEmployeeInputEnvelope
    set?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    disconnect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    delete?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    connect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    update?: salaryUpdateWithWhereUniqueWithoutEmployeeInput | salaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: salaryUpdateManyWithWhereWithoutEmployeeInput | salaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: salaryScalarWhereInput | salaryScalarWhereInput[]
  }

  export type terminationUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput> | terminationCreateWithoutEmployeeInput[] | terminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: terminationCreateOrConnectWithoutEmployeeInput | terminationCreateOrConnectWithoutEmployeeInput[]
    upsert?: terminationUpsertWithWhereUniqueWithoutEmployeeInput | terminationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: terminationCreateManyEmployeeInputEnvelope
    set?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    disconnect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    delete?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    connect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    update?: terminationUpdateWithWhereUniqueWithoutEmployeeInput | terminationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: terminationUpdateManyWithWhereWithoutEmployeeInput | terminationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: terminationScalarWhereInput | terminationScalarWhereInput[]
  }

  export type activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_actorIdToemployeeInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutEmployee_activitylog_actorIdToemployeeInput | activitylogUpdateManyWithWhereWithoutEmployee_activitylog_actorIdToemployeeInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput = {
    create?: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput> | activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput[] | activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput[]
    connectOrCreate?: activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput[]
    upsert?: activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput[]
    createMany?: activitylogCreateManyEmployee_activitylog_targetIdToemployeeInputEnvelope
    set?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    disconnect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    delete?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    connect?: activitylogWhereUniqueInput | activitylogWhereUniqueInput[]
    update?: activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput[]
    updateMany?: activitylogUpdateManyWithWhereWithoutEmployee_activitylog_targetIdToemployeeInput | activitylogUpdateManyWithWhereWithoutEmployee_activitylog_targetIdToemployeeInput[]
    deleteMany?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
  }

  export type attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput> | attendancelogCreateWithoutEmployeeInput[] | attendancelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutEmployeeInput | attendancelogCreateOrConnectWithoutEmployeeInput[]
    upsert?: attendancelogUpsertWithWhereUniqueWithoutEmployeeInput | attendancelogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: attendancelogCreateManyEmployeeInputEnvelope
    set?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    disconnect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    delete?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    update?: attendancelogUpdateWithWhereUniqueWithoutEmployeeInput | attendancelogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: attendancelogUpdateManyWithWhereWithoutEmployeeInput | attendancelogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
  }

  export type attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput> | attendancesummaryCreateWithoutEmployeeInput[] | attendancesummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: attendancesummaryCreateOrConnectWithoutEmployeeInput | attendancesummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: attendancesummaryUpsertWithWhereUniqueWithoutEmployeeInput | attendancesummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: attendancesummaryCreateManyEmployeeInputEnvelope
    set?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    disconnect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    delete?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    connect?: attendancesummaryWhereUniqueInput | attendancesummaryWhereUniqueInput[]
    update?: attendancesummaryUpdateWithWhereUniqueWithoutEmployeeInput | attendancesummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: attendancesummaryUpdateManyWithWhereWithoutEmployeeInput | attendancesummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
  }

  export type complaintUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput> | complaintCreateWithoutEmployeeInput[] | complaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: complaintCreateOrConnectWithoutEmployeeInput | complaintCreateOrConnectWithoutEmployeeInput[]
    upsert?: complaintUpsertWithWhereUniqueWithoutEmployeeInput | complaintUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: complaintCreateManyEmployeeInputEnvelope
    set?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    disconnect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    delete?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    connect?: complaintWhereUniqueInput | complaintWhereUniqueInput[]
    update?: complaintUpdateWithWhereUniqueWithoutEmployeeInput | complaintUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: complaintUpdateManyWithWhereWithoutEmployeeInput | complaintUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: complaintScalarWhereInput | complaintScalarWhereInput[]
  }

  export type employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput> | employeeshiftCreateWithoutEmployeeInput[] | employeeshiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutEmployeeInput | employeeshiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: employeeshiftUpsertWithWhereUniqueWithoutEmployeeInput | employeeshiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employeeshiftCreateManyEmployeeInputEnvelope
    set?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    disconnect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    delete?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    update?: employeeshiftUpdateWithWhereUniqueWithoutEmployeeInput | employeeshiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employeeshiftUpdateManyWithWhereWithoutEmployeeInput | employeeshiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
  }

  export type leaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput> | leaveCreateWithoutEmployeeInput[] | leaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutEmployeeInput | leaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: leaveUpsertWithWhereUniqueWithoutEmployeeInput | leaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: leaveCreateManyEmployeeInputEnvelope
    set?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    disconnect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    delete?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    update?: leaveUpdateWithWhereUniqueWithoutEmployeeInput | leaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: leaveUpdateManyWithWhereWithoutEmployeeInput | leaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: leaveScalarWhereInput | leaveScalarWhereInput[]
  }

  export type meetingUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput> | meetingCreateWithoutEmployeeInput[] | meetingUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: meetingCreateOrConnectWithoutEmployeeInput | meetingCreateOrConnectWithoutEmployeeInput[]
    upsert?: meetingUpsertWithWhereUniqueWithoutEmployeeInput | meetingUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: meetingCreateManyEmployeeInputEnvelope
    set?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    disconnect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    delete?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    connect?: meetingWhereUniqueInput | meetingWhereUniqueInput[]
    update?: meetingUpdateWithWhereUniqueWithoutEmployeeInput | meetingUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: meetingUpdateManyWithWhereWithoutEmployeeInput | meetingUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: meetingScalarWhereInput | meetingScalarWhereInput[]
  }

  export type overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput> | overtimelogCreateWithoutEmployeeInput[] | overtimelogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutEmployeeInput | overtimelogCreateOrConnectWithoutEmployeeInput[]
    upsert?: overtimelogUpsertWithWhereUniqueWithoutEmployeeInput | overtimelogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: overtimelogCreateManyEmployeeInputEnvelope
    set?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    disconnect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    delete?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    update?: overtimelogUpdateWithWhereUniqueWithoutEmployeeInput | overtimelogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: overtimelogUpdateManyWithWhereWithoutEmployeeInput | overtimelogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
  }

  export type performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput> | performancereviewCreateWithoutEmployeeInput[] | performancereviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: performancereviewCreateOrConnectWithoutEmployeeInput | performancereviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: performancereviewUpsertWithWhereUniqueWithoutEmployeeInput | performancereviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: performancereviewCreateManyEmployeeInputEnvelope
    set?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    disconnect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    delete?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    connect?: performancereviewWhereUniqueInput | performancereviewWhereUniqueInput[]
    update?: performancereviewUpdateWithWhereUniqueWithoutEmployeeInput | performancereviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: performancereviewUpdateManyWithWhereWithoutEmployeeInput | performancereviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: performancereviewScalarWhereInput | performancereviewScalarWhereInput[]
  }

  export type salaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput> | salaryCreateWithoutEmployeeInput[] | salaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: salaryCreateOrConnectWithoutEmployeeInput | salaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: salaryUpsertWithWhereUniqueWithoutEmployeeInput | salaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: salaryCreateManyEmployeeInputEnvelope
    set?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    disconnect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    delete?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    connect?: salaryWhereUniqueInput | salaryWhereUniqueInput[]
    update?: salaryUpdateWithWhereUniqueWithoutEmployeeInput | salaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: salaryUpdateManyWithWhereWithoutEmployeeInput | salaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: salaryScalarWhereInput | salaryScalarWhereInput[]
  }

  export type terminationUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput> | terminationCreateWithoutEmployeeInput[] | terminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: terminationCreateOrConnectWithoutEmployeeInput | terminationCreateOrConnectWithoutEmployeeInput[]
    upsert?: terminationUpsertWithWhereUniqueWithoutEmployeeInput | terminationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: terminationCreateManyEmployeeInputEnvelope
    set?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    disconnect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    delete?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    connect?: terminationWhereUniqueInput | terminationWhereUniqueInput[]
    update?: terminationUpdateWithWhereUniqueWithoutEmployeeInput | terminationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: terminationUpdateManyWithWhereWithoutEmployeeInput | terminationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: terminationScalarWhereInput | terminationScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutEmployeeshiftInput = {
    create?: XOR<employeeCreateWithoutEmployeeshiftInput, employeeUncheckedCreateWithoutEmployeeshiftInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployeeshiftInput
    connect?: employeeWhereUniqueInput
  }

  export type shiftCreateNestedOneWithoutEmployeeshiftInput = {
    create?: XOR<shiftCreateWithoutEmployeeshiftInput, shiftUncheckedCreateWithoutEmployeeshiftInput>
    connectOrCreate?: shiftCreateOrConnectWithoutEmployeeshiftInput
    connect?: shiftWhereUniqueInput
  }

  export type employeeUpdateOneRequiredWithoutEmployeeshiftNestedInput = {
    create?: XOR<employeeCreateWithoutEmployeeshiftInput, employeeUncheckedCreateWithoutEmployeeshiftInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployeeshiftInput
    upsert?: employeeUpsertWithoutEmployeeshiftInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutEmployeeshiftInput, employeeUpdateWithoutEmployeeshiftInput>, employeeUncheckedUpdateWithoutEmployeeshiftInput>
  }

  export type shiftUpdateOneRequiredWithoutEmployeeshiftNestedInput = {
    create?: XOR<shiftCreateWithoutEmployeeshiftInput, shiftUncheckedCreateWithoutEmployeeshiftInput>
    connectOrCreate?: shiftCreateOrConnectWithoutEmployeeshiftInput
    upsert?: shiftUpsertWithoutEmployeeshiftInput
    connect?: shiftWhereUniqueInput
    update?: XOR<XOR<shiftUpdateToOneWithWhereWithoutEmployeeshiftInput, shiftUpdateWithoutEmployeeshiftInput>, shiftUncheckedUpdateWithoutEmployeeshiftInput>
  }

  export type employeeCreateNestedManyWithoutEmploymenttypeInput = {
    create?: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput> | employeeCreateWithoutEmploymenttypeInput[] | employeeUncheckedCreateWithoutEmploymenttypeInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutEmploymenttypeInput | employeeCreateOrConnectWithoutEmploymenttypeInput[]
    createMany?: employeeCreateManyEmploymenttypeInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutEmploymenttypeInput = {
    create?: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput> | employeeCreateWithoutEmploymenttypeInput[] | employeeUncheckedCreateWithoutEmploymenttypeInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutEmploymenttypeInput | employeeCreateOrConnectWithoutEmploymenttypeInput[]
    createMany?: employeeCreateManyEmploymenttypeInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutEmploymenttypeNestedInput = {
    create?: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput> | employeeCreateWithoutEmploymenttypeInput[] | employeeUncheckedCreateWithoutEmploymenttypeInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutEmploymenttypeInput | employeeCreateOrConnectWithoutEmploymenttypeInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutEmploymenttypeInput | employeeUpsertWithWhereUniqueWithoutEmploymenttypeInput[]
    createMany?: employeeCreateManyEmploymenttypeInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutEmploymenttypeInput | employeeUpdateWithWhereUniqueWithoutEmploymenttypeInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutEmploymenttypeInput | employeeUpdateManyWithWhereWithoutEmploymenttypeInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutEmploymenttypeNestedInput = {
    create?: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput> | employeeCreateWithoutEmploymenttypeInput[] | employeeUncheckedCreateWithoutEmploymenttypeInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutEmploymenttypeInput | employeeCreateOrConnectWithoutEmploymenttypeInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutEmploymenttypeInput | employeeUpsertWithWhereUniqueWithoutEmploymenttypeInput[]
    createMany?: employeeCreateManyEmploymenttypeInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutEmploymenttypeInput | employeeUpdateWithWhereUniqueWithoutEmploymenttypeInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutEmploymenttypeInput | employeeUpdateManyWithWhereWithoutEmploymenttypeInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type Enuminterview_resultFieldUpdateOperationsInput = {
    set?: $Enums.interview_result
  }

  export type employeeCreateNestedManyWithoutJobstatusInput = {
    create?: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput> | employeeCreateWithoutJobstatusInput[] | employeeUncheckedCreateWithoutJobstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutJobstatusInput | employeeCreateOrConnectWithoutJobstatusInput[]
    createMany?: employeeCreateManyJobstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutJobstatusInput = {
    create?: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput> | employeeCreateWithoutJobstatusInput[] | employeeUncheckedCreateWithoutJobstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutJobstatusInput | employeeCreateOrConnectWithoutJobstatusInput[]
    createMany?: employeeCreateManyJobstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutJobstatusNestedInput = {
    create?: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput> | employeeCreateWithoutJobstatusInput[] | employeeUncheckedCreateWithoutJobstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutJobstatusInput | employeeCreateOrConnectWithoutJobstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutJobstatusInput | employeeUpsertWithWhereUniqueWithoutJobstatusInput[]
    createMany?: employeeCreateManyJobstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutJobstatusInput | employeeUpdateWithWhereUniqueWithoutJobstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutJobstatusInput | employeeUpdateManyWithWhereWithoutJobstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutJobstatusNestedInput = {
    create?: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput> | employeeCreateWithoutJobstatusInput[] | employeeUncheckedCreateWithoutJobstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutJobstatusInput | employeeCreateOrConnectWithoutJobstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutJobstatusInput | employeeUpsertWithWhereUniqueWithoutJobstatusInput[]
    createMany?: employeeCreateManyJobstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutJobstatusInput | employeeUpdateWithWhereUniqueWithoutJobstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutJobstatusInput | employeeUpdateManyWithWhereWithoutJobstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutLeaveInput = {
    create?: XOR<userCreateWithoutLeaveInput, userUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: userCreateOrConnectWithoutLeaveInput
    connect?: userWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutLeaveInput = {
    create?: XOR<employeeCreateWithoutLeaveInput, employeeUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: employeeCreateOrConnectWithoutLeaveInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumleave_leaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.leave_leaveType
  }

  export type Enumleave_statusFieldUpdateOperationsInput = {
    set?: $Enums.leave_status
  }

  export type userUpdateOneWithoutLeaveNestedInput = {
    create?: XOR<userCreateWithoutLeaveInput, userUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: userCreateOrConnectWithoutLeaveInput
    upsert?: userUpsertWithoutLeaveInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutLeaveInput, userUpdateWithoutLeaveInput>, userUncheckedUpdateWithoutLeaveInput>
  }

  export type employeeUpdateOneRequiredWithoutLeaveNestedInput = {
    create?: XOR<employeeCreateWithoutLeaveInput, employeeUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: employeeCreateOrConnectWithoutLeaveInput
    upsert?: employeeUpsertWithoutLeaveInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutLeaveInput, employeeUpdateWithoutLeaveInput>, employeeUncheckedUpdateWithoutLeaveInput>
  }

  export type employeeCreateNestedManyWithoutMaritalstatusInput = {
    create?: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput> | employeeCreateWithoutMaritalstatusInput[] | employeeUncheckedCreateWithoutMaritalstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutMaritalstatusInput | employeeCreateOrConnectWithoutMaritalstatusInput[]
    createMany?: employeeCreateManyMaritalstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutMaritalstatusInput = {
    create?: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput> | employeeCreateWithoutMaritalstatusInput[] | employeeUncheckedCreateWithoutMaritalstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutMaritalstatusInput | employeeCreateOrConnectWithoutMaritalstatusInput[]
    createMany?: employeeCreateManyMaritalstatusInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutMaritalstatusNestedInput = {
    create?: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput> | employeeCreateWithoutMaritalstatusInput[] | employeeUncheckedCreateWithoutMaritalstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutMaritalstatusInput | employeeCreateOrConnectWithoutMaritalstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutMaritalstatusInput | employeeUpsertWithWhereUniqueWithoutMaritalstatusInput[]
    createMany?: employeeCreateManyMaritalstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutMaritalstatusInput | employeeUpdateWithWhereUniqueWithoutMaritalstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutMaritalstatusInput | employeeUpdateManyWithWhereWithoutMaritalstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutMaritalstatusNestedInput = {
    create?: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput> | employeeCreateWithoutMaritalstatusInput[] | employeeUncheckedCreateWithoutMaritalstatusInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutMaritalstatusInput | employeeCreateOrConnectWithoutMaritalstatusInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutMaritalstatusInput | employeeUpsertWithWhereUniqueWithoutMaritalstatusInput[]
    createMany?: employeeCreateManyMaritalstatusInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutMaritalstatusInput | employeeUpdateWithWhereUniqueWithoutMaritalstatusInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutMaritalstatusInput | employeeUpdateManyWithWhereWithoutMaritalstatusInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutMeetingInput = {
    create?: XOR<employeeCreateWithoutMeetingInput, employeeUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMeetingInput
    connect?: employeeWhereUniqueInput
  }

  export type employeeUpdateOneWithoutMeetingNestedInput = {
    create?: XOR<employeeCreateWithoutMeetingInput, employeeUncheckedCreateWithoutMeetingInput>
    connectOrCreate?: employeeCreateOrConnectWithoutMeetingInput
    upsert?: employeeUpsertWithoutMeetingInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutMeetingInput, employeeUpdateWithoutMeetingInput>, employeeUncheckedUpdateWithoutMeetingInput>
  }

  export type userCreateNestedOneWithoutOvertimelogInput = {
    create?: XOR<userCreateWithoutOvertimelogInput, userUncheckedCreateWithoutOvertimelogInput>
    connectOrCreate?: userCreateOrConnectWithoutOvertimelogInput
    connect?: userWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutOvertimelogInput = {
    create?: XOR<employeeCreateWithoutOvertimelogInput, employeeUncheckedCreateWithoutOvertimelogInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOvertimelogInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumovertimelog_approvalStatusFieldUpdateOperationsInput = {
    set?: $Enums.overtimelog_approvalStatus
  }

  export type Enumovertimelog_compensationMethodFieldUpdateOperationsInput = {
    set?: $Enums.overtimelog_compensationMethod
  }

  export type Enumovertimelog_overtimeTypeFieldUpdateOperationsInput = {
    set?: $Enums.overtimelog_overtimeType
  }

  export type userUpdateOneWithoutOvertimelogNestedInput = {
    create?: XOR<userCreateWithoutOvertimelogInput, userUncheckedCreateWithoutOvertimelogInput>
    connectOrCreate?: userCreateOrConnectWithoutOvertimelogInput
    upsert?: userUpsertWithoutOvertimelogInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutOvertimelogInput, userUpdateWithoutOvertimelogInput>, userUncheckedUpdateWithoutOvertimelogInput>
  }

  export type employeeUpdateOneRequiredWithoutOvertimelogNestedInput = {
    create?: XOR<employeeCreateWithoutOvertimelogInput, employeeUncheckedCreateWithoutOvertimelogInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOvertimelogInput
    upsert?: employeeUpsertWithoutOvertimelogInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutOvertimelogInput, employeeUpdateWithoutOvertimelogInput>, employeeUncheckedUpdateWithoutOvertimelogInput>
  }

  export type departmentCreateNestedManyWithoutPayrollpolicyInput = {
    create?: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput> | departmentCreateWithoutPayrollpolicyInput[] | departmentUncheckedCreateWithoutPayrollpolicyInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutPayrollpolicyInput | departmentCreateOrConnectWithoutPayrollpolicyInput[]
    createMany?: departmentCreateManyPayrollpolicyInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type departmentUncheckedCreateNestedManyWithoutPayrollpolicyInput = {
    create?: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput> | departmentCreateWithoutPayrollpolicyInput[] | departmentUncheckedCreateWithoutPayrollpolicyInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutPayrollpolicyInput | departmentCreateOrConnectWithoutPayrollpolicyInput[]
    createMany?: departmentCreateManyPayrollpolicyInputEnvelope
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
  }

  export type departmentUpdateManyWithoutPayrollpolicyNestedInput = {
    create?: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput> | departmentCreateWithoutPayrollpolicyInput[] | departmentUncheckedCreateWithoutPayrollpolicyInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutPayrollpolicyInput | departmentCreateOrConnectWithoutPayrollpolicyInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutPayrollpolicyInput | departmentUpsertWithWhereUniqueWithoutPayrollpolicyInput[]
    createMany?: departmentCreateManyPayrollpolicyInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutPayrollpolicyInput | departmentUpdateWithWhereUniqueWithoutPayrollpolicyInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutPayrollpolicyInput | departmentUpdateManyWithWhereWithoutPayrollpolicyInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type departmentUncheckedUpdateManyWithoutPayrollpolicyNestedInput = {
    create?: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput> | departmentCreateWithoutPayrollpolicyInput[] | departmentUncheckedCreateWithoutPayrollpolicyInput[]
    connectOrCreate?: departmentCreateOrConnectWithoutPayrollpolicyInput | departmentCreateOrConnectWithoutPayrollpolicyInput[]
    upsert?: departmentUpsertWithWhereUniqueWithoutPayrollpolicyInput | departmentUpsertWithWhereUniqueWithoutPayrollpolicyInput[]
    createMany?: departmentCreateManyPayrollpolicyInputEnvelope
    set?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    disconnect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    delete?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    connect?: departmentWhereUniqueInput | departmentWhereUniqueInput[]
    update?: departmentUpdateWithWhereUniqueWithoutPayrollpolicyInput | departmentUpdateWithWhereUniqueWithoutPayrollpolicyInput[]
    updateMany?: departmentUpdateManyWithWhereWithoutPayrollpolicyInput | departmentUpdateManyWithWhereWithoutPayrollpolicyInput[]
    deleteMany?: departmentScalarWhereInput | departmentScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutPerformancereviewInput = {
    create?: XOR<employeeCreateWithoutPerformancereviewInput, employeeUncheckedCreateWithoutPerformancereviewInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPerformancereviewInput
    connect?: employeeWhereUniqueInput
  }

  export type employeeUpdateOneRequiredWithoutPerformancereviewNestedInput = {
    create?: XOR<employeeCreateWithoutPerformancereviewInput, employeeUncheckedCreateWithoutPerformancereviewInput>
    connectOrCreate?: employeeCreateOrConnectWithoutPerformancereviewInput
    upsert?: employeeUpsertWithoutPerformancereviewInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutPerformancereviewInput, employeeUpdateWithoutPerformancereviewInput>, employeeUncheckedUpdateWithoutPerformancereviewInput>
  }

  export type employeeCreateNestedManyWithoutPositionInput = {
    create?: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput> | employeeCreateWithoutPositionInput[] | employeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutPositionInput | employeeCreateOrConnectWithoutPositionInput[]
    createMany?: employeeCreateManyPositionInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput> | employeeCreateWithoutPositionInput[] | employeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutPositionInput | employeeCreateOrConnectWithoutPositionInput[]
    createMany?: employeeCreateManyPositionInputEnvelope
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
  }

  export type employeeUpdateManyWithoutPositionNestedInput = {
    create?: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput> | employeeCreateWithoutPositionInput[] | employeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutPositionInput | employeeCreateOrConnectWithoutPositionInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutPositionInput | employeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: employeeCreateManyPositionInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutPositionInput | employeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutPositionInput | employeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type employeeUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput> | employeeCreateWithoutPositionInput[] | employeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: employeeCreateOrConnectWithoutPositionInput | employeeCreateOrConnectWithoutPositionInput[]
    upsert?: employeeUpsertWithWhereUniqueWithoutPositionInput | employeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: employeeCreateManyPositionInputEnvelope
    set?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    disconnect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    delete?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    connect?: employeeWhereUniqueInput | employeeWhereUniqueInput[]
    update?: employeeUpdateWithWhereUniqueWithoutPositionInput | employeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: employeeUpdateManyWithWhereWithoutPositionInput | employeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: employeeScalarWhereInput | employeeScalarWhereInput[]
  }

  export type userroleCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type userroleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput> | userroleCreateWithoutRoleInput[] | userroleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutRoleInput | userroleCreateOrConnectWithoutRoleInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutRoleInput | userroleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: userroleCreateManyRoleInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutRoleInput | userroleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutRoleInput | userroleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutSalaryRecordsInput = {
    create?: XOR<employeeCreateWithoutSalaryRecordsInput, employeeUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSalaryRecordsInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumsalary_statusFieldUpdateOperationsInput = {
    set?: $Enums.salary_status
  }

  export type employeeUpdateOneRequiredWithoutSalaryRecordsNestedInput = {
    create?: XOR<employeeCreateWithoutSalaryRecordsInput, employeeUncheckedCreateWithoutSalaryRecordsInput>
    connectOrCreate?: employeeCreateOrConnectWithoutSalaryRecordsInput
    upsert?: employeeUpsertWithoutSalaryRecordsInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutSalaryRecordsInput, employeeUpdateWithoutSalaryRecordsInput>, employeeUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type attendancelogCreateNestedManyWithoutSessiondefinitionInput = {
    create?: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput> | attendancelogCreateWithoutSessiondefinitionInput[] | attendancelogUncheckedCreateWithoutSessiondefinitionInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutSessiondefinitionInput | attendancelogCreateOrConnectWithoutSessiondefinitionInput[]
    createMany?: attendancelogCreateManySessiondefinitionInputEnvelope
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
  }

  export type attendancelogUncheckedCreateNestedManyWithoutSessiondefinitionInput = {
    create?: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput> | attendancelogCreateWithoutSessiondefinitionInput[] | attendancelogUncheckedCreateWithoutSessiondefinitionInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutSessiondefinitionInput | attendancelogCreateOrConnectWithoutSessiondefinitionInput[]
    createMany?: attendancelogCreateManySessiondefinitionInputEnvelope
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
  }

  export type attendancelogUpdateManyWithoutSessiondefinitionNestedInput = {
    create?: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput> | attendancelogCreateWithoutSessiondefinitionInput[] | attendancelogUncheckedCreateWithoutSessiondefinitionInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutSessiondefinitionInput | attendancelogCreateOrConnectWithoutSessiondefinitionInput[]
    upsert?: attendancelogUpsertWithWhereUniqueWithoutSessiondefinitionInput | attendancelogUpsertWithWhereUniqueWithoutSessiondefinitionInput[]
    createMany?: attendancelogCreateManySessiondefinitionInputEnvelope
    set?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    disconnect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    delete?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    update?: attendancelogUpdateWithWhereUniqueWithoutSessiondefinitionInput | attendancelogUpdateWithWhereUniqueWithoutSessiondefinitionInput[]
    updateMany?: attendancelogUpdateManyWithWhereWithoutSessiondefinitionInput | attendancelogUpdateManyWithWhereWithoutSessiondefinitionInput[]
    deleteMany?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
  }

  export type attendancelogUncheckedUpdateManyWithoutSessiondefinitionNestedInput = {
    create?: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput> | attendancelogCreateWithoutSessiondefinitionInput[] | attendancelogUncheckedCreateWithoutSessiondefinitionInput[]
    connectOrCreate?: attendancelogCreateOrConnectWithoutSessiondefinitionInput | attendancelogCreateOrConnectWithoutSessiondefinitionInput[]
    upsert?: attendancelogUpsertWithWhereUniqueWithoutSessiondefinitionInput | attendancelogUpsertWithWhereUniqueWithoutSessiondefinitionInput[]
    createMany?: attendancelogCreateManySessiondefinitionInputEnvelope
    set?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    disconnect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    delete?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    connect?: attendancelogWhereUniqueInput | attendancelogWhereUniqueInput[]
    update?: attendancelogUpdateWithWhereUniqueWithoutSessiondefinitionInput | attendancelogUpdateWithWhereUniqueWithoutSessiondefinitionInput[]
    updateMany?: attendancelogUpdateManyWithWhereWithoutSessiondefinitionInput | attendancelogUpdateManyWithWhereWithoutSessiondefinitionInput[]
    deleteMany?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
  }

  export type employeeshiftCreateNestedManyWithoutShiftInput = {
    create?: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput> | employeeshiftCreateWithoutShiftInput[] | employeeshiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutShiftInput | employeeshiftCreateOrConnectWithoutShiftInput[]
    createMany?: employeeshiftCreateManyShiftInputEnvelope
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
  }

  export type employeeshiftUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput> | employeeshiftCreateWithoutShiftInput[] | employeeshiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutShiftInput | employeeshiftCreateOrConnectWithoutShiftInput[]
    createMany?: employeeshiftCreateManyShiftInputEnvelope
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
  }

  export type employeeshiftUpdateManyWithoutShiftNestedInput = {
    create?: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput> | employeeshiftCreateWithoutShiftInput[] | employeeshiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutShiftInput | employeeshiftCreateOrConnectWithoutShiftInput[]
    upsert?: employeeshiftUpsertWithWhereUniqueWithoutShiftInput | employeeshiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: employeeshiftCreateManyShiftInputEnvelope
    set?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    disconnect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    delete?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    update?: employeeshiftUpdateWithWhereUniqueWithoutShiftInput | employeeshiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: employeeshiftUpdateManyWithWhereWithoutShiftInput | employeeshiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
  }

  export type employeeshiftUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput> | employeeshiftCreateWithoutShiftInput[] | employeeshiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: employeeshiftCreateOrConnectWithoutShiftInput | employeeshiftCreateOrConnectWithoutShiftInput[]
    upsert?: employeeshiftUpsertWithWhereUniqueWithoutShiftInput | employeeshiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: employeeshiftCreateManyShiftInputEnvelope
    set?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    disconnect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    delete?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    connect?: employeeshiftWhereUniqueInput | employeeshiftWhereUniqueInput[]
    update?: employeeshiftUpdateWithWhereUniqueWithoutShiftInput | employeeshiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: employeeshiftUpdateManyWithWhereWithoutShiftInput | employeeshiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutTerminationInput = {
    create?: XOR<employeeCreateWithoutTerminationInput, employeeUncheckedCreateWithoutTerminationInput>
    connectOrCreate?: employeeCreateOrConnectWithoutTerminationInput
    connect?: employeeWhereUniqueInput
  }

  export type Enumtermination_statusFieldUpdateOperationsInput = {
    set?: $Enums.termination_status
  }

  export type Enumtermination_workflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.termination_workflowStatus
  }

  export type employeeUpdateOneRequiredWithoutTerminationNestedInput = {
    create?: XOR<employeeCreateWithoutTerminationInput, employeeUncheckedCreateWithoutTerminationInput>
    connectOrCreate?: employeeCreateOrConnectWithoutTerminationInput
    upsert?: employeeUpsertWithoutTerminationInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutTerminationInput, employeeUpdateWithoutTerminationInput>, employeeUncheckedUpdateWithoutTerminationInput>
  }

  export type employeeCreateNestedOneWithoutUserInput = {
    create?: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUserInput
    connect?: employeeWhereUniqueInput
  }

  export type leaveCreateNestedManyWithoutUserInput = {
    create?: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput> | leaveCreateWithoutUserInput[] | leaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutUserInput | leaveCreateOrConnectWithoutUserInput[]
    createMany?: leaveCreateManyUserInputEnvelope
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
  }

  export type overtimelogCreateNestedManyWithoutUserInput = {
    create?: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput> | overtimelogCreateWithoutUserInput[] | overtimelogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutUserInput | overtimelogCreateOrConnectWithoutUserInput[]
    createMany?: overtimelogCreateManyUserInputEnvelope
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
  }

  export type userroleCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type employeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUserInput
    connect?: employeeWhereUniqueInput
  }

  export type leaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput> | leaveCreateWithoutUserInput[] | leaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutUserInput | leaveCreateOrConnectWithoutUserInput[]
    createMany?: leaveCreateManyUserInputEnvelope
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
  }

  export type overtimelogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput> | overtimelogCreateWithoutUserInput[] | overtimelogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutUserInput | overtimelogCreateOrConnectWithoutUserInput[]
    createMany?: overtimelogCreateManyUserInputEnvelope
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
  }

  export type userroleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
  }

  export type employeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUserInput
    upsert?: employeeUpsertWithoutUserInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutUserInput, employeeUpdateWithoutUserInput>, employeeUncheckedUpdateWithoutUserInput>
  }

  export type leaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput> | leaveCreateWithoutUserInput[] | leaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutUserInput | leaveCreateOrConnectWithoutUserInput[]
    upsert?: leaveUpsertWithWhereUniqueWithoutUserInput | leaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: leaveCreateManyUserInputEnvelope
    set?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    disconnect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    delete?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    update?: leaveUpdateWithWhereUniqueWithoutUserInput | leaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: leaveUpdateManyWithWhereWithoutUserInput | leaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: leaveScalarWhereInput | leaveScalarWhereInput[]
  }

  export type overtimelogUpdateManyWithoutUserNestedInput = {
    create?: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput> | overtimelogCreateWithoutUserInput[] | overtimelogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutUserInput | overtimelogCreateOrConnectWithoutUserInput[]
    upsert?: overtimelogUpsertWithWhereUniqueWithoutUserInput | overtimelogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: overtimelogCreateManyUserInputEnvelope
    set?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    disconnect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    delete?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    update?: overtimelogUpdateWithWhereUniqueWithoutUserInput | overtimelogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: overtimelogUpdateManyWithWhereWithoutUserInput | overtimelogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
  }

  export type userroleUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type employeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: employeeCreateOrConnectWithoutUserInput
    upsert?: employeeUpsertWithoutUserInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutUserInput, employeeUpdateWithoutUserInput>, employeeUncheckedUpdateWithoutUserInput>
  }

  export type leaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput> | leaveCreateWithoutUserInput[] | leaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: leaveCreateOrConnectWithoutUserInput | leaveCreateOrConnectWithoutUserInput[]
    upsert?: leaveUpsertWithWhereUniqueWithoutUserInput | leaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: leaveCreateManyUserInputEnvelope
    set?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    disconnect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    delete?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    connect?: leaveWhereUniqueInput | leaveWhereUniqueInput[]
    update?: leaveUpdateWithWhereUniqueWithoutUserInput | leaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: leaveUpdateManyWithWhereWithoutUserInput | leaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: leaveScalarWhereInput | leaveScalarWhereInput[]
  }

  export type overtimelogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput> | overtimelogCreateWithoutUserInput[] | overtimelogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: overtimelogCreateOrConnectWithoutUserInput | overtimelogCreateOrConnectWithoutUserInput[]
    upsert?: overtimelogUpsertWithWhereUniqueWithoutUserInput | overtimelogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: overtimelogCreateManyUserInputEnvelope
    set?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    disconnect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    delete?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    connect?: overtimelogWhereUniqueInput | overtimelogWhereUniqueInput[]
    update?: overtimelogUpdateWithWhereUniqueWithoutUserInput | overtimelogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: overtimelogUpdateManyWithWhereWithoutUserInput | overtimelogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
  }

  export type userroleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput> | userroleCreateWithoutUserInput[] | userroleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: userroleCreateOrConnectWithoutUserInput | userroleCreateOrConnectWithoutUserInput[]
    upsert?: userroleUpsertWithWhereUniqueWithoutUserInput | userroleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: userroleCreateManyUserInputEnvelope
    set?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    disconnect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    delete?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    connect?: userroleWhereUniqueInput | userroleWhereUniqueInput[]
    update?: userroleUpdateWithWhereUniqueWithoutUserInput | userroleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: userroleUpdateManyWithWhereWithoutUserInput | userroleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: userroleScalarWhereInput | userroleScalarWhereInput[]
  }

  export type roleCreateNestedOneWithoutUserroleInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    connect?: roleWhereUniqueInput
  }

  export type userCreateNestedOneWithoutUserroleInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    connect?: userWhereUniqueInput
  }

  export type roleUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: roleCreateOrConnectWithoutUserroleInput
    upsert?: roleUpsertWithoutUserroleInput
    connect?: roleWhereUniqueInput
    update?: XOR<XOR<roleUpdateToOneWithWhereWithoutUserroleInput, roleUpdateWithoutUserroleInput>, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type userUpdateOneRequiredWithoutUserroleNestedInput = {
    create?: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    connectOrCreate?: userCreateOrConnectWithoutUserroleInput
    upsert?: userUpsertWithoutUserroleInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutUserroleInput, userUpdateWithoutUserroleInput>, userUncheckedUpdateWithoutUserroleInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumactivitylog_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.activitylog_type | Enumactivitylog_typeFieldRefInput<$PrismaModel>
    in?: $Enums.activitylog_type[]
    notIn?: $Enums.activitylog_type[]
    not?: NestedEnumactivitylog_typeFilter<$PrismaModel> | $Enums.activitylog_type
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumactivitylog_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.activitylog_type | Enumactivitylog_typeFieldRefInput<$PrismaModel>
    in?: $Enums.activitylog_type[]
    notIn?: $Enums.activitylog_type[]
    not?: NestedEnumactivitylog_typeWithAggregatesFilter<$PrismaModel> | $Enums.activitylog_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumactivitylog_typeFilter<$PrismaModel>
    _max?: NestedEnumactivitylog_typeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumattendancelog_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancelog_status | Enumattendancelog_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancelog_status[]
    notIn?: $Enums.attendancelog_status[]
    not?: NestedEnumattendancelog_statusFilter<$PrismaModel> | $Enums.attendancelog_status
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumattendancelog_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancelog_status | Enumattendancelog_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancelog_status[]
    notIn?: $Enums.attendancelog_status[]
    not?: NestedEnumattendancelog_statusWithAggregatesFilter<$PrismaModel> | $Enums.attendancelog_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattendancelog_statusFilter<$PrismaModel>
    _max?: NestedEnumattendancelog_statusFilter<$PrismaModel>
  }

  export type NestedEnumattendancesummary_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancesummary_status | Enumattendancesummary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancesummary_status[]
    notIn?: $Enums.attendancesummary_status[]
    not?: NestedEnumattendancesummary_statusFilter<$PrismaModel> | $Enums.attendancesummary_status
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumattendancesummary_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.attendancesummary_status | Enumattendancesummary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.attendancesummary_status[]
    notIn?: $Enums.attendancesummary_status[]
    not?: NestedEnumattendancesummary_statusWithAggregatesFilter<$PrismaModel> | $Enums.attendancesummary_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumattendancesummary_statusFilter<$PrismaModel>
    _max?: NestedEnumattendancesummary_statusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumcomplaint_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.complaint_status | Enumcomplaint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.complaint_status[]
    notIn?: $Enums.complaint_status[]
    not?: NestedEnumcomplaint_statusFilter<$PrismaModel> | $Enums.complaint_status
  }

  export type NestedEnumcomplaint_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.complaint_status | Enumcomplaint_statusFieldRefInput<$PrismaModel>
    in?: $Enums.complaint_status[]
    notIn?: $Enums.complaint_status[]
    not?: NestedEnumcomplaint_statusWithAggregatesFilter<$PrismaModel> | $Enums.complaint_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomplaint_statusFilter<$PrismaModel>
    _max?: NestedEnumcomplaint_statusFilter<$PrismaModel>
  }

  export type NestedEnumemployee_sexFilter<$PrismaModel = never> = {
    equals?: $Enums.employee_sex | Enumemployee_sexFieldRefInput<$PrismaModel>
    in?: $Enums.employee_sex[]
    notIn?: $Enums.employee_sex[]
    not?: NestedEnumemployee_sexFilter<$PrismaModel> | $Enums.employee_sex
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumemployee_sexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.employee_sex | Enumemployee_sexFieldRefInput<$PrismaModel>
    in?: $Enums.employee_sex[]
    notIn?: $Enums.employee_sex[]
    not?: NestedEnumemployee_sexWithAggregatesFilter<$PrismaModel> | $Enums.employee_sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumemployee_sexFilter<$PrismaModel>
    _max?: NestedEnumemployee_sexFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnuminterview_resultFilter<$PrismaModel = never> = {
    equals?: $Enums.interview_result | Enuminterview_resultFieldRefInput<$PrismaModel>
    in?: $Enums.interview_result[]
    notIn?: $Enums.interview_result[]
    not?: NestedEnuminterview_resultFilter<$PrismaModel> | $Enums.interview_result
  }

  export type NestedEnuminterview_resultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.interview_result | Enuminterview_resultFieldRefInput<$PrismaModel>
    in?: $Enums.interview_result[]
    notIn?: $Enums.interview_result[]
    not?: NestedEnuminterview_resultWithAggregatesFilter<$PrismaModel> | $Enums.interview_result
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminterview_resultFilter<$PrismaModel>
    _max?: NestedEnuminterview_resultFilter<$PrismaModel>
  }

  export type NestedEnumleave_leaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_leaveType | Enumleave_leaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.leave_leaveType[]
    notIn?: $Enums.leave_leaveType[]
    not?: NestedEnumleave_leaveTypeFilter<$PrismaModel> | $Enums.leave_leaveType
  }

  export type NestedEnumleave_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_status | Enumleave_statusFieldRefInput<$PrismaModel>
    in?: $Enums.leave_status[]
    notIn?: $Enums.leave_status[]
    not?: NestedEnumleave_statusFilter<$PrismaModel> | $Enums.leave_status
  }

  export type NestedEnumleave_leaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_leaveType | Enumleave_leaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.leave_leaveType[]
    notIn?: $Enums.leave_leaveType[]
    not?: NestedEnumleave_leaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.leave_leaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumleave_leaveTypeFilter<$PrismaModel>
    _max?: NestedEnumleave_leaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumleave_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.leave_status | Enumleave_statusFieldRefInput<$PrismaModel>
    in?: $Enums.leave_status[]
    notIn?: $Enums.leave_status[]
    not?: NestedEnumleave_statusWithAggregatesFilter<$PrismaModel> | $Enums.leave_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumleave_statusFilter<$PrismaModel>
    _max?: NestedEnumleave_statusFilter<$PrismaModel>
  }

  export type NestedEnumovertimelog_approvalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_approvalStatus | Enumovertimelog_approvalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_approvalStatus[]
    notIn?: $Enums.overtimelog_approvalStatus[]
    not?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel> | $Enums.overtimelog_approvalStatus
  }

  export type NestedEnumovertimelog_compensationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_compensationMethod | Enumovertimelog_compensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_compensationMethod[]
    notIn?: $Enums.overtimelog_compensationMethod[]
    not?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel> | $Enums.overtimelog_compensationMethod
  }

  export type NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_overtimeType | Enumovertimelog_overtimeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_overtimeType[]
    notIn?: $Enums.overtimelog_overtimeType[]
    not?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel> | $Enums.overtimelog_overtimeType
  }

  export type NestedEnumovertimelog_approvalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_approvalStatus | Enumovertimelog_approvalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_approvalStatus[]
    notIn?: $Enums.overtimelog_approvalStatus[]
    not?: NestedEnumovertimelog_approvalStatusWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_approvalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_approvalStatusFilter<$PrismaModel>
  }

  export type NestedEnumovertimelog_compensationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_compensationMethod | Enumovertimelog_compensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_compensationMethod[]
    notIn?: $Enums.overtimelog_compensationMethod[]
    not?: NestedEnumovertimelog_compensationMethodWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_compensationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_compensationMethodFilter<$PrismaModel>
  }

  export type NestedEnumovertimelog_overtimeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.overtimelog_overtimeType | Enumovertimelog_overtimeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.overtimelog_overtimeType[]
    notIn?: $Enums.overtimelog_overtimeType[]
    not?: NestedEnumovertimelog_overtimeTypeWithAggregatesFilter<$PrismaModel> | $Enums.overtimelog_overtimeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel>
    _max?: NestedEnumovertimelog_overtimeTypeFilter<$PrismaModel>
  }

  export type NestedEnumsalary_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.salary_status | Enumsalary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.salary_status[]
    notIn?: $Enums.salary_status[]
    not?: NestedEnumsalary_statusFilter<$PrismaModel> | $Enums.salary_status
  }

  export type NestedEnumsalary_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.salary_status | Enumsalary_statusFieldRefInput<$PrismaModel>
    in?: $Enums.salary_status[]
    notIn?: $Enums.salary_status[]
    not?: NestedEnumsalary_statusWithAggregatesFilter<$PrismaModel> | $Enums.salary_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumsalary_statusFilter<$PrismaModel>
    _max?: NestedEnumsalary_statusFilter<$PrismaModel>
  }

  export type NestedEnumtermination_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_status | Enumtermination_statusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_status[]
    notIn?: $Enums.termination_status[]
    not?: NestedEnumtermination_statusFilter<$PrismaModel> | $Enums.termination_status
  }

  export type NestedEnumtermination_workflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_workflowStatus | Enumtermination_workflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_workflowStatus[]
    notIn?: $Enums.termination_workflowStatus[]
    not?: NestedEnumtermination_workflowStatusFilter<$PrismaModel> | $Enums.termination_workflowStatus
  }

  export type NestedEnumtermination_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_status | Enumtermination_statusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_status[]
    notIn?: $Enums.termination_status[]
    not?: NestedEnumtermination_statusWithAggregatesFilter<$PrismaModel> | $Enums.termination_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtermination_statusFilter<$PrismaModel>
    _max?: NestedEnumtermination_statusFilter<$PrismaModel>
  }

  export type NestedEnumtermination_workflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.termination_workflowStatus | Enumtermination_workflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.termination_workflowStatus[]
    notIn?: $Enums.termination_workflowStatus[]
    not?: NestedEnumtermination_workflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.termination_workflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtermination_workflowStatusFilter<$PrismaModel>
    _max?: NestedEnumtermination_workflowStatusFilter<$PrismaModel>
  }

  export type employeeCreateWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_actorIdToemployeeInput>
  }

  export type employeeCreateWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_targetIdToemployeeInput>
  }

  export type employeeUpsertWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    update: XOR<employeeUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput>
    create: XOR<employeeCreateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_actorIdToemployeeInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput, employeeUncheckedUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput>
  }

  export type employeeUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutActivitylog_activitylog_actorIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUpsertWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    update: XOR<employeeUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput>
    create: XOR<employeeCreateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedCreateWithoutActivitylog_activitylog_targetIdToemployeeInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput, employeeUncheckedUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput>
  }

  export type employeeUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutActivitylog_activitylog_targetIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateWithoutAgreementstatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutAgreementstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutAgreementstatusInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput>
  }

  export type employeeCreateManyAgreementstatusInputEnvelope = {
    data: employeeCreateManyAgreementstatusInput | employeeCreateManyAgreementstatusInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutAgreementstatusInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutAgreementstatusInput, employeeUncheckedUpdateWithoutAgreementstatusInput>
    create: XOR<employeeCreateWithoutAgreementstatusInput, employeeUncheckedCreateWithoutAgreementstatusInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutAgreementstatusInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutAgreementstatusInput, employeeUncheckedUpdateWithoutAgreementstatusInput>
  }

  export type employeeUpdateManyWithWhereWithoutAgreementstatusInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutAgreementstatusInput>
  }

  export type employeeScalarWhereInput = {
    AND?: employeeScalarWhereInput | employeeScalarWhereInput[]
    OR?: employeeScalarWhereInput[]
    NOT?: employeeScalarWhereInput | employeeScalarWhereInput[]
    id?: IntFilter<"employee"> | number
    userId?: IntNullableFilter<"employee"> | number | null
    firstName?: StringFilter<"employee"> | string
    lastName?: StringFilter<"employee"> | string
    baptismalName?: StringNullableFilter<"employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"employee"> | Date | string | null
    sex?: Enumemployee_sexFilter<"employee"> | $Enums.employee_sex
    nationality?: StringNullableFilter<"employee"> | string | null
    maritalStatusId?: IntNullableFilter<"employee"> | number | null
    departmentId?: IntNullableFilter<"employee"> | number | null
    positionId?: IntNullableFilter<"employee"> | number | null
    employmentTypeId?: IntNullableFilter<"employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"employee"> | number | null
    phone?: StringNullableFilter<"employee"> | string | null
    address?: StringNullableFilter<"employee"> | string | null
    subCity?: StringNullableFilter<"employee"> | string | null
    emergencyContactName?: StringNullableFilter<"employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"employee"> | string | null
    academicQualification?: StringNullableFilter<"employee"> | string | null
    educationalInstitution?: StringNullableFilter<"employee"> | string | null
    salary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"employee"> | string | null
    agreementStatusId?: IntNullableFilter<"employee"> | number | null
    photo?: StringNullableFilter<"employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"employee"> | Date | string | null
    createdAt?: DateTimeFilter<"employee"> | Date | string
    updatedAt?: DateTimeFilter<"employee"> | Date | string
    subDepartmentId?: IntNullableFilter<"employee"> | number | null
  }

  export type employeeCreateWithoutAttendancelogInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutAttendancelogInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutAttendancelogInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutAttendancelogInput, employeeUncheckedCreateWithoutAttendancelogInput>
  }

  export type sessiondefinitionCreateWithoutAttendancelogInput = {
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type sessiondefinitionUncheckedCreateWithoutAttendancelogInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type sessiondefinitionCreateOrConnectWithoutAttendancelogInput = {
    where: sessiondefinitionWhereUniqueInput
    create: XOR<sessiondefinitionCreateWithoutAttendancelogInput, sessiondefinitionUncheckedCreateWithoutAttendancelogInput>
  }

  export type employeeUpsertWithoutAttendancelogInput = {
    update: XOR<employeeUpdateWithoutAttendancelogInput, employeeUncheckedUpdateWithoutAttendancelogInput>
    create: XOR<employeeCreateWithoutAttendancelogInput, employeeUncheckedCreateWithoutAttendancelogInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutAttendancelogInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutAttendancelogInput, employeeUncheckedUpdateWithoutAttendancelogInput>
  }

  export type employeeUpdateWithoutAttendancelogInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutAttendancelogInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type sessiondefinitionUpsertWithoutAttendancelogInput = {
    update: XOR<sessiondefinitionUpdateWithoutAttendancelogInput, sessiondefinitionUncheckedUpdateWithoutAttendancelogInput>
    create: XOR<sessiondefinitionCreateWithoutAttendancelogInput, sessiondefinitionUncheckedCreateWithoutAttendancelogInput>
    where?: sessiondefinitionWhereInput
  }

  export type sessiondefinitionUpdateToOneWithWhereWithoutAttendancelogInput = {
    where?: sessiondefinitionWhereInput
    data: XOR<sessiondefinitionUpdateWithoutAttendancelogInput, sessiondefinitionUncheckedUpdateWithoutAttendancelogInput>
  }

  export type sessiondefinitionUpdateWithoutAttendancelogInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessiondefinitionUncheckedUpdateWithoutAttendancelogInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentCreateWithoutAttendancesummaryInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutAttendancesummaryInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutAttendancesummaryInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutAttendancesummaryInput, departmentUncheckedCreateWithoutAttendancesummaryInput>
  }

  export type employeeCreateWithoutAttendancesummaryInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutAttendancesummaryInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutAttendancesummaryInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutAttendancesummaryInput, employeeUncheckedCreateWithoutAttendancesummaryInput>
  }

  export type departmentUpsertWithoutAttendancesummaryInput = {
    update: XOR<departmentUpdateWithoutAttendancesummaryInput, departmentUncheckedUpdateWithoutAttendancesummaryInput>
    create: XOR<departmentCreateWithoutAttendancesummaryInput, departmentUncheckedCreateWithoutAttendancesummaryInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutAttendancesummaryInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutAttendancesummaryInput, departmentUncheckedUpdateWithoutAttendancesummaryInput>
  }

  export type departmentUpdateWithoutAttendancesummaryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutAttendancesummaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type employeeUpsertWithoutAttendancesummaryInput = {
    update: XOR<employeeUpdateWithoutAttendancesummaryInput, employeeUncheckedUpdateWithoutAttendancesummaryInput>
    create: XOR<employeeCreateWithoutAttendancesummaryInput, employeeUncheckedCreateWithoutAttendancesummaryInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutAttendancesummaryInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutAttendancesummaryInput, employeeUncheckedUpdateWithoutAttendancesummaryInput>
  }

  export type employeeUpdateWithoutAttendancesummaryInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutAttendancesummaryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateWithoutComplaintInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutComplaintInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutComplaintInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutComplaintInput, employeeUncheckedCreateWithoutComplaintInput>
  }

  export type employeeUpsertWithoutComplaintInput = {
    update: XOR<employeeUpdateWithoutComplaintInput, employeeUncheckedUpdateWithoutComplaintInput>
    create: XOR<employeeCreateWithoutComplaintInput, employeeUncheckedCreateWithoutComplaintInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutComplaintInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutComplaintInput, employeeUncheckedUpdateWithoutComplaintInput>
  }

  export type employeeUpdateWithoutComplaintInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutComplaintInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type attendancesummaryCreateWithoutDepartmentInput = {
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    employee: employeeCreateNestedOneWithoutAttendancesummaryInput
  }

  export type attendancesummaryUncheckedCreateWithoutDepartmentInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
  }

  export type attendancesummaryCreateOrConnectWithoutDepartmentInput = {
    where: attendancesummaryWhereUniqueInput
    create: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput>
  }

  export type attendancesummaryCreateManyDepartmentInputEnvelope = {
    data: attendancesummaryCreateManyDepartmentInput | attendancesummaryCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type departmentCreateWithoutOther_departmentInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutOther_departmentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutOther_departmentInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutOther_departmentInput, departmentUncheckedCreateWithoutOther_departmentInput>
  }

  export type departmentCreateWithoutDepartmentInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    payrollPolicyId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutDepartmentInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput>
  }

  export type departmentCreateManyDepartmentInputEnvelope = {
    data: departmentCreateManyDepartmentInput | departmentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type payrollpolicyCreateWithoutDepartmentInput = {
    name: string
    isDefault?: boolean
    otMultiplierWeekday1?: Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    otMultiplierSleepover?: Decimal | DecimalJsLike | number | string
  }

  export type payrollpolicyUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    isDefault?: boolean
    otMultiplierWeekday1?: Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt: Date | string
    otMultiplierSleepover?: Decimal | DecimalJsLike | number | string
  }

  export type payrollpolicyCreateOrConnectWithoutDepartmentInput = {
    where: payrollpolicyWhereUniqueInput
    create: XOR<payrollpolicyCreateWithoutDepartmentInput, payrollpolicyUncheckedCreateWithoutDepartmentInput>
  }

  export type employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutDepartment_employee_departmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput>
  }

  export type employeeCreateManyDepartment_employee_departmentIdTodepartmentInputEnvelope = {
    data: employeeCreateManyDepartment_employee_departmentIdTodepartmentInput | employeeCreateManyDepartment_employee_departmentIdTodepartmentInput[]
    skipDuplicates?: boolean
  }

  export type employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput>
  }

  export type employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInputEnvelope = {
    data: employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInput | employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInput[]
    skipDuplicates?: boolean
  }

  export type attendancesummaryUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: attendancesummaryWhereUniqueInput
    update: XOR<attendancesummaryUpdateWithoutDepartmentInput, attendancesummaryUncheckedUpdateWithoutDepartmentInput>
    create: XOR<attendancesummaryCreateWithoutDepartmentInput, attendancesummaryUncheckedCreateWithoutDepartmentInput>
  }

  export type attendancesummaryUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: attendancesummaryWhereUniqueInput
    data: XOR<attendancesummaryUpdateWithoutDepartmentInput, attendancesummaryUncheckedUpdateWithoutDepartmentInput>
  }

  export type attendancesummaryUpdateManyWithWhereWithoutDepartmentInput = {
    where: attendancesummaryScalarWhereInput
    data: XOR<attendancesummaryUpdateManyMutationInput, attendancesummaryUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type attendancesummaryScalarWhereInput = {
    AND?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
    OR?: attendancesummaryScalarWhereInput[]
    NOT?: attendancesummaryScalarWhereInput | attendancesummaryScalarWhereInput[]
    id?: IntFilter<"attendancesummary"> | number
    employeeId?: IntFilter<"attendancesummary"> | number
    date?: DateTimeFilter<"attendancesummary"> | Date | string
    status?: Enumattendancesummary_statusFilter<"attendancesummary"> | $Enums.attendancesummary_status
    lateArrival?: BoolFilter<"attendancesummary"> | boolean
    earlyDeparture?: BoolFilter<"attendancesummary"> | boolean
    unplannedAbsence?: BoolFilter<"attendancesummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"attendancesummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"attendancesummary"> | string | null
    departmentId?: IntNullableFilter<"attendancesummary"> | number | null
  }

  export type departmentUpsertWithoutOther_departmentInput = {
    update: XOR<departmentUpdateWithoutOther_departmentInput, departmentUncheckedUpdateWithoutOther_departmentInput>
    create: XOR<departmentCreateWithoutOther_departmentInput, departmentUncheckedCreateWithoutOther_departmentInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutOther_departmentInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutOther_departmentInput, departmentUncheckedUpdateWithoutOther_departmentInput>
  }

  export type departmentUpdateWithoutOther_departmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutOther_departmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: departmentWhereUniqueInput
    update: XOR<departmentUpdateWithoutDepartmentInput, departmentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<departmentCreateWithoutDepartmentInput, departmentUncheckedCreateWithoutDepartmentInput>
  }

  export type departmentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: departmentWhereUniqueInput
    data: XOR<departmentUpdateWithoutDepartmentInput, departmentUncheckedUpdateWithoutDepartmentInput>
  }

  export type departmentUpdateManyWithWhereWithoutDepartmentInput = {
    where: departmentScalarWhereInput
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type departmentScalarWhereInput = {
    AND?: departmentScalarWhereInput | departmentScalarWhereInput[]
    OR?: departmentScalarWhereInput[]
    NOT?: departmentScalarWhereInput | departmentScalarWhereInput[]
    id?: IntFilter<"department"> | number
    name?: StringFilter<"department"> | string
    description?: StringNullableFilter<"department"> | string | null
    createdAt?: DateTimeFilter<"department"> | Date | string
    updatedAt?: DateTimeFilter<"department"> | Date | string
    parentId?: IntNullableFilter<"department"> | number | null
    payrollPolicyId?: IntNullableFilter<"department"> | number | null
  }

  export type payrollpolicyUpsertWithoutDepartmentInput = {
    update: XOR<payrollpolicyUpdateWithoutDepartmentInput, payrollpolicyUncheckedUpdateWithoutDepartmentInput>
    create: XOR<payrollpolicyCreateWithoutDepartmentInput, payrollpolicyUncheckedCreateWithoutDepartmentInput>
    where?: payrollpolicyWhereInput
  }

  export type payrollpolicyUpdateToOneWithWhereWithoutDepartmentInput = {
    where?: payrollpolicyWhereInput
    data: XOR<payrollpolicyUpdateWithoutDepartmentInput, payrollpolicyUncheckedUpdateWithoutDepartmentInput>
  }

  export type payrollpolicyUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type payrollpolicyUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    otMultiplierWeekday1?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierWeekday2?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierSunday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otMultiplierHoliday?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    otMultiplierSleepover?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type employeeUpsertWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedUpdateWithoutDepartment_employee_departmentIdTodepartmentInput>
    create: XOR<employeeCreateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_departmentIdTodepartmentInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutDepartment_employee_departmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutDepartment_employee_departmentIdTodepartmentInput, employeeUncheckedUpdateWithoutDepartment_employee_departmentIdTodepartmentInput>
  }

  export type employeeUpdateManyWithWhereWithoutDepartment_employee_departmentIdTodepartmentInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentInput>
  }

  export type employeeUpsertWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput>
    create: XOR<employeeCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedCreateWithoutDepartment_employee_subDepartmentIdTodepartmentInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput, employeeUncheckedUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput>
  }

  export type employeeUpdateManyWithWhereWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput>
  }

  export type activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput = {
    type: $Enums.activitylog_type
    message: string
    departmentId: number
    createdAt?: Date | string
    employee_activitylog_targetIdToemployee?: employeeCreateNestedOneWithoutActivitylog_activitylog_targetIdToemployeeInput
  }

  export type activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    targetId?: number | null
    departmentId: number
    createdAt?: Date | string
  }

  export type activitylogCreateOrConnectWithoutEmployee_activitylog_actorIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    create: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput>
  }

  export type activitylogCreateManyEmployee_activitylog_actorIdToemployeeInputEnvelope = {
    data: activitylogCreateManyEmployee_activitylog_actorIdToemployeeInput | activitylogCreateManyEmployee_activitylog_actorIdToemployeeInput[]
    skipDuplicates?: boolean
  }

  export type activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput = {
    type: $Enums.activitylog_type
    message: string
    departmentId: number
    createdAt?: Date | string
    employee_activitylog_actorIdToemployee: employeeCreateNestedOneWithoutActivitylog_activitylog_actorIdToemployeeInput
  }

  export type activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    actorId: number
    departmentId: number
    createdAt?: Date | string
  }

  export type activitylogCreateOrConnectWithoutEmployee_activitylog_targetIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    create: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput>
  }

  export type activitylogCreateManyEmployee_activitylog_targetIdToemployeeInputEnvelope = {
    data: activitylogCreateManyEmployee_activitylog_targetIdToemployeeInput | activitylogCreateManyEmployee_activitylog_targetIdToemployeeInput[]
    skipDuplicates?: boolean
  }

  export type attendancelogCreateWithoutEmployeeInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
    sessiondefinition: sessiondefinitionCreateNestedOneWithoutAttendancelogInput
  }

  export type attendancelogUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancelogCreateOrConnectWithoutEmployeeInput = {
    where: attendancelogWhereUniqueInput
    create: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput>
  }

  export type attendancelogCreateManyEmployeeInputEnvelope = {
    data: attendancelogCreateManyEmployeeInput | attendancelogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type attendancesummaryCreateWithoutEmployeeInput = {
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    department?: departmentCreateNestedOneWithoutAttendancesummaryInput
  }

  export type attendancesummaryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type attendancesummaryCreateOrConnectWithoutEmployeeInput = {
    where: attendancesummaryWhereUniqueInput
    create: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type attendancesummaryCreateManyEmployeeInputEnvelope = {
    data: attendancesummaryCreateManyEmployeeInput | attendancesummaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type complaintCreateWithoutEmployeeInput = {
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type complaintUncheckedCreateWithoutEmployeeInput = {
    id?: number
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type complaintCreateOrConnectWithoutEmployeeInput = {
    where: complaintWhereUniqueInput
    create: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput>
  }

  export type complaintCreateManyEmployeeInputEnvelope = {
    data: complaintCreateManyEmployeeInput | complaintCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type agreementstatusCreateWithoutEmployeeInput = {
    status: string
  }

  export type agreementstatusUncheckedCreateWithoutEmployeeInput = {
    id?: number
    status: string
  }

  export type agreementstatusCreateOrConnectWithoutEmployeeInput = {
    where: agreementstatusWhereUniqueInput
    create: XOR<agreementstatusCreateWithoutEmployeeInput, agreementstatusUncheckedCreateWithoutEmployeeInput>
  }

  export type departmentCreateWithoutEmployee_employee_departmentIdTodepartmentInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutEmployee_employee_departmentIdTodepartmentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutEmployee_employee_departmentIdTodepartmentInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_departmentIdTodepartmentInput>
  }

  export type employmenttypeCreateWithoutEmployeeInput = {
    type: string
  }

  export type employmenttypeUncheckedCreateWithoutEmployeeInput = {
    id?: number
    type: string
  }

  export type employmenttypeCreateOrConnectWithoutEmployeeInput = {
    where: employmenttypeWhereUniqueInput
    create: XOR<employmenttypeCreateWithoutEmployeeInput, employmenttypeUncheckedCreateWithoutEmployeeInput>
  }

  export type jobstatusCreateWithoutEmployeeInput = {
    status: string
  }

  export type jobstatusUncheckedCreateWithoutEmployeeInput = {
    id?: number
    status: string
  }

  export type jobstatusCreateOrConnectWithoutEmployeeInput = {
    where: jobstatusWhereUniqueInput
    create: XOR<jobstatusCreateWithoutEmployeeInput, jobstatusUncheckedCreateWithoutEmployeeInput>
  }

  export type maritalstatusCreateWithoutEmployeeInput = {
    status: string
  }

  export type maritalstatusUncheckedCreateWithoutEmployeeInput = {
    id?: number
    status: string
  }

  export type maritalstatusCreateOrConnectWithoutEmployeeInput = {
    where: maritalstatusWhereUniqueInput
    create: XOR<maritalstatusCreateWithoutEmployeeInput, maritalstatusUncheckedCreateWithoutEmployeeInput>
  }

  export type positionCreateWithoutEmployeeInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type positionUncheckedCreateWithoutEmployeeInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type positionCreateOrConnectWithoutEmployeeInput = {
    where: positionWhereUniqueInput
    create: XOR<positionCreateWithoutEmployeeInput, positionUncheckedCreateWithoutEmployeeInput>
  }

  export type departmentCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    payrollpolicy?: payrollpolicyCreateNestedOneWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    payrollPolicyId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
  }

  export type userCreateWithoutEmployeeInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    leave?: leaveCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEmployeeInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    leave?: leaveUncheckedCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEmployeeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEmployeeInput, userUncheckedCreateWithoutEmployeeInput>
  }

  export type employeeshiftCreateWithoutEmployeeInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    shift: shiftCreateNestedOneWithoutEmployeeshiftInput
  }

  export type employeeshiftUncheckedCreateWithoutEmployeeInput = {
    id?: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type employeeshiftCreateOrConnectWithoutEmployeeInput = {
    where: employeeshiftWhereUniqueInput
    create: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput>
  }

  export type employeeshiftCreateManyEmployeeInputEnvelope = {
    data: employeeshiftCreateManyEmployeeInput | employeeshiftCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type leaveCreateWithoutEmployeeInput = {
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    requestedAt?: Date | string
    updatedAt: Date | string
    user?: userCreateNestedOneWithoutLeaveInput
  }

  export type leaveUncheckedCreateWithoutEmployeeInput = {
    id?: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type leaveCreateOrConnectWithoutEmployeeInput = {
    where: leaveWhereUniqueInput
    create: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput>
  }

  export type leaveCreateManyEmployeeInputEnvelope = {
    data: leaveCreateManyEmployeeInput | leaveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type meetingCreateWithoutEmployeeInput = {
    title: string
    description?: string | null
    date: Date | string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type meetingUncheckedCreateWithoutEmployeeInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type meetingCreateOrConnectWithoutEmployeeInput = {
    where: meetingWhereUniqueInput
    create: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput>
  }

  export type meetingCreateManyEmployeeInputEnvelope = {
    data: meetingCreateManyEmployeeInput | meetingCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type overtimelogCreateWithoutEmployeeInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: userCreateNestedOneWithoutOvertimelogInput
  }

  export type overtimelogUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type overtimelogCreateOrConnectWithoutEmployeeInput = {
    where: overtimelogWhereUniqueInput
    create: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput>
  }

  export type overtimelogCreateManyEmployeeInputEnvelope = {
    data: overtimelogCreateManyEmployeeInput | overtimelogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type performancereviewCreateWithoutEmployeeInput = {
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type performancereviewUncheckedCreateWithoutEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type performancereviewCreateOrConnectWithoutEmployeeInput = {
    where: performancereviewWhereUniqueInput
    create: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput>
  }

  export type performancereviewCreateManyEmployeeInputEnvelope = {
    data: performancereviewCreateManyEmployeeInput | performancereviewCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type salaryCreateWithoutEmployeeInput = {
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
  }

  export type salaryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
  }

  export type salaryCreateOrConnectWithoutEmployeeInput = {
    where: salaryWhereUniqueInput
    create: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput>
  }

  export type salaryCreateManyEmployeeInputEnvelope = {
    data: salaryCreateManyEmployeeInput | salaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type terminationCreateWithoutEmployeeInput = {
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
  }

  export type terminationUncheckedCreateWithoutEmployeeInput = {
    id?: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
  }

  export type terminationCreateOrConnectWithoutEmployeeInput = {
    where: terminationWhereUniqueInput
    create: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput>
  }

  export type terminationCreateManyEmployeeInputEnvelope = {
    data: terminationCreateManyEmployeeInput | terminationCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    update: XOR<activitylogUpdateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedUpdateWithoutEmployee_activitylog_actorIdToemployeeInput>
    create: XOR<activitylogCreateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_actorIdToemployeeInput>
  }

  export type activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_actorIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    data: XOR<activitylogUpdateWithoutEmployee_activitylog_actorIdToemployeeInput, activitylogUncheckedUpdateWithoutEmployee_activitylog_actorIdToemployeeInput>
  }

  export type activitylogUpdateManyWithWhereWithoutEmployee_activitylog_actorIdToemployeeInput = {
    where: activitylogScalarWhereInput
    data: XOR<activitylogUpdateManyMutationInput, activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeInput>
  }

  export type activitylogScalarWhereInput = {
    AND?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
    OR?: activitylogScalarWhereInput[]
    NOT?: activitylogScalarWhereInput | activitylogScalarWhereInput[]
    id?: IntFilter<"activitylog"> | number
    type?: Enumactivitylog_typeFilter<"activitylog"> | $Enums.activitylog_type
    message?: StringFilter<"activitylog"> | string
    actorId?: IntFilter<"activitylog"> | number
    targetId?: IntNullableFilter<"activitylog"> | number | null
    departmentId?: IntFilter<"activitylog"> | number
    createdAt?: DateTimeFilter<"activitylog"> | Date | string
  }

  export type activitylogUpsertWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    update: XOR<activitylogUpdateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedUpdateWithoutEmployee_activitylog_targetIdToemployeeInput>
    create: XOR<activitylogCreateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedCreateWithoutEmployee_activitylog_targetIdToemployeeInput>
  }

  export type activitylogUpdateWithWhereUniqueWithoutEmployee_activitylog_targetIdToemployeeInput = {
    where: activitylogWhereUniqueInput
    data: XOR<activitylogUpdateWithoutEmployee_activitylog_targetIdToemployeeInput, activitylogUncheckedUpdateWithoutEmployee_activitylog_targetIdToemployeeInput>
  }

  export type activitylogUpdateManyWithWhereWithoutEmployee_activitylog_targetIdToemployeeInput = {
    where: activitylogScalarWhereInput
    data: XOR<activitylogUpdateManyMutationInput, activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeInput>
  }

  export type attendancelogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: attendancelogWhereUniqueInput
    update: XOR<attendancelogUpdateWithoutEmployeeInput, attendancelogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<attendancelogCreateWithoutEmployeeInput, attendancelogUncheckedCreateWithoutEmployeeInput>
  }

  export type attendancelogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: attendancelogWhereUniqueInput
    data: XOR<attendancelogUpdateWithoutEmployeeInput, attendancelogUncheckedUpdateWithoutEmployeeInput>
  }

  export type attendancelogUpdateManyWithWhereWithoutEmployeeInput = {
    where: attendancelogScalarWhereInput
    data: XOR<attendancelogUpdateManyMutationInput, attendancelogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type attendancelogScalarWhereInput = {
    AND?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
    OR?: attendancelogScalarWhereInput[]
    NOT?: attendancelogScalarWhereInput | attendancelogScalarWhereInput[]
    id?: IntFilter<"attendancelog"> | number
    employeeId?: IntFilter<"attendancelog"> | number
    date?: DateTimeFilter<"attendancelog"> | Date | string
    sessionId?: IntFilter<"attendancelog"> | number
    actualClockIn?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"attendancelog"> | Date | string | null
    status?: Enumattendancelog_statusFilter<"attendancelog"> | $Enums.attendancelog_status
    createdAt?: DateTimeFilter<"attendancelog"> | Date | string
  }

  export type attendancesummaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: attendancesummaryWhereUniqueInput
    update: XOR<attendancesummaryUpdateWithoutEmployeeInput, attendancesummaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<attendancesummaryCreateWithoutEmployeeInput, attendancesummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type attendancesummaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: attendancesummaryWhereUniqueInput
    data: XOR<attendancesummaryUpdateWithoutEmployeeInput, attendancesummaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type attendancesummaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: attendancesummaryScalarWhereInput
    data: XOR<attendancesummaryUpdateManyMutationInput, attendancesummaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type complaintUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: complaintWhereUniqueInput
    update: XOR<complaintUpdateWithoutEmployeeInput, complaintUncheckedUpdateWithoutEmployeeInput>
    create: XOR<complaintCreateWithoutEmployeeInput, complaintUncheckedCreateWithoutEmployeeInput>
  }

  export type complaintUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: complaintWhereUniqueInput
    data: XOR<complaintUpdateWithoutEmployeeInput, complaintUncheckedUpdateWithoutEmployeeInput>
  }

  export type complaintUpdateManyWithWhereWithoutEmployeeInput = {
    where: complaintScalarWhereInput
    data: XOR<complaintUpdateManyMutationInput, complaintUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type complaintScalarWhereInput = {
    AND?: complaintScalarWhereInput | complaintScalarWhereInput[]
    OR?: complaintScalarWhereInput[]
    NOT?: complaintScalarWhereInput | complaintScalarWhereInput[]
    id?: IntFilter<"complaint"> | number
    employeeId?: IntFilter<"complaint"> | number
    subject?: StringFilter<"complaint"> | string
    description?: StringFilter<"complaint"> | string
    status?: Enumcomplaint_statusFilter<"complaint"> | $Enums.complaint_status
    response?: StringNullableFilter<"complaint"> | string | null
    createdAt?: DateTimeFilter<"complaint"> | Date | string
    updatedAt?: DateTimeFilter<"complaint"> | Date | string
  }

  export type agreementstatusUpsertWithoutEmployeeInput = {
    update: XOR<agreementstatusUpdateWithoutEmployeeInput, agreementstatusUncheckedUpdateWithoutEmployeeInput>
    create: XOR<agreementstatusCreateWithoutEmployeeInput, agreementstatusUncheckedCreateWithoutEmployeeInput>
    where?: agreementstatusWhereInput
  }

  export type agreementstatusUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: agreementstatusWhereInput
    data: XOR<agreementstatusUpdateWithoutEmployeeInput, agreementstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type agreementstatusUpdateWithoutEmployeeInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type agreementstatusUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type departmentUpsertWithoutEmployee_employee_departmentIdTodepartmentInput = {
    update: XOR<departmentUpdateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedUpdateWithoutEmployee_employee_departmentIdTodepartmentInput>
    create: XOR<departmentCreateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_departmentIdTodepartmentInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutEmployee_employee_departmentIdTodepartmentInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutEmployee_employee_departmentIdTodepartmentInput, departmentUncheckedUpdateWithoutEmployee_employee_departmentIdTodepartmentInput>
  }

  export type departmentUpdateWithoutEmployee_employee_departmentIdTodepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutEmployee_employee_departmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type employmenttypeUpsertWithoutEmployeeInput = {
    update: XOR<employmenttypeUpdateWithoutEmployeeInput, employmenttypeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<employmenttypeCreateWithoutEmployeeInput, employmenttypeUncheckedCreateWithoutEmployeeInput>
    where?: employmenttypeWhereInput
  }

  export type employmenttypeUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: employmenttypeWhereInput
    data: XOR<employmenttypeUpdateWithoutEmployeeInput, employmenttypeUncheckedUpdateWithoutEmployeeInput>
  }

  export type employmenttypeUpdateWithoutEmployeeInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type employmenttypeUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type jobstatusUpsertWithoutEmployeeInput = {
    update: XOR<jobstatusUpdateWithoutEmployeeInput, jobstatusUncheckedUpdateWithoutEmployeeInput>
    create: XOR<jobstatusCreateWithoutEmployeeInput, jobstatusUncheckedCreateWithoutEmployeeInput>
    where?: jobstatusWhereInput
  }

  export type jobstatusUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: jobstatusWhereInput
    data: XOR<jobstatusUpdateWithoutEmployeeInput, jobstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type jobstatusUpdateWithoutEmployeeInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type jobstatusUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type maritalstatusUpsertWithoutEmployeeInput = {
    update: XOR<maritalstatusUpdateWithoutEmployeeInput, maritalstatusUncheckedUpdateWithoutEmployeeInput>
    create: XOR<maritalstatusCreateWithoutEmployeeInput, maritalstatusUncheckedCreateWithoutEmployeeInput>
    where?: maritalstatusWhereInput
  }

  export type maritalstatusUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: maritalstatusWhereInput
    data: XOR<maritalstatusUpdateWithoutEmployeeInput, maritalstatusUncheckedUpdateWithoutEmployeeInput>
  }

  export type maritalstatusUpdateWithoutEmployeeInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type maritalstatusUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type positionUpsertWithoutEmployeeInput = {
    update: XOR<positionUpdateWithoutEmployeeInput, positionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<positionCreateWithoutEmployeeInput, positionUncheckedCreateWithoutEmployeeInput>
    where?: positionWhereInput
  }

  export type positionUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: positionWhereInput
    data: XOR<positionUpdateWithoutEmployeeInput, positionUncheckedUpdateWithoutEmployeeInput>
  }

  export type positionUpdateWithoutEmployeeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type positionUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type departmentUpsertWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    update: XOR<departmentUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
    create: XOR<departmentCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedCreateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput, departmentUncheckedUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput>
  }

  export type departmentUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutEmployee_employee_subDepartmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
  }

  export type userUpsertWithoutEmployeeInput = {
    update: XOR<userUpdateWithoutEmployeeInput, userUncheckedUpdateWithoutEmployeeInput>
    create: XOR<userCreateWithoutEmployeeInput, userUncheckedCreateWithoutEmployeeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEmployeeInput, userUncheckedUpdateWithoutEmployeeInput>
  }

  export type userUpdateWithoutEmployeeInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    leave?: leaveUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    leave?: leaveUncheckedUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type employeeshiftUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: employeeshiftWhereUniqueInput
    update: XOR<employeeshiftUpdateWithoutEmployeeInput, employeeshiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<employeeshiftCreateWithoutEmployeeInput, employeeshiftUncheckedCreateWithoutEmployeeInput>
  }

  export type employeeshiftUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: employeeshiftWhereUniqueInput
    data: XOR<employeeshiftUpdateWithoutEmployeeInput, employeeshiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type employeeshiftUpdateManyWithWhereWithoutEmployeeInput = {
    where: employeeshiftScalarWhereInput
    data: XOR<employeeshiftUpdateManyMutationInput, employeeshiftUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type employeeshiftScalarWhereInput = {
    AND?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
    OR?: employeeshiftScalarWhereInput[]
    NOT?: employeeshiftScalarWhereInput | employeeshiftScalarWhereInput[]
    id?: IntFilter<"employeeshift"> | number
    employeeId?: IntFilter<"employeeshift"> | number
    shiftId?: IntFilter<"employeeshift"> | number
    effectiveFrom?: DateTimeFilter<"employeeshift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"employeeshift"> | Date | string | null
  }

  export type leaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: leaveWhereUniqueInput
    update: XOR<leaveUpdateWithoutEmployeeInput, leaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<leaveCreateWithoutEmployeeInput, leaveUncheckedCreateWithoutEmployeeInput>
  }

  export type leaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: leaveWhereUniqueInput
    data: XOR<leaveUpdateWithoutEmployeeInput, leaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type leaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: leaveScalarWhereInput
    data: XOR<leaveUpdateManyMutationInput, leaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type leaveScalarWhereInput = {
    AND?: leaveScalarWhereInput | leaveScalarWhereInput[]
    OR?: leaveScalarWhereInput[]
    NOT?: leaveScalarWhereInput | leaveScalarWhereInput[]
    id?: IntFilter<"leave"> | number
    employeeId?: IntFilter<"leave"> | number
    leaveType?: Enumleave_leaveTypeFilter<"leave"> | $Enums.leave_leaveType
    startDate?: DateTimeFilter<"leave"> | Date | string
    endDate?: DateTimeFilter<"leave"> | Date | string
    status?: Enumleave_statusFilter<"leave"> | $Enums.leave_status
    reason?: StringNullableFilter<"leave"> | string | null
    approvedBy?: IntNullableFilter<"leave"> | number | null
    requestedAt?: DateTimeFilter<"leave"> | Date | string
    updatedAt?: DateTimeFilter<"leave"> | Date | string
  }

  export type meetingUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: meetingWhereUniqueInput
    update: XOR<meetingUpdateWithoutEmployeeInput, meetingUncheckedUpdateWithoutEmployeeInput>
    create: XOR<meetingCreateWithoutEmployeeInput, meetingUncheckedCreateWithoutEmployeeInput>
  }

  export type meetingUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: meetingWhereUniqueInput
    data: XOR<meetingUpdateWithoutEmployeeInput, meetingUncheckedUpdateWithoutEmployeeInput>
  }

  export type meetingUpdateManyWithWhereWithoutEmployeeInput = {
    where: meetingScalarWhereInput
    data: XOR<meetingUpdateManyMutationInput, meetingUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type meetingScalarWhereInput = {
    AND?: meetingScalarWhereInput | meetingScalarWhereInput[]
    OR?: meetingScalarWhereInput[]
    NOT?: meetingScalarWhereInput | meetingScalarWhereInput[]
    id?: IntFilter<"meeting"> | number
    title?: StringFilter<"meeting"> | string
    description?: StringNullableFilter<"meeting"> | string | null
    date?: DateTimeFilter<"meeting"> | Date | string
    time?: StringFilter<"meeting"> | string
    creatorId?: IntNullableFilter<"meeting"> | number | null
    createdAt?: DateTimeFilter<"meeting"> | Date | string
    updatedAt?: DateTimeFilter<"meeting"> | Date | string
  }

  export type overtimelogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: overtimelogWhereUniqueInput
    update: XOR<overtimelogUpdateWithoutEmployeeInput, overtimelogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<overtimelogCreateWithoutEmployeeInput, overtimelogUncheckedCreateWithoutEmployeeInput>
  }

  export type overtimelogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: overtimelogWhereUniqueInput
    data: XOR<overtimelogUpdateWithoutEmployeeInput, overtimelogUncheckedUpdateWithoutEmployeeInput>
  }

  export type overtimelogUpdateManyWithWhereWithoutEmployeeInput = {
    where: overtimelogScalarWhereInput
    data: XOR<overtimelogUpdateManyMutationInput, overtimelogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type overtimelogScalarWhereInput = {
    AND?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
    OR?: overtimelogScalarWhereInput[]
    NOT?: overtimelogScalarWhereInput | overtimelogScalarWhereInput[]
    id?: IntFilter<"overtimelog"> | number
    employeeId?: IntFilter<"overtimelog"> | number
    date?: DateTimeFilter<"overtimelog"> | Date | string
    hours?: DecimalNullableFilter<"overtimelog"> | Decimal | DecimalJsLike | number | string | null
    reason?: StringNullableFilter<"overtimelog"> | string | null
    approvedBy?: IntNullableFilter<"overtimelog"> | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFilter<"overtimelog"> | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFilter<"overtimelog"> | $Enums.overtimelog_compensationMethod
    endTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    startTime?: DateTimeNullableFilter<"overtimelog"> | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFilter<"overtimelog"> | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFilter<"overtimelog"> | Date | string
    updatedAt?: DateTimeFilter<"overtimelog"> | Date | string
  }

  export type performancereviewUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: performancereviewWhereUniqueInput
    update: XOR<performancereviewUpdateWithoutEmployeeInput, performancereviewUncheckedUpdateWithoutEmployeeInput>
    create: XOR<performancereviewCreateWithoutEmployeeInput, performancereviewUncheckedCreateWithoutEmployeeInput>
  }

  export type performancereviewUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: performancereviewWhereUniqueInput
    data: XOR<performancereviewUpdateWithoutEmployeeInput, performancereviewUncheckedUpdateWithoutEmployeeInput>
  }

  export type performancereviewUpdateManyWithWhereWithoutEmployeeInput = {
    where: performancereviewScalarWhereInput
    data: XOR<performancereviewUpdateManyMutationInput, performancereviewUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type performancereviewScalarWhereInput = {
    AND?: performancereviewScalarWhereInput | performancereviewScalarWhereInput[]
    OR?: performancereviewScalarWhereInput[]
    NOT?: performancereviewScalarWhereInput | performancereviewScalarWhereInput[]
    id?: IntFilter<"performancereview"> | number
    employeeId?: IntFilter<"performancereview"> | number
    reviewDate?: DateTimeFilter<"performancereview"> | Date | string
    reviewerName?: StringNullableFilter<"performancereview"> | string | null
    score?: IntNullableFilter<"performancereview"> | number | null
    comments?: StringNullableFilter<"performancereview"> | string | null
    createdAt?: DateTimeFilter<"performancereview"> | Date | string
    updatedAt?: DateTimeFilter<"performancereview"> | Date | string
  }

  export type salaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: salaryWhereUniqueInput
    update: XOR<salaryUpdateWithoutEmployeeInput, salaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<salaryCreateWithoutEmployeeInput, salaryUncheckedCreateWithoutEmployeeInput>
  }

  export type salaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: salaryWhereUniqueInput
    data: XOR<salaryUpdateWithoutEmployeeInput, salaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type salaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: salaryScalarWhereInput
    data: XOR<salaryUpdateManyMutationInput, salaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type salaryScalarWhereInput = {
    AND?: salaryScalarWhereInput | salaryScalarWhereInput[]
    OR?: salaryScalarWhereInput[]
    NOT?: salaryScalarWhereInput | salaryScalarWhereInput[]
    id?: IntFilter<"salary"> | number
    employeeId?: IntFilter<"salary"> | number
    salaryMonth?: DateTimeFilter<"salary"> | Date | string
    amount?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFilter<"salary"> | $Enums.salary_status
    overtimeHours?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"salary"> | Date | string | null
    createdAt?: DateTimeFilter<"salary"> | Date | string
    updatedAt?: DateTimeFilter<"salary"> | Date | string
    baseSalary?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"salary"> | Decimal | DecimalJsLike | number | string
  }

  export type terminationUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: terminationWhereUniqueInput
    update: XOR<terminationUpdateWithoutEmployeeInput, terminationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<terminationCreateWithoutEmployeeInput, terminationUncheckedCreateWithoutEmployeeInput>
  }

  export type terminationUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: terminationWhereUniqueInput
    data: XOR<terminationUpdateWithoutEmployeeInput, terminationUncheckedUpdateWithoutEmployeeInput>
  }

  export type terminationUpdateManyWithWhereWithoutEmployeeInput = {
    where: terminationScalarWhereInput
    data: XOR<terminationUpdateManyMutationInput, terminationUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type terminationScalarWhereInput = {
    AND?: terminationScalarWhereInput | terminationScalarWhereInput[]
    OR?: terminationScalarWhereInput[]
    NOT?: terminationScalarWhereInput | terminationScalarWhereInput[]
    id?: IntFilter<"termination"> | number
    employeeId?: IntFilter<"termination"> | number
    terminationDate?: DateTimeFilter<"termination"> | Date | string
    reason?: StringNullableFilter<"termination"> | string | null
    status?: Enumtermination_statusFilter<"termination"> | $Enums.termination_status
    remarks?: StringNullableFilter<"termination"> | string | null
    createdAt?: DateTimeFilter<"termination"> | Date | string
    updatedAt?: DateTimeFilter<"termination"> | Date | string
    workflowStatus?: Enumtermination_workflowStatusFilter<"termination"> | $Enums.termination_workflowStatus
  }

  export type employeeCreateWithoutEmployeeshiftInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutEmployeeshiftInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutEmployeeshiftInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutEmployeeshiftInput, employeeUncheckedCreateWithoutEmployeeshiftInput>
  }

  export type shiftCreateWithoutEmployeeshiftInput = {
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type shiftUncheckedCreateWithoutEmployeeshiftInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type shiftCreateOrConnectWithoutEmployeeshiftInput = {
    where: shiftWhereUniqueInput
    create: XOR<shiftCreateWithoutEmployeeshiftInput, shiftUncheckedCreateWithoutEmployeeshiftInput>
  }

  export type employeeUpsertWithoutEmployeeshiftInput = {
    update: XOR<employeeUpdateWithoutEmployeeshiftInput, employeeUncheckedUpdateWithoutEmployeeshiftInput>
    create: XOR<employeeCreateWithoutEmployeeshiftInput, employeeUncheckedCreateWithoutEmployeeshiftInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutEmployeeshiftInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutEmployeeshiftInput, employeeUncheckedUpdateWithoutEmployeeshiftInput>
  }

  export type employeeUpdateWithoutEmployeeshiftInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutEmployeeshiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type shiftUpsertWithoutEmployeeshiftInput = {
    update: XOR<shiftUpdateWithoutEmployeeshiftInput, shiftUncheckedUpdateWithoutEmployeeshiftInput>
    create: XOR<shiftCreateWithoutEmployeeshiftInput, shiftUncheckedCreateWithoutEmployeeshiftInput>
    where?: shiftWhereInput
  }

  export type shiftUpdateToOneWithWhereWithoutEmployeeshiftInput = {
    where?: shiftWhereInput
    data: XOR<shiftUpdateWithoutEmployeeshiftInput, shiftUncheckedUpdateWithoutEmployeeshiftInput>
  }

  export type shiftUpdateWithoutEmployeeshiftInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shiftUncheckedUpdateWithoutEmployeeshiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeCreateWithoutEmploymenttypeInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutEmploymenttypeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutEmploymenttypeInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput>
  }

  export type employeeCreateManyEmploymenttypeInputEnvelope = {
    data: employeeCreateManyEmploymenttypeInput | employeeCreateManyEmploymenttypeInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutEmploymenttypeInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutEmploymenttypeInput, employeeUncheckedUpdateWithoutEmploymenttypeInput>
    create: XOR<employeeCreateWithoutEmploymenttypeInput, employeeUncheckedCreateWithoutEmploymenttypeInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutEmploymenttypeInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutEmploymenttypeInput, employeeUncheckedUpdateWithoutEmploymenttypeInput>
  }

  export type employeeUpdateManyWithWhereWithoutEmploymenttypeInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutEmploymenttypeInput>
  }

  export type employeeCreateWithoutJobstatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutJobstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutJobstatusInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput>
  }

  export type employeeCreateManyJobstatusInputEnvelope = {
    data: employeeCreateManyJobstatusInput | employeeCreateManyJobstatusInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutJobstatusInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutJobstatusInput, employeeUncheckedUpdateWithoutJobstatusInput>
    create: XOR<employeeCreateWithoutJobstatusInput, employeeUncheckedCreateWithoutJobstatusInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutJobstatusInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutJobstatusInput, employeeUncheckedUpdateWithoutJobstatusInput>
  }

  export type employeeUpdateManyWithWhereWithoutJobstatusInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutJobstatusInput>
  }

  export type userCreateWithoutLeaveInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeCreateNestedOneWithoutUserInput
    overtimelog?: overtimelogCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutLeaveInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeUncheckedCreateNestedOneWithoutUserInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutLeaveInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutLeaveInput, userUncheckedCreateWithoutLeaveInput>
  }

  export type employeeCreateWithoutLeaveInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutLeaveInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutLeaveInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutLeaveInput, employeeUncheckedCreateWithoutLeaveInput>
  }

  export type userUpsertWithoutLeaveInput = {
    update: XOR<userUpdateWithoutLeaveInput, userUncheckedUpdateWithoutLeaveInput>
    create: XOR<userCreateWithoutLeaveInput, userUncheckedCreateWithoutLeaveInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutLeaveInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutLeaveInput, userUncheckedUpdateWithoutLeaveInput>
  }

  export type userUpdateWithoutLeaveInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUpdateOneWithoutUserNestedInput
    overtimelog?: overtimelogUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUncheckedUpdateOneWithoutUserNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type employeeUpsertWithoutLeaveInput = {
    update: XOR<employeeUpdateWithoutLeaveInput, employeeUncheckedUpdateWithoutLeaveInput>
    create: XOR<employeeCreateWithoutLeaveInput, employeeUncheckedCreateWithoutLeaveInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutLeaveInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutLeaveInput, employeeUncheckedUpdateWithoutLeaveInput>
  }

  export type employeeUpdateWithoutLeaveInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutLeaveInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateWithoutMaritalstatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutMaritalstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutMaritalstatusInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput>
  }

  export type employeeCreateManyMaritalstatusInputEnvelope = {
    data: employeeCreateManyMaritalstatusInput | employeeCreateManyMaritalstatusInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutMaritalstatusInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutMaritalstatusInput, employeeUncheckedUpdateWithoutMaritalstatusInput>
    create: XOR<employeeCreateWithoutMaritalstatusInput, employeeUncheckedCreateWithoutMaritalstatusInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutMaritalstatusInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutMaritalstatusInput, employeeUncheckedUpdateWithoutMaritalstatusInput>
  }

  export type employeeUpdateManyWithWhereWithoutMaritalstatusInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutMaritalstatusInput>
  }

  export type employeeCreateWithoutMeetingInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutMeetingInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutMeetingInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutMeetingInput, employeeUncheckedCreateWithoutMeetingInput>
  }

  export type employeeUpsertWithoutMeetingInput = {
    update: XOR<employeeUpdateWithoutMeetingInput, employeeUncheckedUpdateWithoutMeetingInput>
    create: XOR<employeeCreateWithoutMeetingInput, employeeUncheckedCreateWithoutMeetingInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutMeetingInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutMeetingInput, employeeUncheckedUpdateWithoutMeetingInput>
  }

  export type employeeUpdateWithoutMeetingInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutMeetingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type userCreateWithoutOvertimelogInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeCreateNestedOneWithoutUserInput
    leave?: leaveCreateNestedManyWithoutUserInput
    userrole?: userroleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOvertimelogInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeUncheckedCreateNestedOneWithoutUserInput
    leave?: leaveUncheckedCreateNestedManyWithoutUserInput
    userrole?: userroleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOvertimelogInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOvertimelogInput, userUncheckedCreateWithoutOvertimelogInput>
  }

  export type employeeCreateWithoutOvertimelogInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutOvertimelogInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutOvertimelogInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutOvertimelogInput, employeeUncheckedCreateWithoutOvertimelogInput>
  }

  export type userUpsertWithoutOvertimelogInput = {
    update: XOR<userUpdateWithoutOvertimelogInput, userUncheckedUpdateWithoutOvertimelogInput>
    create: XOR<userCreateWithoutOvertimelogInput, userUncheckedCreateWithoutOvertimelogInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutOvertimelogInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutOvertimelogInput, userUncheckedUpdateWithoutOvertimelogInput>
  }

  export type userUpdateWithoutOvertimelogInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUpdateOneWithoutUserNestedInput
    leave?: leaveUpdateManyWithoutUserNestedInput
    userrole?: userroleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOvertimelogInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUncheckedUpdateOneWithoutUserNestedInput
    leave?: leaveUncheckedUpdateManyWithoutUserNestedInput
    userrole?: userroleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type employeeUpsertWithoutOvertimelogInput = {
    update: XOR<employeeUpdateWithoutOvertimelogInput, employeeUncheckedUpdateWithoutOvertimelogInput>
    create: XOR<employeeCreateWithoutOvertimelogInput, employeeUncheckedCreateWithoutOvertimelogInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutOvertimelogInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutOvertimelogInput, employeeUncheckedUpdateWithoutOvertimelogInput>
  }

  export type employeeUpdateWithoutOvertimelogInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutOvertimelogInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type departmentCreateWithoutPayrollpolicyInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    attendancesummary?: attendancesummaryCreateNestedManyWithoutDepartmentInput
    department?: departmentCreateNestedOneWithoutOther_departmentInput
    other_department?: departmentCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentUncheckedCreateWithoutPayrollpolicyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutDepartmentInput
    other_department?: departmentUncheckedCreateNestedManyWithoutDepartmentInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_departmentIdTodepartmentInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedCreateNestedManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput
  }

  export type departmentCreateOrConnectWithoutPayrollpolicyInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput>
  }

  export type departmentCreateManyPayrollpolicyInputEnvelope = {
    data: departmentCreateManyPayrollpolicyInput | departmentCreateManyPayrollpolicyInput[]
    skipDuplicates?: boolean
  }

  export type departmentUpsertWithWhereUniqueWithoutPayrollpolicyInput = {
    where: departmentWhereUniqueInput
    update: XOR<departmentUpdateWithoutPayrollpolicyInput, departmentUncheckedUpdateWithoutPayrollpolicyInput>
    create: XOR<departmentCreateWithoutPayrollpolicyInput, departmentUncheckedCreateWithoutPayrollpolicyInput>
  }

  export type departmentUpdateWithWhereUniqueWithoutPayrollpolicyInput = {
    where: departmentWhereUniqueInput
    data: XOR<departmentUpdateWithoutPayrollpolicyInput, departmentUncheckedUpdateWithoutPayrollpolicyInput>
  }

  export type departmentUpdateManyWithWhereWithoutPayrollpolicyInput = {
    where: departmentScalarWhereInput
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyWithoutPayrollpolicyInput>
  }

  export type employeeCreateWithoutPerformancereviewInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutPerformancereviewInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutPerformancereviewInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutPerformancereviewInput, employeeUncheckedCreateWithoutPerformancereviewInput>
  }

  export type employeeUpsertWithoutPerformancereviewInput = {
    update: XOR<employeeUpdateWithoutPerformancereviewInput, employeeUncheckedUpdateWithoutPerformancereviewInput>
    create: XOR<employeeCreateWithoutPerformancereviewInput, employeeUncheckedCreateWithoutPerformancereviewInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutPerformancereviewInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutPerformancereviewInput, employeeUncheckedUpdateWithoutPerformancereviewInput>
  }

  export type employeeUpdateWithoutPerformancereviewInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutPerformancereviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateWithoutPositionInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutPositionInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutPositionInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput>
  }

  export type employeeCreateManyPositionInputEnvelope = {
    data: employeeCreateManyPositionInput | employeeCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithWhereUniqueWithoutPositionInput = {
    where: employeeWhereUniqueInput
    update: XOR<employeeUpdateWithoutPositionInput, employeeUncheckedUpdateWithoutPositionInput>
    create: XOR<employeeCreateWithoutPositionInput, employeeUncheckedCreateWithoutPositionInput>
  }

  export type employeeUpdateWithWhereUniqueWithoutPositionInput = {
    where: employeeWhereUniqueInput
    data: XOR<employeeUpdateWithoutPositionInput, employeeUncheckedUpdateWithoutPositionInput>
  }

  export type employeeUpdateManyWithWhereWithoutPositionInput = {
    where: employeeScalarWhereInput
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyWithoutPositionInput>
  }

  export type userroleCreateWithoutRoleInput = {
    user: userCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutRoleInput = {
    userId: number
  }

  export type userroleCreateOrConnectWithoutRoleInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleCreateManyRoleInputEnvelope = {
    data: userroleCreateManyRoleInput | userroleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type userroleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
    create: XOR<userroleCreateWithoutRoleInput, userroleUncheckedCreateWithoutRoleInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutRoleInput, userroleUncheckedUpdateWithoutRoleInput>
  }

  export type userroleUpdateManyWithWhereWithoutRoleInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutRoleInput>
  }

  export type userroleScalarWhereInput = {
    AND?: userroleScalarWhereInput | userroleScalarWhereInput[]
    OR?: userroleScalarWhereInput[]
    NOT?: userroleScalarWhereInput | userroleScalarWhereInput[]
    userId?: IntFilter<"userrole"> | number
    roleId?: IntFilter<"userrole"> | number
  }

  export type employeeCreateWithoutSalaryRecordsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutSalaryRecordsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutSalaryRecordsInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutSalaryRecordsInput, employeeUncheckedCreateWithoutSalaryRecordsInput>
  }

  export type employeeUpsertWithoutSalaryRecordsInput = {
    update: XOR<employeeUpdateWithoutSalaryRecordsInput, employeeUncheckedUpdateWithoutSalaryRecordsInput>
    create: XOR<employeeCreateWithoutSalaryRecordsInput, employeeUncheckedCreateWithoutSalaryRecordsInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutSalaryRecordsInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutSalaryRecordsInput, employeeUncheckedUpdateWithoutSalaryRecordsInput>
  }

  export type employeeUpdateWithoutSalaryRecordsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutSalaryRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type attendancelogCreateWithoutSessiondefinitionInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
    employee: employeeCreateNestedOneWithoutAttendancelogInput
  }

  export type attendancelogUncheckedCreateWithoutSessiondefinitionInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancelogCreateOrConnectWithoutSessiondefinitionInput = {
    where: attendancelogWhereUniqueInput
    create: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput>
  }

  export type attendancelogCreateManySessiondefinitionInputEnvelope = {
    data: attendancelogCreateManySessiondefinitionInput | attendancelogCreateManySessiondefinitionInput[]
    skipDuplicates?: boolean
  }

  export type attendancelogUpsertWithWhereUniqueWithoutSessiondefinitionInput = {
    where: attendancelogWhereUniqueInput
    update: XOR<attendancelogUpdateWithoutSessiondefinitionInput, attendancelogUncheckedUpdateWithoutSessiondefinitionInput>
    create: XOR<attendancelogCreateWithoutSessiondefinitionInput, attendancelogUncheckedCreateWithoutSessiondefinitionInput>
  }

  export type attendancelogUpdateWithWhereUniqueWithoutSessiondefinitionInput = {
    where: attendancelogWhereUniqueInput
    data: XOR<attendancelogUpdateWithoutSessiondefinitionInput, attendancelogUncheckedUpdateWithoutSessiondefinitionInput>
  }

  export type attendancelogUpdateManyWithWhereWithoutSessiondefinitionInput = {
    where: attendancelogScalarWhereInput
    data: XOR<attendancelogUpdateManyMutationInput, attendancelogUncheckedUpdateManyWithoutSessiondefinitionInput>
  }

  export type employeeshiftCreateWithoutShiftInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    employee: employeeCreateNestedOneWithoutEmployeeshiftInput
  }

  export type employeeshiftUncheckedCreateWithoutShiftInput = {
    id?: number
    employeeId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type employeeshiftCreateOrConnectWithoutShiftInput = {
    where: employeeshiftWhereUniqueInput
    create: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput>
  }

  export type employeeshiftCreateManyShiftInputEnvelope = {
    data: employeeshiftCreateManyShiftInput | employeeshiftCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type employeeshiftUpsertWithWhereUniqueWithoutShiftInput = {
    where: employeeshiftWhereUniqueInput
    update: XOR<employeeshiftUpdateWithoutShiftInput, employeeshiftUncheckedUpdateWithoutShiftInput>
    create: XOR<employeeshiftCreateWithoutShiftInput, employeeshiftUncheckedCreateWithoutShiftInput>
  }

  export type employeeshiftUpdateWithWhereUniqueWithoutShiftInput = {
    where: employeeshiftWhereUniqueInput
    data: XOR<employeeshiftUpdateWithoutShiftInput, employeeshiftUncheckedUpdateWithoutShiftInput>
  }

  export type employeeshiftUpdateManyWithWhereWithoutShiftInput = {
    where: employeeshiftScalarWhereInput
    data: XOR<employeeshiftUpdateManyMutationInput, employeeshiftUncheckedUpdateManyWithoutShiftInput>
  }

  export type employeeCreateWithoutTerminationInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    user?: userCreateNestedOneWithoutEmployeeInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutTerminationInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutTerminationInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutTerminationInput, employeeUncheckedCreateWithoutTerminationInput>
  }

  export type employeeUpsertWithoutTerminationInput = {
    update: XOR<employeeUpdateWithoutTerminationInput, employeeUncheckedUpdateWithoutTerminationInput>
    create: XOR<employeeCreateWithoutTerminationInput, employeeUncheckedCreateWithoutTerminationInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutTerminationInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutTerminationInput, employeeUncheckedUpdateWithoutTerminationInput>
  }

  export type employeeUpdateWithoutTerminationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutTerminationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateWithoutUserInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryCreateNestedManyWithoutEmployeeInput
    complaint?: complaintCreateNestedManyWithoutEmployeeInput
    agreementstatus?: agreementstatusCreateNestedOneWithoutEmployeeInput
    department_employee_departmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_departmentIdTodepartmentInput
    employmenttype?: employmenttypeCreateNestedOneWithoutEmployeeInput
    jobstatus?: jobstatusCreateNestedOneWithoutEmployeeInput
    maritalstatus?: maritalstatusCreateNestedOneWithoutEmployeeInput
    position?: positionCreateNestedOneWithoutEmployeeInput
    department_employee_subDepartmentIdTodepartment?: departmentCreateNestedOneWithoutEmployee_employee_subDepartmentIdTodepartmentInput
    employeeshift?: employeeshiftCreateNestedManyWithoutEmployeeInput
    leave?: leaveCreateNestedManyWithoutEmployeeInput
    meeting?: meetingCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryCreateNestedManyWithoutEmployeeInput
    termination?: terminationCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutUserInput = {
    id?: number
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_actorIdToemployeeInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedCreateNestedManyWithoutEmployee_activitylog_targetIdToemployeeInput
    attendancelog?: attendancelogUncheckedCreateNestedManyWithoutEmployeeInput
    attendancesummary?: attendancesummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaint?: complaintUncheckedCreateNestedManyWithoutEmployeeInput
    employeeshift?: employeeshiftUncheckedCreateNestedManyWithoutEmployeeInput
    leave?: leaveUncheckedCreateNestedManyWithoutEmployeeInput
    meeting?: meetingUncheckedCreateNestedManyWithoutEmployeeInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutEmployeeInput
    performancereview?: performancereviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaryRecords?: salaryUncheckedCreateNestedManyWithoutEmployeeInput
    termination?: terminationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutUserInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
  }

  export type leaveCreateWithoutUserInput = {
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    requestedAt?: Date | string
    updatedAt: Date | string
    employee: employeeCreateNestedOneWithoutLeaveInput
  }

  export type leaveUncheckedCreateWithoutUserInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type leaveCreateOrConnectWithoutUserInput = {
    where: leaveWhereUniqueInput
    create: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput>
  }

  export type leaveCreateManyUserInputEnvelope = {
    data: leaveCreateManyUserInput | leaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type overtimelogCreateWithoutUserInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: employeeCreateNestedOneWithoutOvertimelogInput
  }

  export type overtimelogUncheckedCreateWithoutUserInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type overtimelogCreateOrConnectWithoutUserInput = {
    where: overtimelogWhereUniqueInput
    create: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput>
  }

  export type overtimelogCreateManyUserInputEnvelope = {
    data: overtimelogCreateManyUserInput | overtimelogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type userroleCreateWithoutUserInput = {
    role: roleCreateNestedOneWithoutUserroleInput
  }

  export type userroleUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type userroleCreateOrConnectWithoutUserInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleCreateManyUserInputEnvelope = {
    data: userroleCreateManyUserInput | userroleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type employeeUpsertWithoutUserInput = {
    update: XOR<employeeUpdateWithoutUserInput, employeeUncheckedUpdateWithoutUserInput>
    create: XOR<employeeCreateWithoutUserInput, employeeUncheckedCreateWithoutUserInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutUserInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutUserInput, employeeUncheckedUpdateWithoutUserInput>
  }

  export type employeeUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type leaveUpsertWithWhereUniqueWithoutUserInput = {
    where: leaveWhereUniqueInput
    update: XOR<leaveUpdateWithoutUserInput, leaveUncheckedUpdateWithoutUserInput>
    create: XOR<leaveCreateWithoutUserInput, leaveUncheckedCreateWithoutUserInput>
  }

  export type leaveUpdateWithWhereUniqueWithoutUserInput = {
    where: leaveWhereUniqueInput
    data: XOR<leaveUpdateWithoutUserInput, leaveUncheckedUpdateWithoutUserInput>
  }

  export type leaveUpdateManyWithWhereWithoutUserInput = {
    where: leaveScalarWhereInput
    data: XOR<leaveUpdateManyMutationInput, leaveUncheckedUpdateManyWithoutUserInput>
  }

  export type overtimelogUpsertWithWhereUniqueWithoutUserInput = {
    where: overtimelogWhereUniqueInput
    update: XOR<overtimelogUpdateWithoutUserInput, overtimelogUncheckedUpdateWithoutUserInput>
    create: XOR<overtimelogCreateWithoutUserInput, overtimelogUncheckedCreateWithoutUserInput>
  }

  export type overtimelogUpdateWithWhereUniqueWithoutUserInput = {
    where: overtimelogWhereUniqueInput
    data: XOR<overtimelogUpdateWithoutUserInput, overtimelogUncheckedUpdateWithoutUserInput>
  }

  export type overtimelogUpdateManyWithWhereWithoutUserInput = {
    where: overtimelogScalarWhereInput
    data: XOR<overtimelogUpdateManyMutationInput, overtimelogUncheckedUpdateManyWithoutUserInput>
  }

  export type userroleUpsertWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    update: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
    create: XOR<userroleCreateWithoutUserInput, userroleUncheckedCreateWithoutUserInput>
  }

  export type userroleUpdateWithWhereUniqueWithoutUserInput = {
    where: userroleWhereUniqueInput
    data: XOR<userroleUpdateWithoutUserInput, userroleUncheckedUpdateWithoutUserInput>
  }

  export type userroleUpdateManyWithWhereWithoutUserInput = {
    where: userroleScalarWhereInput
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyWithoutUserInput>
  }

  export type roleCreateWithoutUserroleInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type roleUncheckedCreateWithoutUserroleInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type roleCreateOrConnectWithoutUserroleInput = {
    where: roleWhereUniqueInput
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
  }

  export type userCreateWithoutUserroleInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeCreateNestedOneWithoutUserInput
    leave?: leaveCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutUserroleInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    notifyOnComplaint?: boolean
    employee?: employeeUncheckedCreateNestedOneWithoutUserInput
    leave?: leaveUncheckedCreateNestedManyWithoutUserInput
    overtimelog?: overtimelogUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutUserroleInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
  }

  export type roleUpsertWithoutUserroleInput = {
    update: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
    create: XOR<roleCreateWithoutUserroleInput, roleUncheckedCreateWithoutUserroleInput>
    where?: roleWhereInput
  }

  export type roleUpdateToOneWithWhereWithoutUserroleInput = {
    where?: roleWhereInput
    data: XOR<roleUpdateWithoutUserroleInput, roleUncheckedUpdateWithoutUserroleInput>
  }

  export type roleUpdateWithoutUserroleInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type roleUncheckedUpdateWithoutUserroleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUpsertWithoutUserroleInput = {
    update: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
    create: XOR<userCreateWithoutUserroleInput, userUncheckedCreateWithoutUserroleInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutUserroleInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutUserroleInput, userUncheckedUpdateWithoutUserroleInput>
  }

  export type userUpdateWithoutUserroleInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUpdateOneWithoutUserNestedInput
    leave?: leaveUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutUserroleInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employee?: employeeUncheckedUpdateOneWithoutUserNestedInput
    leave?: leaveUncheckedUpdateManyWithoutUserNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type employeeCreateManyAgreementstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateWithoutAgreementstatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutAgreementstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutAgreementstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type attendancesummaryCreateManyDepartmentInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
  }

  export type departmentCreateManyDepartmentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    payrollPolicyId?: number | null
  }

  export type employeeCreateManyDepartment_employee_departmentIdTodepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeCreateManyDepartment_employee_subDepartmentIdTodepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type attendancesummaryUpdateWithoutDepartmentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: employeeUpdateOneRequiredWithoutAttendancesummaryNestedInput
  }

  export type attendancesummaryUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendancesummaryUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type departmentUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    payrollpolicy?: payrollpolicyUpdateOneWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeUpdateWithoutDepartment_employee_departmentIdTodepartmentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutDepartment_employee_departmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogCreateManyEmployee_activitylog_actorIdToemployeeInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    targetId?: number | null
    departmentId: number
    createdAt?: Date | string
  }

  export type activitylogCreateManyEmployee_activitylog_targetIdToemployeeInput = {
    id?: number
    type: $Enums.activitylog_type
    message: string
    actorId: number
    departmentId: number
    createdAt?: Date | string
  }

  export type attendancelogCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancesummaryCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    status: $Enums.attendancesummary_status
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type complaintCreateManyEmployeeInput = {
    id?: number
    subject: string
    description: string
    status?: $Enums.complaint_status
    response?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type employeeshiftCreateManyEmployeeInput = {
    id?: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type leaveCreateManyEmployeeInput = {
    id?: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type meetingCreateManyEmployeeInput = {
    id?: number
    title: string
    description?: string | null
    date: Date | string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type overtimelogCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type performancereviewCreateManyEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type salaryCreateManyEmployeeInput = {
    id?: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.salary_status
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    baseSalary?: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
  }

  export type terminationCreateManyEmployeeInput = {
    id?: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.termination_status
    remarks?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    workflowStatus?: $Enums.termination_workflowStatus
  }

  export type activitylogUpdateWithoutEmployee_activitylog_actorIdToemployeeInput = {
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_activitylog_targetIdToemployee?: employeeUpdateOneWithoutActivitylog_activitylog_targetIdToemployeeNestedInput
  }

  export type activitylogUncheckedUpdateWithoutEmployee_activitylog_actorIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    targetId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUpdateWithoutEmployee_activitylog_targetIdToemployeeInput = {
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee_activitylog_actorIdToemployee?: employeeUpdateOneRequiredWithoutActivitylog_activitylog_actorIdToemployeeNestedInput
  }

  export type activitylogUncheckedUpdateWithoutEmployee_activitylog_targetIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumactivitylog_typeFieldUpdateOperationsInput | $Enums.activitylog_type
    message?: StringFieldUpdateOperationsInput | string
    actorId?: IntFieldUpdateOperationsInput | number
    departmentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancelogUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessiondefinition?: sessiondefinitionUpdateOneRequiredWithoutAttendancelogNestedInput
  }

  export type attendancelogUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancelogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancesummaryUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    department?: departmentUpdateOneWithoutAttendancesummaryNestedInput
  }

  export type attendancesummaryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type attendancesummaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumattendancesummary_statusFieldUpdateOperationsInput | $Enums.attendancesummary_status
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type complaintUpdateWithoutEmployeeInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type complaintUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: Enumcomplaint_statusFieldUpdateOperationsInput | $Enums.complaint_status
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeeshiftUpdateWithoutEmployeeInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shift?: shiftUpdateOneRequiredWithoutEmployeeshiftNestedInput
  }

  export type employeeshiftUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeshiftUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type leaveUpdateWithoutEmployeeInput = {
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutLeaveNestedInput
  }

  export type leaveUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingUpdateWithoutEmployeeInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type meetingUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutOvertimelogNestedInput
  }

  export type overtimelogUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type performancereviewUpdateWithoutEmployeeInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type performancereviewUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type performancereviewUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type salaryUpdateWithoutEmployeeInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type salaryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type salaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: Enumsalary_statusFieldUpdateOperationsInput | $Enums.salary_status
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type terminationUpdateWithoutEmployeeInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type terminationUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type terminationUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: Enumtermination_statusFieldUpdateOperationsInput | $Enums.termination_status
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflowStatus?: Enumtermination_workflowStatusFieldUpdateOperationsInput | $Enums.termination_workflowStatus
  }

  export type employeeCreateManyEmploymenttypeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateWithoutEmploymenttypeInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutEmploymenttypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutEmploymenttypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeCreateManyJobstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateWithoutJobstatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutJobstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutJobstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeCreateManyMaritalstatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    departmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateWithoutMaritalstatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    position?: positionUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutMaritalstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutMaritalstatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type departmentCreateManyPayrollpolicyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    parentId?: number | null
  }

  export type departmentUpdateWithoutPayrollpolicyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendancesummary?: attendancesummaryUpdateManyWithoutDepartmentNestedInput
    department?: departmentUpdateOneWithoutOther_departmentNestedInput
    other_department?: departmentUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateWithoutPayrollpolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutDepartmentNestedInput
    other_department?: departmentUncheckedUpdateManyWithoutDepartmentNestedInput
    employee_employee_departmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_departmentIdTodepartmentNestedInput
    employee_employee_subDepartmentIdTodepartment?: employeeUncheckedUpdateManyWithoutDepartment_employee_subDepartmentIdTodepartmentNestedInput
  }

  export type departmentUncheckedUpdateManyWithoutPayrollpolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeCreateManyPositionInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.employee_sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt: Date | string
    subDepartmentId?: number | null
  }

  export type employeeUpdateWithoutPositionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitylog_activitylog_actorIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUpdateManyWithoutEmployeeNestedInput
    agreementstatus?: agreementstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_departmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_departmentIdTodepartmentNestedInput
    employmenttype?: employmenttypeUpdateOneWithoutEmployeeNestedInput
    jobstatus?: jobstatusUpdateOneWithoutEmployeeNestedInput
    maritalstatus?: maritalstatusUpdateOneWithoutEmployeeNestedInput
    department_employee_subDepartmentIdTodepartment?: departmentUpdateOneWithoutEmployee_employee_subDepartmentIdTodepartmentNestedInput
    user?: userUpdateOneWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    activitylog_activitylog_actorIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_actorIdToemployeeNestedInput
    activitylog_activitylog_targetIdToemployee?: activitylogUncheckedUpdateManyWithoutEmployee_activitylog_targetIdToemployeeNestedInput
    attendancelog?: attendancelogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendancesummary?: attendancesummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaint?: complaintUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeshift?: employeeshiftUncheckedUpdateManyWithoutEmployeeNestedInput
    leave?: leaveUncheckedUpdateManyWithoutEmployeeNestedInput
    meeting?: meetingUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimelog?: overtimelogUncheckedUpdateManyWithoutEmployeeNestedInput
    performancereview?: performancereviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryRecords?: salaryUncheckedUpdateManyWithoutEmployeeNestedInput
    termination?: terminationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: Enumemployee_sexFieldUpdateOperationsInput | $Enums.employee_sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userroleCreateManyRoleInput = {
    userId: number
  }

  export type userroleUpdateWithoutRoleInput = {
    user?: userUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type attendancelogCreateManySessiondefinitionInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.attendancelog_status
    createdAt?: Date | string
  }

  export type attendancelogUpdateWithoutSessiondefinitionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutAttendancelogNestedInput
  }

  export type attendancelogUncheckedUpdateWithoutSessiondefinitionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type attendancelogUncheckedUpdateManyWithoutSessiondefinitionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumattendancelog_statusFieldUpdateOperationsInput | $Enums.attendancelog_status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeeshiftCreateManyShiftInput = {
    id?: number
    employeeId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type employeeshiftUpdateWithoutShiftInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: employeeUpdateOneRequiredWithoutEmployeeshiftNestedInput
  }

  export type employeeshiftUncheckedUpdateWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeshiftUncheckedUpdateManyWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type leaveCreateManyUserInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.leave_leaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.leave_status
    reason?: string | null
    requestedAt?: Date | string
    updatedAt: Date | string
  }

  export type overtimelogCreateManyUserInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    reason?: string | null
    approvalStatus?: $Enums.overtimelog_approvalStatus
    compensationMethod?: $Enums.overtimelog_compensationMethod
    endTime?: Date | string | null
    startTime?: Date | string | null
    overtimeType?: $Enums.overtimelog_overtimeType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userroleCreateManyUserInput = {
    roleId: number
  }

  export type leaveUpdateWithoutUserInput = {
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutLeaveNestedInput
  }

  export type leaveUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type leaveUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: Enumleave_leaveTypeFieldUpdateOperationsInput | $Enums.leave_leaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumleave_statusFieldUpdateOperationsInput | $Enums.leave_status
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: employeeUpdateOneRequiredWithoutOvertimelogNestedInput
  }

  export type overtimelogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type overtimelogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: Enumovertimelog_approvalStatusFieldUpdateOperationsInput | $Enums.overtimelog_approvalStatus
    compensationMethod?: Enumovertimelog_compensationMethodFieldUpdateOperationsInput | $Enums.overtimelog_compensationMethod
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    overtimeType?: Enumovertimelog_overtimeTypeFieldUpdateOperationsInput | $Enums.overtimelog_overtimeType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userroleUpdateWithoutUserInput = {
    role?: roleUpdateOneRequiredWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type userroleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}